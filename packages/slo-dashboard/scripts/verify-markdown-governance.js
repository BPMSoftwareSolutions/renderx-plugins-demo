#!/usr/bin/env node

/**
 * Markdown Governance Verification Script
 * 
 * Purpose: Enforce JSON-driven automation policy
 * - Detect manual .md files in .generated/
 * - Verify checksums match auto-generated versions
 * - Block commits with governance violations
 * - Report compliance metrics
 * 
 * Policy: ALL markdown files in .generated/ must be auto-generated from JSON
 * 
 * Usage:
 *   npm run verify:markdown-governance            # Run verification
 *   npm run verify:markdown-governance -- --fix   # Auto-fix by regenerating
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const { execSync } = require('child_process');

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  packagePath: path.join(__dirname, '..'),
  generatedPath: path.join(__dirname, '..', '.generated'),
  authorityFile: path.join(__dirname, '..', '.generated', 'MARKDOWN_GENERATION_AUTHORITY.json'),
  
  authorizedManualMarkdown: [
    'README.md',  // In package root (not .generated/)
    'RECOVERY_REPORT.md'  // In package root (not .generated/)
  ],
  
  mustBeAutoGenerated: [
    'CONTEXT_TREE_AUDIT_SESSION.md',
    'SESSION_SUMMARY.md',
    'NEXT_SESSION_HANDOFF.md',
    'README.md',  // In .generated/ only
    'MASTER_INDEX.md'
  ]
};

// ============================================================================
// UTILITIES
// ============================================================================

function loadAuthority() {
  try {
    const content = fs.readFileSync(CONFIG.authorityFile, 'utf8');
    return JSON.parse(content);
  } catch (error) {
    console.error('‚ùå Failed to load governance authority:', error.message);
    process.exit(1);
  }
}

function _calculateChecksum(content) {
  return crypto.createHash('sha256').update(content).digest('hex');
}

function _extractChecksumFromMarkdown(_filePath) {
  // Checksums could be in header comments
  // For now, we regenerate and compare
  return null;
}

function isAutoGeneratedFile(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    // Check for auto-generation header
    const hasAutoGenHeader = content.includes('AUTO-GENERATED FILE');
    const hasDoNotEditWarning = content.includes('Do not edit manually') || 
                                content.includes('DO NOT EDIT MANUALLY');
    
    // Debug logging
    if (process.env.DEBUG_GOVERNANCE) {
      console.log(`\n[DEBUG] Checking: ${path.basename(filePath)}`);
      console.log(`  - Has AUTO-GENERATED FILE: ${hasAutoGenHeader}`);
      console.log(`  - Has DO NOT EDIT: ${hasDoNotEditWarning}`);
      console.log(`  - Result: ${hasAutoGenHeader && hasDoNotEditWarning}`);
    }
    
    return hasAutoGenHeader && hasDoNotEditWarning;
  } catch (error) {
    console.error(`[ERROR] Failed to check file: ${filePath}`, error);
    return false;
  }
}

// ============================================================================
// VERIFICATION LOGIC
// ============================================================================

function verifyMarkdownGovernance(_options = {}) {
  console.log('\nüîç Markdown Governance Verification');
  console.log('‚ïê'.repeat(60));
  console.log('Policy: JSON-Driven Automation');
  console.log('Rule: All .md files in .generated/ must be auto-generated\n');
  
  loadAuthority();  // Load and validate authority exists
  const violations = [];
  const compliant = [];
  
  // Check .generated/ directory
  console.log('üìã Scanning .generated/ directory...\n');
  
  if (!fs.existsSync(CONFIG.generatedPath)) {
    console.error('‚ùå .generated/ directory not found');
    return { success: false, violations: [], compliant: [] };
  }
  
  const files = fs.readdirSync(CONFIG.generatedPath);
  
  // Check markdown files
  files.forEach(file => {
    if (!file.endsWith('.md')) return;
    
    const filePath = path.join(CONFIG.generatedPath, file);
    const isAutoGen = isAutoGeneratedFile(filePath);
    
    if (CONFIG.mustBeAutoGenerated.includes(file)) {
      if (!isAutoGen) {
        violations.push({
          file: file,
          reason: 'MANUAL CREATION - Must be auto-generated',
          severity: 'CRITICAL',
          fix: 'Delete and regenerate using: npm run generate:all'
        });
        console.log(`‚ùå ${file} - MANUAL CREATION (violation)`);
      } else {
        compliant.push(file);
        console.log(`‚úÖ ${file} - Auto-generated (compliant)`);
      }
    }
  });
  
  // Check for unauthorized manual markdown in .generated/
  files.forEach(file => {
    if (!file.endsWith('.md')) return;
    if (CONFIG.mustBeAutoGenerated.includes(file)) return;
    
    const filePath = path.join(CONFIG.generatedPath, file);
    const isAutoGen = isAutoGeneratedFile(filePath);
    
    if (!isAutoGen) {
      violations.push({
        file: file,
        reason: 'UNAUTHORIZED - Manual markdown in .generated/',
        severity: 'HIGH',
        fix: 'Delete this file or move to authorized location'
      });
      console.log(`‚ö†Ô∏è  ${file} - UNAUTHORIZED MANUAL FILE (violation)`);
    }
  });
  
  // Summary
  console.log('\n' + '‚ïê'.repeat(60));
  console.log(`\nüìä Verification Results:`);
  console.log(`   ‚úÖ Compliant: ${compliant.length}`);
  console.log(`   ‚ùå Violations: ${violations.length}\n`);
  
  if (violations.length > 0) {
    console.log('üö® Violations Detected:\n');
    violations.forEach((v, i) => {
      console.log(`${i + 1}. ${v.file}`);
      console.log(`   Reason: ${v.reason}`);
      console.log(`   Severity: ${v.severity}`);
      console.log(`   Fix: ${v.fix}\n`);
    });
  } else {
    console.log('‚úÖ ALL MARKDOWN FILES COMPLY WITH GOVERNANCE POLICY\n');
  }
  
  return {
    success: violations.length === 0,
    violations,
    compliant,
    summary: {
      total: compliant.length + violations.length,
      compliant: compliant.length,
      violations: violations.length,
      complianceRate: (compliant.length / (compliant.length + violations.length) * 100).toFixed(1) + '%'
    }
  };
}

// ============================================================================
// AUTO-FIX LOGIC
// ============================================================================

function autoFixViolations(verificationResult) {
  console.log('\nüîß Auto-Fixing Violations...\n');
  
  const violationsToFix = verificationResult.violations
    .filter(v => v.reason === 'MANUAL CREATION - Must be auto-generated');
  
  if (violationsToFix.length === 0) {
    console.log('‚úÖ No violations to fix\n');
    return;
  }
  
  console.log(`Fixing ${violationsToFix.length} violations:\n`);
  
  violationsToFix.forEach(v => {
    console.log(`üóëÔ∏è  Deleting: ${v.file}`);
    try {
      const filePath = path.join(CONFIG.generatedPath, v.file);
      fs.unlinkSync(filePath);
      console.log(`   ‚úÖ Deleted\n`);
    } catch (error) {
      console.error(`   ‚ùå Failed to delete: ${error.message}\n`);
    }
  });
  
  // Regenerate all markdown
  console.log('üìù Regenerating markdown files...\n');
  try {
    execSync('npm run generate:all', { 
      cwd: CONFIG.packagePath,
      stdio: 'inherit'
    });
    console.log('\n‚úÖ All markdown files regenerated\n');
  } catch (error) {
    console.error('‚ùå Failed to regenerate:', error.message);
    process.exit(1);
  }
}

// ============================================================================
// MAIN ENTRY POINT
// ============================================================================

const args = process.argv.slice(2);
const options = {
  fix: args.includes('--fix'),
  verbose: args.includes('--verbose')
};

try {
  const result = verifyMarkdownGovernance(options);
  
  if (options.fix && !result.success) {
    autoFixViolations(result);
    // Re-verify after fix
    const recheck = verifyMarkdownGovernance(options);
    process.exit(recheck.success ? 0 : 1);
  }
  
  process.exit(result.success ? 0 : 1);
} catch (error) {
  console.error('‚ùå Verification failed:', error.message);
  process.exit(1);
}
