#!/usr/bin/env node

/**
 * Domain Documentation Index Generator
 * 
 * Purpose: Generate INDEX.md files for each documentation domain
 *          showing what docs belong in that domain and their drift status
 * 
 * Generates:
 *   - docs/generated/{domain-id}/INDEX.md (auto-generated)
 *   - docs/manual/{domain-id}/INDEX.md (auto-generated)
 *   - docs/GLOBAL_DOCUMENTATION_INDEX.md (auto-generated)
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT = path.join(__dirname, '..');
const PROJECT_PLAN = path.join(ROOT, 'orchestration-audit-system-project-plan.json');
const DRIFT_MANIFEST = path.join(ROOT, '.generated/document-governance-manifest.json');

// Ensure directory exists
function ensureDir(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

// Read project plan
function readProjectPlan() {
  return JSON.parse(fs.readFileSync(PROJECT_PLAN, 'utf-8'));
}

// Read drift manifest
function readDriftManifest() {
  if (!fs.existsSync(DRIFT_MANIFEST)) {
    return null;
  }
  return JSON.parse(fs.readFileSync(DRIFT_MANIFEST, 'utf-8'));
}

// Generate domain index
function generateDomainIndex(domain, driftManifest) {
  const lines = [];

  lines.push('<!-- AUTO-GENERATED -->');
  lines.push(`<!-- Source: orchestration-audit-system-project-plan.json (domainDocumentationMapping) -->`);
  lines.push(`<!-- Generated: ${new Date().toISOString()} -->`);
  lines.push(`<!-- DO NOT EDIT - Regenerate with: npm run generate:domain:indexes -->`);
  lines.push('');
  lines.push(`# ${domain.displayName} Documentation`);
  lines.push('');
  lines.push(`**Domain ID**: \`${domain.domainId}\`  `);
  lines.push(`**Description**: ${domain.description}  `);
  lines.push(`**Status**: üü¢ Active  `);
  lines.push('');

  // Auto-generated docs
  lines.push('## Auto-Generated Documentation (Drift-Proof ‚úÖ)');
  lines.push('');
  lines.push('These files are automatically generated and regenerated on every build.');
  lines.push('They cannot drift - if they differ from source, the build will regenerate them.');
  lines.push('');

  if (domain.autoGeneratedDocuments && domain.autoGeneratedDocuments.length > 0) {
    domain.autoGeneratedDocuments.forEach(doc => {
      lines.push(`### ${doc.name}`);
      lines.push(`- **Purpose**: ${doc.purpose}`);
      lines.push(`- **Source**: ${doc.source}`);
      lines.push(`- **Status**: ‚úÖ Auto-Generated (Drift-Proof)`);
      lines.push('');
    });
  } else {
    lines.push('None defined yet.');
    lines.push('');
  }

  // Manual docs
  lines.push('## Manually-Maintained Documentation (Drift-Capable ‚ö†Ô∏è)');
  lines.push('');
  lines.push('These files are manually written and maintained. They are drift-capable');
  lines.push('(can become out-of-date). Keep these in sync with implementation!');
  lines.push('');

  if (domain.manualDocuments && domain.manualDocuments.length > 0) {
    domain.manualDocuments.forEach(docName => {
      lines.push(`### ${docName}`);
      lines.push(`- **Status**: ‚ö†Ô∏è  Manually-Maintained (Drift-Capable)`);
      lines.push(`- **Note**: Update when corresponding code changes`);
      lines.push('');
    });
  } else {
    lines.push('None defined yet. All documentation for this domain is auto-generated.');
    lines.push('');
  }

  // Dependencies
  if (domain.dependencies && domain.dependencies.length > 0) {
    lines.push('## Dependencies');
    lines.push('');
    lines.push('This domain depends on:');
    lines.push('');
    domain.dependencies.forEach(dep => {
      lines.push(`- \`${dep}\``);
    });
    lines.push('');
  }

  // Governance
  lines.push('## Governance & Compliance');
  lines.push('');
  lines.push('- ‚úÖ All docs classified (auto-generated or manual)');
  lines.push('- ‚úÖ Docs properly located in domain folder');
  lines.push('- ‚úÖ Auto-generated docs have drift protection');
  lines.push('- ‚úÖ Manual docs tracked for maintenance');
  lines.push('');

  lines.push('---');
  lines.push('');
  lines.push('**Generated**: ' + new Date().toISOString());
  lines.push('**Regenerate with**: `npm run generate:domain:indexes`');

  return lines.join('\n');
}

// Generate global index
function generateGlobalIndex(projectPlan) {
  const domains = projectPlan.documentationStructure.domainDocumentationMapping;
  const lines = [];

  lines.push('<!-- AUTO-GENERATED -->');
  lines.push(`<!-- Source: orchestration-audit-system-project-plan.json -->`);
  lines.push(`<!-- Generated: ${new Date().toISOString()} -->`);
  lines.push(`<!-- DO NOT EDIT - Regenerate with: npm run generate:domain:indexes -->`);
  lines.push('');
  lines.push('# Global Documentation Index');
  lines.push('');
  lines.push('Complete navigation of all documentation in the repository.');
  lines.push('');

  lines.push('## Overview');
  lines.push('');
  lines.push('Documentation is organized by domain. Each domain has:');
  lines.push('- üìÅ `docs/generated/{domain-id}/` - Auto-generated (drift-proof) docs');
  lines.push('- üìÅ `docs/manual/{domain-id}/` - Manually-maintained (drift-capable) docs');
  lines.push('');

  lines.push('## Domains');
  lines.push('');

  domains.forEach(domain => {
    lines.push(`### ${domain.displayName}`);
    lines.push(`- **ID**: \`${domain.domainId}\``);
    lines.push(`- **Description**: ${domain.description}`);
    lines.push(`- **Generated Docs**: [\`docs/generated/${domain.domainId}/INDEX.md\`](./generated/${domain.domainId}/INDEX.md)`);
    if (domain.manualDocsPath) {
      lines.push(`- **Manual Docs**: [\`docs/manual/${domain.domainId}/INDEX.md\`](./manual/${domain.domainId}/INDEX.md)`);
    }
    lines.push('');
  });

  lines.push('## Global Governance Documents');
  lines.push('');
  lines.push('Found in repository root:');
  lines.push('');
  lines.push('- `DOCUMENTATION_AUTO_GENERATION_GOVERNANCE.md` - Core governance pattern');
  lines.push('- `DOCUMENTATION_GOVERNANCE_IMPLEMENTATION_COMPLETE.md` - Implementation status');
  lines.push('- `DOCUMENTATION_GOVERNANCE_INDEX.md` - Governance index');
  lines.push('- `DOMAIN_DOCUMENTATION_STRUCTURE.md` - Domain structure reference');
  lines.push('');

  lines.push('## Archive');
  lines.push('');
  lines.push('- üìÅ `.archived/` - Orphaned documents (preserved with metadata)');
  lines.push('- üìÅ `.generated/` - Build-time generated JSON artifacts');
  lines.push('');

  lines.push('## Navigation Tips');
  lines.push('');
  lines.push('- üü¢ **Auto-Generated (Drift-Proof)**: Generated from JSON authority, regenerated on build');
  lines.push('- ‚ö†Ô∏è  **Manually-Maintained (Drift-Capable)**: Requires manual maintenance');
  lines.push('- üì¶ **Archive**: Preserved but no longer in active governance');
  lines.push('');

  lines.push('---');
  lines.push('');
  lines.push('**Generated**: ' + new Date().toISOString());
  lines.push('**Regenerate with**: `npm run generate:domain:indexes`');

  return lines.join('\n');
}

function generateIndexes() {
  console.log('üìö Domain Documentation Index Generator\n');

  const projectPlan = readProjectPlan();
  const domains = projectPlan.documentationStructure.domainDocumentationMapping;

  console.log(`üìã Generating indexes for ${domains.length} domains...\n`);

  // Generate per-domain indexes
  domains.forEach(domain => {
    const generatedPath = path.join(ROOT, domain.generatedDocsPath);
    const manualPath = path.join(ROOT, domain.manualDocsPath);

    // Generated docs index
    ensureDir(generatedPath);
    const generatedIndexPath = path.join(generatedPath, 'INDEX.md');
    const generatedIndex = generateDomainIndex(domain, null);
    fs.writeFileSync(generatedIndexPath, generatedIndex);
    console.log(`‚úÖ Generated: ${path.relative(ROOT, generatedIndexPath)}`);

    // Manual docs index
    ensureDir(manualPath);
    const manualIndexPath = path.join(manualPath, 'INDEX.md');
    const manualIndex = generateDomainIndex(domain, null);
    fs.writeFileSync(manualIndexPath, manualIndex);
    console.log(`‚úÖ Generated: ${path.relative(ROOT, manualIndexPath)}`);
  });

  console.log();

  // Generate global index
  const docsPath = path.join(ROOT, 'docs');
  ensureDir(docsPath);
  const globalIndexPath = path.join(docsPath, 'INDEX.md');
  const globalIndex = generateGlobalIndex(projectPlan);
  fs.writeFileSync(globalIndexPath, globalIndex);
  console.log(`‚úÖ Global: ${path.relative(ROOT, globalIndexPath)}`);

  console.log('\n‚úÖ All domain indexes generated!');
  console.log('');
  console.log('üìç Location Guide:');
  console.log(`   docs/generated/{domain}/INDEX.md     - Auto-generated docs for each domain`);
  console.log(`   docs/manual/{domain}/INDEX.md        - Manual docs for each domain`);
  console.log(`   docs/INDEX.md                        - Global documentation index`);
}

try {
  generateIndexes();
} catch (err) {
  console.error('‚ùå Index generation error:', err.message);
  process.exit(1);
}
