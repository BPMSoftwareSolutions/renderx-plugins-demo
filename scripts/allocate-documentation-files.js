#!/usr/bin/env node

/**
 * Documentation File Allocation System
 * 
 * Purpose: Automatically allocate documentation files to their proper locations
 *          according to documentationStructure governance rules
 * 
 * Strategy:
 *   1. Auto-generated docs: Move to docs/generated/{domain-id}/
 *   2. Drift-capable (manual): Move to docs/manual/{domain-id}/
 *   3. Global governance: Keep in root (allowed list only)
 *   4. Orphaned: Move to docs/archive/ or flag for review
 * 
 * Generates:
 *   - .generated/file-allocation-report.json
 *   - .generated/file-allocation-manifest.json
 *   - docs/generated/{domain}/ structure
 *   - docs/manual/{domain}/ structure
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT = path.join(__dirname, '..');
const PROJECT_PLAN = path.join(ROOT, 'orchestration-audit-system-project-plan.json');
const MANIFEST_PATH = path.join(ROOT, '.generated/document-governance-manifest.json');
const REPORT_PATH = path.join(ROOT, '.generated/file-allocation-report.json');
const ALLOCATION_MANIFEST_PATH = path.join(ROOT, '.generated/file-allocation-manifest.json');

// Read project plan
function readProjectPlan() {
  if (!fs.existsSync(PROJECT_PLAN)) {
    throw new Error(`Project plan not found: ${PROJECT_PLAN}`);
  }
  return JSON.parse(fs.readFileSync(PROJECT_PLAN, 'utf-8'));
}

// Read existing drift audit manifest
function readDriftManifest() {
  if (!fs.existsSync(MANIFEST_PATH)) {
    console.warn('‚ö†Ô∏è  Drift manifest not found. Run audit first: npm run audit:documentation:drift');
    return null;
  }
  return JSON.parse(fs.readFileSync(MANIFEST_PATH, 'utf-8'));
}

// Determine file allocation
function getAllocationRules(projectPlan) {
  const docStructure = projectPlan.documentationStructure;
  const rules = {};

  // Global docs that belong in root
  rules.globalRoot = {
    category: 'global-root',
    path: '.',
    allowed: docStructure.globalDocumentationFolders.root.allowed || [],
    autoGenerated: true,
    description: 'Global governance and high-level indexes'
  };

  // Generated artifacts
  rules.generated = {
    category: 'generated-artifacts',
    path: '.generated',
    purpose: 'Build-time generated JSON artifacts',
    description: 'JSON manifests, indexes, and metadata'
  };

  // Archive
  rules.archive = {
    category: 'archive',
    path: '.archived',
    purpose: 'Archived orphaned documents',
    description: 'Documents no longer in active governance'
  };

  // Domain-specific docs
  rules.domains = {};
  (docStructure.domainDocumentationMapping || []).forEach(domain => {
    rules.domains[domain.domainId] = {
      category: 'domain-docs',
      domainId: domain.domainId,
      displayName: domain.displayName,
      generatedPath: domain.generatedDocsPath,
      manualPath: domain.manualDocsPath,
      description: domain.description
    };
  });

  return rules;
}

// Determine where a file should go
function allocateFile(filename, filepath, driftManifest, rules) {
  const result = {
    filename,
    filepath,
    currentPath: filepath,
    allocatedPath: null,
    allocatedCategory: null,
    reason: null,
    action: 'skip',
    autoGenerated: false
  };

  // Check if it's a global governance doc
  if (rules.globalRoot.allowed.includes(filename)) {
    result.allocatedPath = '.';
    result.allocatedCategory = 'global-root';
    result.reason = 'Global governance documentation';
    result.action = 'keep-in-root';
    return result;
  }

  // Check if it's already in .generated
  if (filepath.startsWith('.generated/')) {
    result.allocatedPath = '.generated';
    result.allocatedCategory = 'generated-artifacts';
    result.reason = 'Auto-generated artifact';
    result.action = 'keep-in-generated';
    result.autoGenerated = true;
    return result;
  }

  // Check if it's already in .archived
  if (filepath.startsWith('.archived/')) {
    result.allocatedPath = '.archived';
    result.allocatedCategory = 'archive';
    result.reason = 'Already archived';
    result.action = 'keep-in-archive';
    return result;
  }

  // Check drift manifest for classification
  if (driftManifest) {
    const manifestEntry = driftManifest.documents?.find(d => d.filename === filename);
    
    if (manifestEntry) {
      // Auto-generated document
      if (manifestEntry.generation_type === 'auto-generated') {
        const domainId = manifestEntry.domain || 'uncategorized';
        const domain = rules.domains[domainId];
        
        if (domain) {
          result.allocatedPath = domain.generatedPath;
          result.allocatedCategory = 'domain-generated';
          result.reason = `Auto-generated for domain: ${domain.displayName}`;
          result.action = 'move-to-generated';
          result.autoGenerated = true;
          result.domain = domainId;
        }
        return result;
      }

      // Manually-maintained document
      if (manifestEntry.generation_type === 'manual-maintained') {
        const domain = rules.domains[manifestEntry.domain];
        
        if (domain) {
          result.allocatedPath = domain.manualPath;
          result.allocatedCategory = 'domain-manual';
          result.reason = `Manually-maintained for domain: ${domain.displayName}`;
          result.action = 'move-to-manual';
          result.autoGenerated = false;
          result.domain = manifestEntry.domain;
        }
        return result;
      }

      // Orphaned document
      if (manifestEntry.generation_type === 'orphaned') {
        result.allocatedPath = '.archived';
        result.allocatedCategory = 'orphaned';
        result.reason = 'Orphaned document (already archived)';
        result.action = 'keep-in-archive';
        return result;
      }
    }
  }

  // Default: orphaned
  result.allocatedPath = '.archived';
  result.allocatedCategory = 'unclassified';
  result.reason = 'Unclassified document';
  result.action = 'move-to-archive';
  return result;
}

// Ensure directory exists
function ensureDir(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
}

// Move file
function moveFile(sourcePath, destPath) {
  try {
    const destDir = path.dirname(destPath);
    ensureDir(destDir);

    // Read source
    const content = fs.readFileSync(sourcePath, 'utf-8');

    // Write destination
    fs.writeFileSync(destPath, content, 'utf-8');

    // Delete source if different
    if (sourcePath !== destPath && fs.existsSync(sourcePath)) {
      fs.unlinkSync(sourcePath);
    }

    return { success: true, message: `Moved to ${destPath}` };
  } catch (err) {
    return { success: false, message: err.message };
  }
}

// Find markdown files in root
function findMarkdownFilesInRoot() {
  const files = fs.readdirSync(ROOT);
  return files.filter(f => {
    const fullPath = path.join(ROOT, f);
    const stat = fs.statSync(fullPath);
    return stat.isFile() && f.endsWith('.md');
  });
}

function allocateDocuments() {
  console.log('üìÇ Documentation File Allocation System\n');

  const projectPlan = readProjectPlan();
  const driftManifest = readDriftManifest();
  const rules = getAllocationRules(projectPlan);

  // Find markdown files in root
  const rootMarkdownFiles = findMarkdownFilesInRoot();
  console.log(`üìã Found ${rootMarkdownFiles.length} markdown files in root\n`);

  // Process each file
  const allocations = [];
  const summary = {
    globalRoot: 0,
    domainGenerated: 0,
    domainManual: 0,
    archived: 0,
    unclassified: 0,
    actions: {}
  };

  console.log('üìç Allocating files...\n');

  rootMarkdownFiles.forEach(filename => {
    const filepath = path.join(ROOT, filename);
    const relPath = path.relative(ROOT, filepath);
    
    const allocation = allocateFile(filename, relPath, driftManifest, rules);
    allocations.push(allocation);

    // Count summary
    if (allocation.allocatedCategory === 'global-root') summary.globalRoot++;
    else if (allocation.allocatedCategory === 'domain-generated') summary.domainGenerated++;
    else if (allocation.allocatedCategory === 'domain-manual') summary.domainManual++;
    else if (allocation.allocatedCategory === 'archive' || allocation.allocatedCategory === 'orphaned') summary.archived++;
    else summary.unclassified++;

    // Count actions
    const action = allocation.action;
    summary.actions[action] = (summary.actions[action] || 0) + 1;

    // Show allocation
    console.log(`${allocation.action === 'keep-in-root' ? '‚úì' : allocation.action === 'keep-in-generated' ? '‚úì' : allocation.action === 'keep-in-archive' ? '‚úì' : '‚Üí'} ${filename}`);
    console.log(`   Category: ${allocation.allocatedCategory}`);
    console.log(`   Reason: ${allocation.reason}`);
    if (allocation.allocatedPath && allocation.action.startsWith('move')) {
      console.log(`   ‚Üí Would move to: ${allocation.allocatedPath}`);
    }
    console.log();
  });

  // Generate reports
  const report = {
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    summary,
    allocations,
    recommendations: generateRecommendations(summary, allocations)
  };

  fs.writeFileSync(REPORT_PATH, JSON.stringify(report, null, 2));
  console.log(`\n‚úÖ Allocation report: ${REPORT_PATH}`);

  // Generate allocation manifest
  const manifest = {
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    totalFiles: allocations.length,
    byCategory: groupBy(allocations, 'allocatedCategory'),
    byAction: groupBy(allocations, 'action'),
    allocations
  };

  fs.writeFileSync(ALLOCATION_MANIFEST_PATH, JSON.stringify(manifest, null, 2));
  console.log(`‚úÖ Allocation manifest: ${ALLOCATION_MANIFEST_PATH}`);

  // Print summary
  console.log('\nüìä Allocation Summary:');
  console.log(`  Global Root: ${summary.globalRoot} files`);
  console.log(`  Domain Generated: ${summary.domainGenerated} files`);
  console.log(`  Domain Manual: ${summary.domainManual} files`);
  console.log(`  Archived: ${summary.archived} files`);
  console.log(`  Unclassified: ${summary.unclassified} files`);

  console.log('\nüéØ Actions Planned:');
  Object.entries(summary.actions).forEach(([action, count]) => {
    console.log(`  ${action}: ${count} files`);
  });

  return report;
}

function groupBy(arr, key) {
  const result = {};
  arr.forEach(item => {
    const k = item[key];
    result[k] = result[k] || [];
    result[k].push(item.filename);
  });
  return result;
}

function generateRecommendations(summary, allocations) {
  const recommendations = [];

  if (summary.globalRoot > 10) {
    recommendations.push({
      priority: 'HIGH',
      issue: 'Too many files in root',
      recommendation: 'Move non-governance files to domain folders'
    });
  }

  if (summary.unclassified > 0) {
    recommendations.push({
      priority: 'HIGH',
      issue: `${summary.unclassified} unclassified files`,
      recommendation: 'Classify files or move to archive'
    });
  }

  const needsMove = allocations.filter(a => a.action.includes('move')).length;
  if (needsMove > 0) {
    recommendations.push({
      priority: 'MEDIUM',
      issue: `${needsMove} files need to be relocated`,
      recommendation: 'Run file move script to reorganize repository'
    });
  }

  return recommendations;
}

try {
  allocateDocuments();
  console.log('\n‚úÖ File allocation analysis complete!');
} catch (err) {
  console.error('‚ùå Allocation error:', err.message);
  process.exit(1);
}
