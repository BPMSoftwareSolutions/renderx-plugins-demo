#!/usr/bin/env node

/**
 * Document Drift Audit System
 * 
 * Purpose: Scan all markdown files and classify as:
 *   - Auto-Generated (drift-proof): Has <!-- AUTO-GENERATED --> header
 *   - Manually-Maintained (drift-capable): Should have <!-- MANUALLY-MAINTAINED --> header
 *   - Orphaned (unknown): Not classified, not referenced by any system
 * 
 * Outputs:
 *   - .generated/document-governance-manifest.json: Full registry with metadata
 *   - .generated/documentation-drift-audit.json: Summary of drift risks
 *   - .generated/orphaned-documents-report.json: Documents needing classification
 *   - DOCUMENTATION_DRIFT_AUDIT_REPORT.md: Human-readable audit report (auto-generated)
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { execSync } from 'child_process';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const PLAN_PATH = path.join(__dirname, '../orchestration-audit-system-project-plan.json');
const ROOT = path.join(__dirname, '..');

// Known auto-generated docs from our generation scripts
const KNOWN_AUTO_GENERATED = new Set([
  'DOCUMENTATION_AUTO_GENERATION_GOVERNANCE.md',
  'PATTERN_RECOGNITION_ACHIEVEMENT.md',
  'DOCUMENTATION_GOVERNANCE_IMPLEMENTATION_COMPLETE.md',
  'DOCUMENTATION_GOVERNANCE_INDEX.md',
  'DEMO_TELEMETRY_INSTRUMENTATION.md',
  'TELEMETRY_GOVERNANCE_QUICKSTART.md',
  'TELEMETRY_GOVERNANCE_VERIFICATION.md',
  'TELEMETRY_GOVERNANCE_COMPLETE.md',
  'DOMAIN_DOCUMENTATION_STRUCTURE.md',
  'DOCUMENTATION_DRIFT_AUDIT_REPORT.md',
  'README.md' // Generated or core
]);

// Folders to exclude from audit
const EXCLUDE_PATTERNS = [
  'node_modules',
  '.git',
  '.venv',
  'dist',
  'build',
  '.pytest_cache',
  '__pycache__',
  'coverage'
];

function shouldExcludeFile(filepath) {
  return EXCLUDE_PATTERNS.some(pattern => filepath.includes(pattern));
}

function scanMarkdownFiles() {
  const files = [];
  
  function walkDir(dir) {
    try {
      const entries = fs.readdirSync(dir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        
        if (shouldExcludeFile(fullPath)) continue;
        
        if (entry.isDirectory()) {
          walkDir(fullPath);
        } else if (entry.name.endsWith('.md')) {
          files.push(fullPath);
        }
      }
    } catch (err) {
      // Silently skip inaccessible directories
    }
  }
  
  walkDir(ROOT);
  return files;
}

function classifyDocument(filepath, content) {
  const filename = path.basename(filepath);
  const relativePath = path.relative(ROOT, filepath);
  
  // Check for AUTO-GENERATED marker - must be within first 500 chars
  const isAutoGenerated = content.substring(0, 500).includes('<!-- AUTO-GENERATED -->');
  
  // Check for MANUALLY-MAINTAINED marker - must be within first 500 chars
  const isManuallyMaintained = content.substring(0, 500).includes('<!-- MANUALLY-MAINTAINED');
  
  // Known auto-generated
  const isKnownAutoGen = KNOWN_AUTO_GENERATED.has(filename);
  
  let generationType = 'orphaned';
  
  if (isAutoGenerated) {
    generationType = 'auto-generated';
  } else if (isManuallyMaintained) {
    generationType = 'manual';
  } else if (isKnownAutoGen) {
    generationType = 'auto-generated';
  }
  
  return {
    filename,
    filepath: relativePath,
    fullPath: filepath,
    generation_type: generationType,
    has_auto_generated_marker: isAutoGenerated,
    has_manual_maintained_marker: isManuallyMaintained,
    is_known_auto_gen: isKnownAutoGen,
    content_length: content.length
  };
}

function extractSourceJson(content) {
  const match = content.match(/<!-- Source: (.+?) -->/);
  return match ? match[1] : null;
}

function extractDomain(filepath) {
  // Try to extract domain from path
  // docs/generated/{domain-id}/... or docs/manual/{domain-id}/...
  const docsMatch = filepath.match(/docs\/(generated|manual)\/([^/]+)\//);
  if (docsMatch) return docsMatch[2];
  
  return null;
}

function auditDocuments() {
  console.log('üîç Scanning markdown files...');
  const files = scanMarkdownFiles();
  console.log(`Found ${files.length} markdown files`);
  
  const manifest = {
    version: '1.0.0',
    auditDate: new Date().toISOString(),
    totalFiles: files.length,
    documents: [],
    summary: {
      'auto-generated': 0,
      'manual': 0,
      'orphaned': 0
    }
  };
  
  const driftRiskDocuments = [];
  const orphanedDocuments = [];
  
  console.log('\nüìä Classifying documents...');
  
  for (const filepath of files) {
    try {
      const content = fs.readFileSync(filepath, 'utf-8');
      const classification = classifyDocument(filepath, content);
      const sourceJson = extractSourceJson(content);
      const domain = extractDomain(classification.filepath);
      
      const docInfo = {
        filename: classification.filename,
        filepath: classification.filepath,
        domain: domain,
        generation_type: classification.generation_type,
        source_json: sourceJson,
        auto_generated_marker: classification.has_auto_generated_marker,
        manually_maintained_marker: classification.has_manual_maintained_marker,
        is_known_auto_gen: classification.is_known_auto_gen,
        filesize_bytes: content.length,
        creation_date: fs.statSync(filepath).birthtime.toISOString(),
        last_modified_date: fs.statSync(filepath).mtime.toISOString()
      };
      
      manifest.documents.push(docInfo);
      manifest.summary[classification.generation_type]++;
      
      if (classification.generation_type === 'manual') {
        driftRiskDocuments.push(docInfo);
      } else if (classification.generation_type === 'orphaned') {
        orphanedDocuments.push(docInfo);
      }
    } catch (err) {
      console.warn(`‚ö†Ô∏è  Error processing ${filepath}: ${err.message}`);
    }
  }
  
  // Sort by modification date (most recent first)
  driftRiskDocuments.sort((a, b) => 
    new Date(b.last_modified_date) - new Date(a.last_modified_date)
  );
  
  // Create drift audit report
  const driftAudit = {
    auditDate: new Date().toISOString(),
    summary: manifest.summary,
    driftRiskLevel: calculateDriftRisk(manifest.summary),
    driftCapableDocuments: driftRiskDocuments.slice(0, 50), // Top 50 most recent
    orphanedDocumentsCount: orphanedDocuments.length,
    topOrphanedDocuments: orphanedDocuments.slice(0, 20) // Top 20
  };
  
  // Create orphaned documents report
  const orphanedReport = {
    auditDate: new Date().toISOString(),
    totalOrphaned: orphanedDocuments.length,
    recommendations: [
      '1. Archive: Move to .archived/ if no longer needed',
      '2. Migrate: Move to docs/manual/{domain}/ if domain-related',
      '3. Auto-Generate: Convert to auto-generated if possible',
      '4. Delete: Remove if completely stale'
    ],
    documents: orphanedDocuments.map(doc => ({
      filename: doc.filename,
      filepath: doc.filepath,
      filesize: doc.filesize_bytes,
      lastModified: doc.last_modified_date,
      recommendation: 'Review for migration'
    }))
  };
  
  // Write artifacts
  console.log('\nüíæ Writing audit artifacts...');
  
  const manifestPath = path.join(ROOT, '.generated', 'document-governance-manifest.json');
  fs.mkdirSync(path.dirname(manifestPath), { recursive: true });
  fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));
  console.log(`‚úÖ Manifest: ${manifestPath}`);
  
  const driftPath = path.join(ROOT, '.generated', 'documentation-drift-audit.json');
  fs.writeFileSync(driftPath, JSON.stringify(driftAudit, null, 2));
  console.log(`‚úÖ Drift Audit: ${driftPath}`);
  
  const orphanedPath = path.join(ROOT, '.generated', 'orphaned-documents-report.json');
  fs.writeFileSync(orphanedPath, JSON.stringify(orphanedReport, null, 2));
  console.log(`‚úÖ Orphaned Report: ${orphanedPath}`);
  
  return { manifest, driftAudit, orphanedReport };
}

function calculateDriftRisk(summary) {
  const total = summary['auto-generated'] + summary['manual'] + summary['orphaned'];
  const driftCapable = summary['manual'] + summary['orphaned'];
  const riskPercentage = (driftCapable / total) * 100;
  
  if (riskPercentage > 80) return 'CRITICAL';
  if (riskPercentage > 50) return 'HIGH';
  if (riskPercentage > 20) return 'MEDIUM';
  return 'LOW';
}

// Run audit
try {
  const { manifest, driftAudit, orphanedReport } = auditDocuments();
  
  console.log('\nüìã Audit Summary:');
  console.log(`  Auto-Generated (Drift-Proof): ${manifest.summary['auto-generated']}`);
  console.log(`  Manually-Maintained (Drift-Capable): ${manifest.summary['manual']}`);
  console.log(`  Orphaned (Unknown): ${manifest.summary['orphaned']}`);
  console.log(`  Drift Risk Level: ${driftAudit.driftRiskLevel}`);
  
  console.log('\n‚úÖ Document audit complete!');
} catch (err) {
  console.error('‚ùå Audit error:', err.message);
  process.exit(1);
}
