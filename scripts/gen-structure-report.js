#!/usr/bin/env node
/**
 * gen-structure-report.js
 * Generates STRUCTURE_REPORT.md and .generated/structure-drift.json from manifests.
 * DO NOT EDIT GENERATED OUTPUT.
 */
import fs from 'fs';
import path from 'path';

const ROOT = process.cwd();
const REPORT_PATH = path.join(ROOT, 'STRUCTURE_REPORT.md');
const DRIFT_PATH = path.join(ROOT, '.generated', 'structure-drift.json');
const ROLES_PATH = path.join(ROOT, 'PROJECT_ROLES.json');
const BOUNDARIES_PATH = path.join(ROOT, 'PROJECT_BOUNDARIES.json');

function ensureGenerated(){
  const dir = path.join(ROOT,'.generated');
  if(!fs.existsSync(dir)) fs.mkdirSync(dir,{recursive:true});
}

function loadJson(p){ return JSON.parse(fs.readFileSync(p,'utf-8')); }
function toPosix(p){ return p.replace(/\\/g,'/'); }
function globToRegex(glob){
  let re = glob.replace(/[.+^${}()|\\]/g,'\\$&');
  re = re.replace(/\*\*\//g,'(?:.+/)?');
  re = re.replace(/\*\*/g,'.+');
  re = re.replace(/\*/g,'[^/]*');
  return new RegExp('^' + re + '$');
}
function matchesAny(p, globs){ return globs.some(g=>globToRegex(g).test(p)); }

function walk(dir){
  let results = [];
  for(const entry of fs.readdirSync(dir)){
    if(entry === 'node_modules') continue;
    const full = path.join(dir, entry);
    const stat = fs.statSync(full);
    if(stat.isDirectory()) results = results.concat(walk(full));
    else results.push(full);
  }
  return results;
}

function main(){
  const boundaries = loadJson(BOUNDARIES_PATH);
  const roles = loadJson(ROLES_PATH).roles;

  // Top-level directories
  const topDirs = fs.readdirSync(ROOT).filter(d=>{
    if(d.startsWith('.')) return false;
    if(['node_modules'].includes(d)) return false;
    return fs.statSync(path.join(ROOT,d)).isDirectory();
  });
  const unexpected = topDirs.filter(d=>!boundaries.includes(d));

  // Empty/stale directories (no code/json assets)
  function dirHasContent(d){
    let has = false;
    for(const entry of fs.readdirSync(d)){
      const full = path.join(d, entry);
      if(fs.statSync(full).isDirectory()) { if(dirHasContent(full)) return true; }
      else if(/\.(ts|js|json|md)$/i.test(entry)) { has = true; break; }
    }
    return has;
  }
  const empty = topDirs.filter(d=>!dirHasContent(path.join(ROOT,d)));

  // Role coverage
  const allFiles = walk(ROOT).map(f=>toPosix(path.relative(ROOT,f)));
  const roleCoverage = {};
  for(const [role, globs] of Object.entries(roles)){
    roleCoverage[role] = allFiles.filter(f=>matchesAny(f, globs)).length;
  }

  // Build markdown
  const md = [
    '# STRUCTURE_REPORT (GENERATED)\n',
    '> DO NOT EDIT â€” GENERATED BY scripts/gen-structure-report.js\n',
    '## Boundaries\n',
    'Allowed top-level directories: ' + boundaries.join(', ') + '\n',
    '## Unexpected Directories\n',
    unexpected.length ? unexpected.map(u=>`- ${u}`).join('\n') : 'None\n',
    '\n## Empty / Stale Top-Level Directories\n',
    empty.length ? empty.map(e=>`- ${e}`).join('\n') : 'None\n',
    '\n## Role Coverage\n',
    Object.entries(roleCoverage).map(([r,c])=>`- ${r}: ${c} files`).join('\n'),
    '\n## Summary\n',
    `UnexpectedCount: ${unexpected.length}  EmptyCount: ${empty.length}`,
    '\n'
  ].join('\n');

  ensureGenerated();
  fs.writeFileSync(REPORT_PATH, md, 'utf-8');
  fs.writeFileSync(DRIFT_PATH, JSON.stringify({ generatedAt: new Date().toISOString(), unexpected, empty, roleCoverage }, null, 2));
  console.log('[gen-structure-report] Generated STRUCTURE_REPORT.md and structure-drift.json');
}

if (process.argv[1].endsWith('gen-structure-report.js')) main();
