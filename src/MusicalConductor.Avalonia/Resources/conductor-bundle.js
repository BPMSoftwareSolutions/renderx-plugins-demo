/* Auto-generated by esbuild. Source: dist/modules/communication. Do not edit directly. */
"use strict";
var MusicalConductorBundle = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // dist/modules/communication/event-types/core.event-types.js
  var CORE_EVENT_TYPES;
  var init_core_event_types = __esm({
    "dist/modules/communication/event-types/core.event-types.js"() {
      "use strict";
      CORE_EVENT_TYPES = {
        // Component Events
        COMPONENT_MOUNTED: "component-mounted",
        COMPONENT_UNMOUNTED: "component-unmounted",
        COMPONENT_UPDATED: "component-updated",
        COMPONENT_ERROR: "component-error",
        // System Events
        SYSTEM_ERROR: "system-error",
        SYSTEM_WARNING: "system-warning",
        SYSTEM_INFO: "system-info"
      };
    }
  });

  // dist/modules/communication/sequences/SequenceTypes.js
  var MUSICAL_DYNAMICS, MUSICAL_TIMING, SEQUENCE_CATEGORIES, MUSICAL_CONDUCTOR_EVENT_TYPES, MUSICAL_SEQUENCE_TEMPLATE, SEQUENCE_PRIORITIES;
  var init_SequenceTypes = __esm({
    "dist/modules/communication/sequences/SequenceTypes.js"() {
      "use strict";
      init_event_types();
      MUSICAL_DYNAMICS = {
        PIANISSIMO: "pp",
        // Very soft - lowest priority
        PIANO: "p",
        // Soft - low priority
        MEZZO_PIANO: "mp",
        // Medium soft - medium-low priority
        MEZZO_FORTE: "mf",
        // Medium loud - medium priority
        FORTE: "f",
        // Loud - high priority
        FORTISSIMO: "ff"
        // Very loud - highest priority
      };
      MUSICAL_TIMING = {
        IMMEDIATE: "immediate",
        // Execute immediately when beat is reached
        AFTER_BEAT: "after-beat",
        // Execute after dependencies complete
        DELAYED: "delayed",
        // Execute with intentional delay
        SYNCHRONIZED: "synchronized",
        // Execute synchronized with other events
        ON_BEAT: "on-beat"
        // Execute exactly on the next musical beat
      };
      SEQUENCE_CATEGORIES = {
        COMPONENT_UI: "component-ui",
        // UI component interactions
        CANVAS_OPERATIONS: "canvas-operations",
        // Canvas manipulation
        DATA_FLOW: "data-flow",
        // Data processing and flow
        SYSTEM: "system",
        // System sequences (alias for tests)
        SYSTEM_EVENTS: "system-events",
        // System-level events
        USER_INTERACTIONS: "user-interactions",
        // User input handling
        INTEGRATION: "integration",
        // External integrations
        PERFORMANCE: "performance",
        // Performance testing sequences
        LAYOUT: "layout"
        // Layout-related sequences
      };
      MUSICAL_CONDUCTOR_EVENT_TYPES = {
        // Conductor Lifecycle
        CONDUCTOR_INITIALIZED: "conductor-initialized",
        CONDUCTOR_DESTROYED: "conductor-destroyed",
        CONDUCTOR_RESET: "conductor-reset",
        // Sequence Management
        SEQUENCE_DEFINED: "sequence-defined",
        SEQUENCE_UNDEFINED: "sequence-undefined",
        SEQUENCE_REGISTERED: "sequence-registered",
        SEQUENCE_UNREGISTERED: "sequence-unregistered",
        // Sequence Execution
        SEQUENCE_STARTED: "sequence-started",
        SEQUENCE_COMPLETED: "sequence-completed",
        SEQUENCE_FAILED: "sequence-failed",
        SEQUENCE_CANCELLED: "sequence-cancelled",
        SEQUENCE_PAUSED: "sequence-paused",
        SEQUENCE_RESUMED: "sequence-resumed",
        // Beat Execution
        BEAT_STARTED: "beat-started",
        BEAT_COMPLETED: "beat-completed",
        BEAT_FAILED: "beat-failed",
        // Movement Execution
        MOVEMENT_STARTED: "movement-started",
        MOVEMENT_COMPLETED: "movement-completed",
        MOVEMENT_FAILED: "movement-failed",
        // Queue Management
        SEQUENCE_QUEUED: "sequence-queued",
        SEQUENCE_DEQUEUED: "sequence-dequeued",
        QUEUE_PROCESSED: "queue-processed",
        // Statistics
        STATISTICS_UPDATED: "statistics-updated"
      };
      MUSICAL_SEQUENCE_TEMPLATE = {
        id: "template-sequence",
        name: "Template Sequence",
        description: "Template for creating new musical sequences",
        key: "C Major",
        tempo: 120,
        timeSignature: "4/4",
        category: SEQUENCE_CATEGORIES.COMPONENT_UI,
        movements: [
          {
            id: "template-movement",
            name: "Template Movement",
            description: "Template movement with example beats",
            beats: [
              {
                beat: 1,
                event: "template-event",
                title: "Template Beat",
                description: "Example beat for template",
                dynamics: MUSICAL_DYNAMICS.MEZZO_FORTE,
                timing: MUSICAL_TIMING.IMMEDIATE,
                data: {},
                errorHandling: "continue"
              }
            ]
          }
        ],
        metadata: {
          version: "1.0.0",
          author: "RenderX System",
          created: /* @__PURE__ */ new Date(),
          tags: ["template", "example"]
        }
      };
      SEQUENCE_PRIORITIES = {
        HIGH: "HIGH",
        // Execute immediately, bypass queue
        NORMAL: "NORMAL",
        // Normal queue processing
        CHAINED: "CHAINED"
        // Execute after current sequence completes
      };
    }
  });

  // dist/modules/communication/event-types/index.js
  var EVENT_TYPES;
  var init_event_types = __esm({
    "dist/modules/communication/event-types/index.js"() {
      "use strict";
      init_core_event_types();
      init_SequenceTypes();
      EVENT_TYPES = {
        // Core Events
        ...CORE_EVENT_TYPES,
        // Musical Conductor Events
        ...MUSICAL_CONDUCTOR_EVENT_TYPES
      };
    }
  });

  // dist/modules/communication/sequences/environment/ConductorEnv.js
  function getConductorEnv() {
    try {
      if (localEnv)
        return localEnv;
      const g = typeof globalThis !== "undefined" ? globalThis : void 0;
      const w = typeof window !== "undefined" ? window : void 0;
      return g && g.__CONDUCTOR_ENV__ || w && w.__CONDUCTOR_ENV__ || {};
    } catch {
      return {};
    }
  }
  function isDevEnv() {
    try {
      const ce = getConductorEnv();
      if (ce && (ce.dev === true || ce.mode === "development"))
        return true;
    } catch {
    }
    try {
      const im = (0, eval)("import.meta");
      if (im && im.env) {
        if (im.env.DEV === true)
          return true;
        if (im.env.MODE === "development")
          return true;
      }
    } catch {
    }
    try {
      const env = typeof process !== "undefined" && process.env || {};
      if (env.MC_DEV === "1" || env.MC_DEV === "true" || env.NODE_ENV === "development" || env.npm_lifecycle_event === "dev")
        return true;
    } catch {
    }
    try {
      const g = typeof globalThis !== "undefined" ? globalThis : void 0;
      if (g && (g.MC_DEV === true || g.MC_DEV === "1"))
        return true;
    } catch {
    }
    try {
      const w = typeof window !== "undefined" ? window : void 0;
      if (w && w.MC_DEV)
        return true;
    } catch {
    }
    return false;
  }
  var localEnv;
  var init_ConductorEnv = __esm({
    "dist/modules/communication/sequences/environment/ConductorEnv.js"() {
      "use strict";
      localEnv = null;
    }
  });

  // dist/modules/communication/sequences/monitoring/DataBaton.js
  var DataBaton;
  var init_DataBaton = __esm({
    "dist/modules/communication/sequences/monitoring/DataBaton.js"() {
      "use strict";
      DataBaton = class _DataBaton {
        /** Compute indent using ConductorLoggerâ€™s scope depth when available */
        static computeIndent(requestId) {
          try {
            const bus = _DataBaton.eventBus;
            const logger = bus?.__conductorLogger;
            if (!logger)
              return "";
            const depth = logger.getDepth?.(requestId) ?? 0;
            return "  ".repeat(Math.max(0, depth));
          } catch {
            return "";
          }
        }
        static snapshot(baton) {
          if (!baton || typeof baton !== "object")
            return {};
          const snap = {};
          for (const k of Object.keys(baton)) {
            snap[k] = baton[k];
          }
          return snap;
        }
        static diff(prev, next) {
          const added = [];
          const removed = [];
          const updated = [];
          const prevKeys = new Set(Object.keys(prev || {}));
          const nextKeys = new Set(Object.keys(next || {}));
          for (const k of nextKeys) {
            if (!prevKeys.has(k)) {
              added.push(k);
            } else if (!_DataBaton.shallowEqual(prev[k], next[k])) {
              updated.push(k);
            }
          }
          for (const k of prevKeys) {
            if (!nextKeys.has(k))
              removed.push(k);
          }
          return { added, removed, updated };
        }
        static log(context, prev, next) {
          const diff = _DataBaton.diff(prev, next);
          const hasChanges = diff.added.length || diff.removed.length || diff.updated.length;
          const prefix = "\u{1F3BD} DataBaton";
          if (!hasChanges) {
            const indent2 = _DataBaton.computeIndent(context.requestId);
            console.log(`${indent2}${prefix}: No changes | seq=${context.sequenceName || "?"} beat=${context.beatNumber ?? "?"} event=${context.beatEvent || "?"} handler=${context.handlerName || "?"}`);
            return;
          }
          const details = [];
          if (diff.added.length)
            details.push(`+${diff.added.join(",")}`);
          if (diff.updated.length)
            details.push(`~${diff.updated.join(",")}`);
          if (diff.removed.length)
            details.push(`-${diff.removed.join(",")}`);
          const previewKeys = [...diff.added, ...diff.updated].slice(0, 3);
          const previewObj = {};
          for (const k of previewKeys)
            previewObj[k] = next[k];
          let preview = "";
          try {
            preview = JSON.stringify(previewObj).slice(0, 200);
          } catch {
          }
          const indent = _DataBaton.computeIndent(context.requestId);
          console.log(`${indent}${prefix}: ${details.join(" ")} | seq=${context.sequenceName || "?"} beat=${context.beatNumber ?? "?"} event=${context.beatEvent || "?"} handler=${context.handlerName || "?"} plugin=${context.pluginId || "?"} req=${context.requestId || "?"} preview=${preview}`);
        }
        static shallowEqual(a, b) {
          if (a === b)
            return true;
          if (!a || !b)
            return a === b;
          if (typeof a !== "object" || typeof b !== "object")
            return a === b;
          const aKeys = Object.keys(a);
          const bKeys = Object.keys(b);
          if (aKeys.length !== bKeys.length)
            return false;
          for (const k of aKeys) {
            if (a[k] !== b[k])
              return false;
          }
          return true;
        }
      };
      DataBaton.eventBus = null;
    }
  });

  // dist/modules/communication/sequences/monitoring/ConductorLogger.js
  var ConductorLogger_exports = {};
  __export(ConductorLogger_exports, {
    ConductorLogger: () => ConductorLogger
  });
  var ConductorLogger;
  var init_ConductorLogger = __esm({
    "dist/modules/communication/sequences/monitoring/ConductorLogger.js"() {
      "use strict";
      init_SequenceTypes();
      init_DataBaton();
      ConductorLogger = class {
        constructor(eventBus2, enabled = true) {
          this.stacks = /* @__PURE__ */ new Map();
          this.eventBus = eventBus2;
          this.enabled = enabled;
          this.eventBus.__conductorLogger = this;
          DataBaton.eventBus = this.eventBus;
        }
        init() {
          if (!this.enabled)
            return;
          this.eventBus.subscribe(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_STARTED, (data) => this.push(data.requestId, {
            type: "sequence",
            label: `\u{1F3BC} ${data.sequenceName}`
          }));
          this.eventBus.subscribe(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_COMPLETED, (data) => this.pop(data.requestId, "sequence"));
          this.eventBus.subscribe(MUSICAL_CONDUCTOR_EVENT_TYPES.MOVEMENT_STARTED, (data) => this.push(data.requestId, {
            type: "movement",
            label: `\u{1F3B5} ${data.movementName}`
          }));
          this.eventBus.subscribe(MUSICAL_CONDUCTOR_EVENT_TYPES.MOVEMENT_COMPLETED, (data) => this.pop(data.requestId, "movement"));
          this.eventBus.subscribe(MUSICAL_CONDUCTOR_EVENT_TYPES.BEAT_STARTED, (data) => this.push(data.requestId, {
            type: "beat",
            label: `\u{1F941} ${data.beat}: ${data.event}`
          }));
          this.eventBus.subscribe(MUSICAL_CONDUCTOR_EVENT_TYPES.BEAT_COMPLETED, (data) => this.pop(data.requestId, "beat"));
          this.eventBus.subscribe(MUSICAL_CONDUCTOR_EVENT_TYPES.BEAT_FAILED, (data) => this.pop(data.requestId, "beat"));
          this.eventBus.subscribe("plugin:handler:start", (data) => this.push(data.requestId, {
            type: "handler",
            label: `\u{1F527} ${data.pluginId}.${data.handlerName}`
          }));
          this.eventBus.subscribe("plugin:handler:end", (data) => this.pop(data.requestId, "handler"));
          this.eventBus.subscribe("musical-conductor:log", (evt) => {
            const indent = this.getIndent(evt.requestId);
            const prefix = evt.pluginId ? `\u{1F9E9} ${evt.pluginId}${evt.handlerName ? "." + evt.handlerName : ""}` : "\u{1F3BC}";
            const line = `${indent}${prefix}`;
            switch (evt.level) {
              case "warn":
                console.warn(line, ...evt.message);
                break;
              case "error":
                console.error(line, ...evt.message);
                break;
              case "info":
              case "log":
              default:
                console.log(line, ...evt.message);
            }
          });
          this.eventBus.subscribe("stage:cue", (cue) => {
            this.logStageCue(cue);
          });
        }
        push(requestId, scope) {
          const key = requestId || "__global__";
          const stack = this.stacks.get(key) || [];
          stack.push(scope);
          this.stacks.set(key, stack);
          const indent = this.getIndent(requestId);
          console.log(`${indent}${scope.label}`);
        }
        pop(requestId, type) {
          const key = requestId || "__global__";
          const stack = this.stacks.get(key) || [];
          for (let i = stack.length - 1; i >= 0; i--) {
            if (stack[i].type === type) {
              stack.splice(i, 1);
              break;
            }
          }
          this.stacks.set(key, stack);
        }
        /** Expose current depth for a request so other loggers can align indent */
        getDepth(requestId) {
          const key = requestId || "__global__";
          return (this.stacks.get(key) || []).length;
        }
        getIndent(requestId) {
          const key = requestId || "__global__";
          const depth = (this.stacks.get(key) || []).length;
          return "  ".repeat(Math.max(0, depth));
        }
        /**
         * Log stage crew commits in debug mode
         * @param cue - Stage cue data containing operations and metadata
         */
        logStageCue(cue) {
          if (!cue || !cue.operations || cue.operations.length === 0) {
            return;
          }
          const indent = this.getIndent();
          const pluginPrefix = cue.pluginId ? `${cue.pluginId}` : "unknown";
          const correlationId = cue.correlationId || "no-correlation";
          const handlerName = cue.meta?.handlerName ? `.${cue.meta.handlerName}` : "";
          console.log(`${indent}\u{1F3AD} Stage Crew: ${pluginPrefix}${handlerName} (${correlationId})`);
          cue.operations.forEach((op, index) => {
            const opIndent = `${indent}  `;
            const isLast = index === cue.operations.length - 1;
            const connector = isLast ? "\u2514\u2500" : "\u251C\u2500";
            switch (op.op) {
              case "classes.add":
                console.log(`${opIndent}${connector} Add class "${op.value}" to ${op.selector}`);
                break;
              case "classes.remove":
                console.log(`${opIndent}${connector} Remove class "${op.value}" from ${op.selector}`);
                break;
              case "attr.set":
                console.log(`${opIndent}${connector} Set ${op.key}="${op.value}" on ${op.selector}`);
                break;
              case "style.set":
                console.log(`${opIndent}${connector} Set style ${op.key}="${op.value}" on ${op.selector}`);
                break;
              case "create":
                const classes = op.classes ? ` classes=[${op.classes.join(", ")}]` : "";
                const attrs = op.attrs ? ` attrs=${JSON.stringify(op.attrs)}` : "";
                console.log(`${opIndent}${connector} Create <${op.tag}>${classes}${attrs} in ${op.parent}`);
                break;
              case "remove":
                console.log(`${opIndent}${connector} Remove ${op.selector}`);
                break;
              default:
                console.log(`${opIndent}${connector} Unknown operation: ${JSON.stringify(op)}`);
            }
          });
        }
      };
    }
  });

  // dist/modules/communication/sequences/orchestration/CallbackRegistry.js
  var CallbackRegistry_exports = {};
  __export(CallbackRegistry_exports, {
    CallbackRegistry: () => CallbackRegistry,
    __internal: () => __internal
  });
  var PLACEHOLDER_KEY, CORRELATION_KEY, DEFAULT_TTL_MS, CallbackRegistry, __internal;
  var init_CallbackRegistry = __esm({
    "dist/modules/communication/sequences/orchestration/CallbackRegistry.js"() {
      "use strict";
      PLACEHOLDER_KEY = "__mc_cb_ref__";
      CORRELATION_KEY = "__mc_correlation_id__";
      DEFAULT_TTL_MS = 2 * 60 * 1e3;
      CallbackRegistry = class _CallbackRegistry {
        constructor() {
          this.store = /* @__PURE__ */ new Map();
        }
        static getInstance() {
          if (!_CallbackRegistry.instance) {
            _CallbackRegistry.instance = new _CallbackRegistry();
          }
          return _CallbackRegistry.instance;
        }
        /** Ensure a correlation id is attached; return it */
        ensureCorrelationId(obj) {
          if (obj && typeof obj === "object" && typeof obj[CORRELATION_KEY] === "string") {
            return obj[CORRELATION_KEY];
          }
          const id = `mc-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
          if (obj && typeof obj === "object") {
            try {
              obj[CORRELATION_KEY] = id;
            } catch {
            }
          }
          return id;
        }
        /** Extract functions from a payload into the registry, replacing with placeholders */
        preserveInPlace(ctx) {
          const correlationId = this.ensureCorrelationId(ctx);
          const entry = this.getOrCreateEntry(correlationId);
          let count = 0;
          const visit = (node, path) => {
            if (!node || typeof node !== "object")
              return;
            const keys = Array.isArray(node) ? node.keys?.() : Object.keys(node);
            if (Array.isArray(node)) {
              for (let i = 0; i < node.length; i++) {
                const child = node[i];
                const childPath = `${path}[${i}]`;
                if (typeof child === "function") {
                  const ref = `${childPath}`;
                  entry.fns.set(ref, child);
                  node[i] = { [PLACEHOLDER_KEY]: ref };
                  count++;
                } else if (child && typeof child === "object") {
                  visit(child, childPath);
                }
              }
              return;
            }
            for (const key of Object.keys(node)) {
              if (key === PLACEHOLDER_KEY)
                continue;
              if (key === CORRELATION_KEY)
                continue;
              const value = node[key];
              const childPath = path ? `${path}.${key}` : key;
              if (typeof value === "function") {
                entry.fns.set(childPath, value);
                node[key] = { [PLACEHOLDER_KEY]: childPath };
                count++;
              } else if (value && typeof value === "object") {
                const tag = value?.tagName;
                if (typeof tag === "string")
                  continue;
                visit(value, childPath);
              }
            }
          };
          try {
            visit(ctx, "");
          } catch {
          }
          entry.lastAccess = Date.now();
          this.purgeOldEntries();
          return { correlationId, count };
        }
        /** Rehydrate placeholders back to functions on the given data object (in place) */
        rehydrateInPlace(data) {
          if (!data || typeof data !== "object")
            return 0;
          const correlationId = data[CORRELATION_KEY];
          if (!correlationId || typeof correlationId !== "string")
            return 0;
          const entry = this.store.get(correlationId);
          if (!entry)
            return 0;
          let count = 0;
          const visit = (node) => {
            if (!node || typeof node !== "object")
              return;
            if (Array.isArray(node)) {
              for (let i = 0; i < node.length; i++) {
                const child = node[i];
                if (child && typeof child === "object" && PLACEHOLDER_KEY in child) {
                  const ref = child[PLACEHOLDER_KEY];
                  const fn = entry.fns.get(ref);
                  if (typeof fn === "function") {
                    node[i] = fn;
                    count++;
                  }
                } else if (child && typeof child === "object") {
                  visit(child);
                }
              }
              return;
            }
            for (const key of Object.keys(node)) {
              const value = node[key];
              if (value && typeof value === "object" && PLACEHOLDER_KEY in value) {
                const ref = value[PLACEHOLDER_KEY];
                const fn = entry.fns.get(ref);
                if (typeof fn === "function") {
                  node[key] = fn;
                  count++;
                }
              } else if (value && typeof value === "object") {
                visit(value);
              }
            }
          };
          try {
            visit(data);
          } catch {
          }
          const setByPath = (root, refPath, fn) => {
            const tokens = [];
            let buf = "";
            const pushBuf = () => {
              if (buf) {
                tokens.push(buf);
                buf = "";
              }
            };
            for (let i = 0; i < refPath.length; i++) {
              const ch = refPath[i];
              if (ch === ".") {
                pushBuf();
              } else if (ch === "[") {
                pushBuf();
                let j = i + 1;
                let num = "";
                while (j < refPath.length && refPath[j] !== "]") {
                  num += refPath[j++];
                }
                tokens.push(parseInt(num, 10));
                i = j;
              } else {
                buf += ch;
              }
            }
            pushBuf();
            let cur = root;
            for (let t = 0; t < tokens.length; t++) {
              const seg = tokens[t];
              const last = t === tokens.length - 1;
              if (typeof seg === "number") {
                if (!Array.isArray(cur))
                  return;
                if (last) {
                  if (typeof cur[seg] !== "function") {
                    cur[seg] = fn;
                  }
                  return;
                }
                if (cur[seg] == null || typeof cur[seg] !== "object") {
                  cur[seg] = {};
                }
                cur = cur[seg];
              } else {
                if (last) {
                  if (typeof cur[seg] !== "function") {
                    cur[seg] = fn;
                  }
                  return;
                }
                if (cur[seg] == null || typeof cur[seg] !== "object") {
                  cur[seg] = {};
                }
                cur = cur[seg];
              }
            }
          };
          for (const [ref, fn] of entry.fns.entries()) {
            try {
              setByPath(data, ref, fn);
              count++;
            } catch {
            }
          }
          entry.lastAccess = Date.now();
          this.purgeOldEntries();
          return count;
        }
        /** Cleanup an entry explicitly */
        cleanup(correlationId) {
          this.store.delete(correlationId);
        }
        getOrCreateEntry(correlationId) {
          let entry = this.store.get(correlationId);
          if (!entry) {
            entry = { fns: /* @__PURE__ */ new Map(), createdAt: Date.now(), lastAccess: Date.now() };
            this.store.set(correlationId, entry);
          }
          return entry;
        }
        purgeOldEntries(now = Date.now(), ttlMs = DEFAULT_TTL_MS) {
          for (const [key, entry] of this.store.entries()) {
            if (now - entry.lastAccess > ttlMs) {
              this.store.delete(key);
            }
          }
        }
      };
      CallbackRegistry.instance = null;
      __internal = { PLACEHOLDER_KEY, CORRELATION_KEY };
    }
  });

  // dist/modules/communication/sequences/stage/StageDomGuard.js
  var StageDomGuard;
  var init_StageDomGuard = __esm({
    "dist/modules/communication/sequences/stage/StageDomGuard.js"() {
      "use strict";
      StageDomGuard = class _StageDomGuard {
        static install() {
          if (this.installed)
            return;
          if (typeof document === "undefined")
            return;
          try {
            this.originals.setAttribute = Element.prototype.setAttribute;
            Element.prototype.setAttribute = function(name, value) {
              _StageDomGuard.maybeWarn("setAttribute", this);
              return _StageDomGuard.originals.setAttribute.call(this, name, value);
            };
            this.originals.removeAttribute = Element.prototype.removeAttribute;
            Element.prototype.removeAttribute = function(name) {
              _StageDomGuard.maybeWarn("removeAttribute", this);
              return _StageDomGuard.originals.removeAttribute.call(this, name);
            };
            this.originals.appendChild = Node.prototype.appendChild;
            Node.prototype.appendChild = function(child) {
              _StageDomGuard.maybeWarn("appendChild", this);
              return _StageDomGuard.originals.appendChild.call(this, child);
            };
            this.originals.removeChild = Node.prototype.removeChild;
            Node.prototype.removeChild = function(child) {
              _StageDomGuard.maybeWarn("removeChild", this);
              return _StageDomGuard.originals.removeChild.call(this, child);
            };
            this.originals.replaceChild = Node.prototype.replaceChild;
            Node.prototype.replaceChild = function(newChild, oldChild) {
              _StageDomGuard.maybeWarn("replaceChild", this);
              return _StageDomGuard.originals.replaceChild.call(this, newChild, oldChild);
            };
            this.originals.insertBefore = Node.prototype.insertBefore;
            Node.prototype.insertBefore = function(newNode, ref) {
              _StageDomGuard.maybeWarn("insertBefore", this);
              return _StageDomGuard.originals.insertBefore.call(this, newNode, ref);
            };
            this.originals.classListAdd = DOMTokenList.prototype.add;
            DOMTokenList.prototype.add = function(...tokens) {
              _StageDomGuard.maybeWarn("classList.add", this.ownerElement);
              return _StageDomGuard.originals.classListAdd.apply(this, tokens);
            };
            this.originals.classListRemove = DOMTokenList.prototype.remove;
            DOMTokenList.prototype.remove = function(...tokens) {
              _StageDomGuard.maybeWarn("classList.remove", this.ownerElement);
              return _StageDomGuard.originals.classListRemove.apply(this, tokens);
            };
            this.originals.styleSetProperty = CSSStyleDeclaration.prototype.setProperty;
            CSSStyleDeclaration.prototype.setProperty = function(prop, value, priority) {
              _StageDomGuard.maybeWarn("style.setProperty", this.ownerElement);
              return _StageDomGuard.originals.styleSetProperty.call(this, prop, value, priority);
            };
            this.originals.createElement = Document.prototype.createElement;
            Document.prototype.createElement = function(tagName, options) {
              _StageDomGuard.maybeWarn("document.createElement", this);
              return _StageDomGuard.originals.createElement.call(this, tagName, options);
            };
            this.installed = true;
          } catch (e) {
            console.warn("\u26A0\uFE0F StageDomGuard: install failed:", e?.message || e);
          }
        }
        static uninstall() {
          if (!this.installed)
            return;
          try {
            if (this.originals.setAttribute)
              Element.prototype.setAttribute = this.originals.setAttribute;
            if (this.originals.removeAttribute)
              Element.prototype.removeAttribute = this.originals.removeAttribute;
            if (this.originals.appendChild)
              Node.prototype.appendChild = this.originals.appendChild;
            if (this.originals.removeChild)
              Node.prototype.removeChild = this.originals.removeChild;
            if (this.originals.replaceChild)
              Node.prototype.replaceChild = this.originals.replaceChild;
            if (this.originals.insertBefore)
              Node.prototype.insertBefore = this.originals.insertBefore;
            if (this.originals.classListAdd)
              DOMTokenList.prototype.add = this.originals.classListAdd;
            if (this.originals.classListRemove)
              DOMTokenList.prototype.remove = this.originals.classListRemove;
            if (this.originals.styleSetProperty)
              CSSStyleDeclaration.prototype.setProperty = this.originals.styleSetProperty;
            if (this.originals.createElement)
              Document.prototype.createElement = this.originals.createElement;
          } catch {
          }
          this.installed = false;
        }
        static silence(fn) {
          this.silenced++;
          try {
            return fn();
          } finally {
            this.silenced--;
          }
        }
        static maybeWarn(op, el) {
          try {
            if (this.silenced > 0)
              return;
            console.warn(`\u26A0\uFE0F StageDomGuard: Direct DOM write detected via ${op}. Use ctx.stageCrew instead.`);
          } catch {
          }
        }
      };
      StageDomGuard.installed = false;
      StageDomGuard.originals = {};
      StageDomGuard.silenced = 0;
    }
  });

  // dist/modules/communication/sequences/stage/StageCrew.js
  var StageCrew_exports = {};
  __export(StageCrew_exports, {
    StageCrew: () => StageCrew
  });
  var BeatTxn, StageCrew;
  var init_StageCrew = __esm({
    "dist/modules/communication/sequences/stage/StageCrew.js"() {
      "use strict";
      init_ConductorEnv();
      init_StageDomGuard();
      BeatTxn = class {
        constructor(eventBus2, pluginId, correlationId, meta) {
          this.eventBus = eventBus2;
          this.pluginId = pluginId;
          this.correlationId = correlationId;
          this.meta = meta;
          this.ops = [];
          this.batchRequested = false;
        }
        update(selector, opts) {
          if (opts?.classes?.add) {
            for (const v of opts.classes.add)
              this.ops.push({ op: "classes.add", selector, value: v });
          }
          if (opts?.classes?.remove) {
            for (const v of opts.classes.remove)
              this.ops.push({ op: "classes.remove", selector, value: v });
          }
          if (opts?.attrs) {
            for (const [k, v] of Object.entries(opts.attrs))
              this.ops.push({ op: "attr.set", selector, key: k, value: v });
          }
          if (opts?.style) {
            for (const [k, v] of Object.entries(opts.style))
              this.ops.push({ op: "style.set", selector, key: k, value: v });
          }
          return this;
        }
        create(tag, opts) {
          const record = { op: "create", tag };
          if (opts?.classes?.length)
            record.classes = [...opts.classes];
          if (opts?.attrs)
            record.attrs = { ...opts.attrs };
          return {
            appendTo: (parent) => {
              this.ops.push({ ...record, parent });
              return this;
            }
          };
        }
        remove(selector) {
          this.ops.push({ op: "remove", selector });
          return this;
        }
        applyOpsToDom() {
          try {
            if (typeof document === "undefined")
              return;
            const apply = () => {
              for (const op of this.ops) {
                switch (op.op) {
                  case "classes.add": {
                    const el = document.querySelector(op.selector);
                    if (el)
                      el.classList.add(op.value);
                    break;
                  }
                  case "classes.remove": {
                    const el = document.querySelector(op.selector);
                    if (el)
                      el.classList.remove(op.value);
                    break;
                  }
                  case "attr.set": {
                    const el = document.querySelector(op.selector);
                    if (el)
                      el.setAttribute(op.key, op.value);
                    break;
                  }
                  case "style.set": {
                    const el = document.querySelector(op.selector);
                    if (el)
                      el.style[op.key] = op.value;
                    break;
                  }
                  case "create": {
                    const parent = document.querySelector(op.parent);
                    if (!parent)
                      break;
                    const el = document.createElement(op.tag);
                    if (op.classes)
                      for (const c of op.classes)
                        el.classList.add(c);
                    if (op.attrs)
                      for (const [k, v] of Object.entries(op.attrs))
                        el.setAttribute(k, v);
                    parent.appendChild(el);
                    break;
                  }
                  case "remove": {
                    const el = document.querySelector(op.selector);
                    if (el && el.parentElement)
                      el.parentElement.removeChild(el);
                    break;
                  }
                }
              }
            };
            if (isDevEnv()) {
              StageDomGuard.silence(apply);
            } else {
              apply();
            }
          } catch {
          }
        }
        commit(opts) {
          const cue = {
            pluginId: this.pluginId,
            correlationId: this.correlationId,
            operations: [...this.ops],
            // Mark as internal StageCrew emission so SPAValidator can allow-list this path
            meta: { ...this.meta || {}, __stageCrewInternal: true }
          };
          const fire = () => {
            this.applyOpsToDom();
            this.eventBus.emit("stage:cue", cue);
          };
          const raf = typeof window !== "undefined" && window.requestAnimationFrame || null;
          if (opts?.batch && raf) {
            raf(() => fire());
          } else {
            fire();
          }
        }
      };
      StageCrew = class {
        constructor(eventBus2, pluginId) {
          this.eventBus = eventBus2;
          this.pluginId = pluginId;
        }
        beginBeat(correlationId, meta) {
          return new BeatTxn(this.eventBus, this.pluginId, correlationId, meta);
        }
      };
    }
  });

  // dist/modules/communication/EventBus.js
  init_event_types();
  var EventBus = class {
    constructor() {
      this.events = {};
      this.debugMode = true;
      this.subscriptionCounter = 0;
      this.eventCounts = {};
    }
    /**
     * Subscribe to an event
     * @param eventName - Name of the event to subscribe to
     * @param callback - Function to call when event is emitted
     * @param context - Optional context including pluginId for deduplication
     * @returns Unsubscribe function
     */
    subscribe(eventName, callback, context) {
      if (!this.events[eventName]) {
        this.events[eventName] = [];
      }
      if (context?.pluginId) {
        const existingSubscription = this.events[eventName].find((sub) => sub.pluginId === context.pluginId);
        if (existingSubscription) {
          const pluginInfo = ` from plugin ${context.pluginId}`;
          console.warn(`\u{1F6AB} EventBus: Duplicate subscription blocked for "${eventName}"${pluginInfo}`);
          return () => {
            this.unsubscribe(eventName, callback);
          };
        }
      }
      const subscription = {
        id: `sub_${this.subscriptionCounter++}`,
        eventName,
        callback,
        subscribedAt: /* @__PURE__ */ new Date(),
        pluginId: context?.pluginId,
        context
      };
      this.events[eventName].push(subscription);
      if (this.debugMode) {
        const pluginInfo = context?.pluginId ? ` (plugin: ${context.pluginId})` : "";
        console.log(`\u{1F4E1} EventBus: Subscribed to "${eventName}" (${this.events[eventName].length} total subscribers)${pluginInfo}`);
      }
      return () => {
        this.unsubscribe(eventName, callback);
      };
    }
    /**
     * Unsubscribe from an event
     * @param eventName - Name of the event
     * @param callback - Callback function to remove
     */
    unsubscribe(eventName, callback) {
      if (!this.events[eventName]) {
        return;
      }
      const index = this.events[eventName].findIndex((sub) => sub.callback === callback);
      if (index > -1) {
        const removedSub = this.events[eventName][index];
        this.events[eventName].splice(index, 1);
        if (this.debugMode) {
          const pluginInfo = removedSub.pluginId ? ` (plugin: ${removedSub.pluginId})` : "";
          console.log(`\u{1F4E1} EventBus: Unsubscribed from "${eventName}" (${this.events[eventName].length} remaining subscribers)${pluginInfo}`);
        }
        if (this.events[eventName].length === 0) {
          delete this.events[eventName];
        }
      }
    }
    /**
     * Emit an event to all subscribers
     * @param eventName - Name of the event to emit
     * @param data - Data to pass to subscribers
     */
    emit(eventName, data) {
      this.eventCounts[eventName] = (this.eventCounts[eventName] || 0) + 1;
      if (!this.events[eventName]) {
        return Promise.resolve();
      }
      const subscribers = [...this.events[eventName]];
      subscribers.forEach((subscription, index) => {
        try {
          const result = subscription.callback(data);
          if (result && typeof result.catch === "function") {
            result.catch((error) => {
              const pluginInfo = subscription.pluginId ? ` (plugin: ${subscription.pluginId})` : "";
              console.error(`\u{1F4E1} EventBus: Async error in subscriber ${index} for "${eventName}"${pluginInfo}:`, error);
            });
          }
        } catch (error) {
          const pluginInfo = subscription.pluginId ? ` (plugin: ${subscription.pluginId})` : "";
          console.error(`\u{1F4E1} EventBus: Error in subscriber ${index} for "${eventName}"${pluginInfo}:`, error);
        }
      });
      return Promise.resolve();
    }
    /**
     * Emit an event and await all (possibly async) subscribers
     * Resolves when all subscriber callbacks have settled
     */
    async emitAsync(eventName, data) {
      this.eventCounts[eventName] = (this.eventCounts[eventName] || 0) + 1;
      if (!this.events[eventName]) {
        return;
      }
      const subscribers = [...this.events[eventName]];
      const tasks = subscribers.map((subscription, index) => {
        try {
          const ret = subscription.callback(data);
          return Promise.resolve(ret);
        } catch (error) {
          const pluginInfo = subscription.pluginId ? ` (plugin: ${subscription.pluginId})` : "";
          console.error(`\u{1F4E1} EventBus: Error in subscriber ${index} for "${eventName}"${pluginInfo}:`, error);
          return Promise.resolve();
        }
      });
      await Promise.allSettled(tasks);
    }
    /**
     * Remove all subscribers for an event
     * @param eventName - Name of the event to clear
     */
    clearEvent(eventName) {
      if (this.events[eventName]) {
        delete this.events[eventName];
        if (this.debugMode) {
          console.log(`\u{1F4E1} EventBus: Cleared all subscribers for "${eventName}"`);
        }
      }
    }
    /**
     * Remove all subscribers for all events
     */
    clearAll() {
      this.events = {};
      this.eventCounts = {};
      if (this.debugMode) {
        console.log("\u{1F4E1} EventBus: Cleared all subscribers");
      }
    }
    /**
     * Get debug information about the EventBus
     */
    getDebugInfo() {
      const subscriptionCounts = {};
      let totalSubscriptions = 0;
      Object.keys(this.events).forEach((eventName) => {
        subscriptionCounts[eventName] = this.events[eventName].length;
        totalSubscriptions += this.events[eventName].length;
      });
      const totalEventsEmitted = Object.values(this.eventCounts).reduce((sum, count) => sum + count, 0);
      return {
        totalEvents: totalEventsEmitted,
        totalSubscriptions,
        eventCounts: { ...this.eventCounts },
        subscriptionCounts
      };
    }
    /**
     * Check if an event has subscribers
     * @param eventName - Name of the event to check
     */
    hasSubscribers(eventName) {
      return !!(this.events[eventName] && this.events[eventName].length > 0);
    }
    /**
     * Get subscriber count for an event
     * @param eventName - Name of the event
     */
    getSubscriberCount(eventName) {
      return this.events[eventName]?.length || 0;
    }
    /**
     * Enable or disable debug mode
     * @param enabled - Whether to enable debug mode
     */
    setDebugMode(enabled) {
      this.debugMode = enabled;
      console.log(`\u{1F4E1} EventBus: Debug mode ${enabled ? "enabled" : "disabled"}`);
    }
  };
  var ConductorEventBus = class extends EventBus {
    constructor(externalConductor = null) {
      super();
      this.externalConductor = null;
      this.sequences = /* @__PURE__ */ new Map();
      this.priorities = /* @__PURE__ */ new Map();
      this.dependencies = /* @__PURE__ */ new Map();
      this.currentSequences = /* @__PURE__ */ new Map();
      this.completedEvents = /* @__PURE__ */ new Set();
      this.metrics = {
        eventsProcessed: 0,
        sequencesExecuted: 0,
        averageLatency: 0,
        raceConditionsDetected: 0
      };
      this.tempo = 120;
      if (externalConductor) {
        console.log("\u{1F3BC} EventBus: Using external conductor for unified sequence system");
        this.externalConductor = externalConductor;
        this.sequences = externalConductor.sequences || /* @__PURE__ */ new Map();
      } else {
        console.log("\u{1F3BC} EventBus: Using internal conductor (legacy mode)");
        this.sequences = /* @__PURE__ */ new Map();
      }
    }
    /**
     * Enhanced emit with conductor control
     * @param eventName - Event to emit
     * @param data - Event data
     * @param options - Conductor options
     */
    emit(eventName, data, options = {}) {
      const startTime = performance.now();
      if (options.sequence) {
        this.emitInSequence(eventName, data, options);
        return Promise.resolve();
      }
      const priority = this.priorities.get(eventName) || "mp";
      const dependencies = this.dependencies.get(eventName) || [];
      if (dependencies.length > 0 && !this.dependenciesMet(dependencies, options.context)) {
        this.queueForDependencies(eventName, data, options, dependencies);
        return Promise.resolve();
      }
      this.executeWithTiming(eventName, data, options, priority);
      this.updateMetrics(eventName, startTime);
      return Promise.resolve();
    }
    /**
     * Execute event with musical timing
     * @param eventName - Event name
     * @param data - Event data
     * @param options - Timing options
     * @param priority - Event priority
     */
    executeWithTiming(eventName, data, options, priority) {
      const timing = options.timing || "immediate";
      switch (timing) {
        case "immediate":
          this.executeEvent(eventName, data, priority);
          break;
        case "after-beat":
          setTimeout(() => this.executeEvent(eventName, data, priority), 0);
          break;
        case "next-measure":
          setTimeout(() => this.executeEvent(eventName, data, priority), 0);
          break;
        case "delayed":
          const delay = this.calculateDelay(options.beats || 1);
          setTimeout(() => this.executeEvent(eventName, data, priority), delay);
          break;
        case "wait-for-signal":
          this.queueForSignal(eventName, data, options.signal, priority);
          break;
        default:
          this.executeEvent(eventName, data, priority);
      }
    }
    /**
     * Execute event with base EventBus emit
     * @param eventName - Event name
     * @param data - Event data
     * @param priority - Event priority
     */
    executeEvent(eventName, data, priority) {
      super.emit(eventName, data);
      this.completedEvents.add(eventName);
    }
    /**
     * Emit event in sequence context
     * @param eventName - Event name
     * @param data - Event data
     * @param options - Sequence options
     */
    emitInSequence(eventName, data, options) {
      if (this.externalConductor && this.externalConductor.startSequence) {
        console.log(`\u{1F3BC} EventBus: Delegating to external conductor for sequence event "${eventName}"`);
        return this.externalConductor.startSequence(options.sequence, data, options.context);
      }
      super.emit(eventName, data);
    }
    /**
     * Check if dependencies are met
     * @param dependencies - Array of dependency event names
     * @param context - Execution context
     */
    dependenciesMet(dependencies, context) {
      return dependencies.every((dep) => this.completedEvents.has(dep));
    }
    /**
     * Queue event for dependencies
     * @param eventName - Event name
     * @param data - Event data
     * @param options - Options
     * @param dependencies - Dependencies
     */
    queueForDependencies(eventName, data, options, dependencies) {
      console.log(`\u{1F3BC} EventBus: Queueing ${eventName} for dependencies:`, dependencies);
      setTimeout(() => {
        if (this.dependenciesMet(dependencies, options.context)) {
          this.emit(eventName, data, { ...options, timing: "immediate" });
        }
      }, 50);
    }
    /**
     * Queue event for signal
     * @param eventName - Event name
     * @param data - Event data
     * @param signal - Signal to wait for
     * @param priority - Event priority
     */
    queueForSignal(eventName, data, signal, priority) {
      console.log(`\u{1F3BC} EventBus: Queueing ${eventName} for signal: ${signal}`);
      const checkSignal = () => {
        if (this.completedEvents.has(signal)) {
          this.executeEvent(eventName, data, priority);
        } else {
          setTimeout(checkSignal, 10);
        }
      };
      checkSignal();
    }
    /**
     * Calculate delay based on tempo
     * @param beats - Number of beats to delay
     */
    calculateDelay(beats) {
      const msPerBeat = 60 / this.tempo * 1e3;
      return beats * msPerBeat;
    }
    /**
     * Update performance metrics
     * @param eventName - Event name
     * @param startTime - Start time
     */
    updateMetrics(eventName, startTime) {
      const latency = performance.now() - startTime;
      this.metrics.eventsProcessed++;
      const alpha = 0.1;
      this.metrics.averageLatency = this.metrics.averageLatency * (1 - alpha) + latency * alpha;
    }
    /**
     * Connect to external conductor
     * @param conductor - The main conductor instance
     */
    connectToMainConductor(conductor) {
      console.log("\u{1F3BC} EventBus: Connecting to main conductor for unified sequence system");
      this.externalConductor = conductor;
      if (conductor.sequences) {
        this.sequences = conductor.sequences;
        console.log(`\u{1F3BC} EventBus: Connected to main conductor with ${this.sequences.size} sequences`);
      } else {
        console.warn("\u{1F6A8} EventBus: Main conductor does not have sequences property");
      }
    }
    /**
     * Get basic performance metrics
     */
    getBasicMetrics() {
      return { ...this.metrics };
    }
    /**
     * Reset performance metrics
     */
    resetMetrics() {
      this.metrics = {
        eventsProcessed: 0,
        sequencesExecuted: 0,
        averageLatency: 0,
        raceConditionsDetected: 0
      };
    }
    /**
     * Set musical tempo (BPM)
     */
    setTempo(bpm) {
      this.tempo = bpm;
    }
    /**
     * Get current musical tempo (BPM)
     */
    getTempo() {
      return this.tempo;
    }
    /**
     * Get beat duration in milliseconds based on current tempo
     */
    getBeatDuration() {
      return 60 / this.tempo * 1e3;
    }
    /**
     * Register a musical sequence
     */
    registerSequence(key, sequence) {
      this.sequences.set(key, sequence);
    }
    /**
     * Get all sequence names
     */
    getSequenceNames() {
      return Array.from(this.sequences.keys());
    }
    /**
     * Play a sequence through the conductor
     */
    async play(sequenceName, data) {
      this.metrics.sequencesExecuted++;
      if (this.externalConductor && this.externalConductor.startSequence) {
        try {
          return await this.externalConductor.startSequence(sequenceName, data);
        } catch (error) {
          console.error(`\u{1F3BC} EventBus: Error playing sequence ${sequenceName}:`, error);
        }
      } else {
        this.emit("sequence-start", { sequenceName, data });
      }
    }
    /**
     * Get comprehensive metrics including conductor stats
     */
    getMetrics() {
      const eventBusStats = this.getDebugInfo();
      const conductorStats = this.externalConductor?.getStatistics?.() || {};
      return {
        sequenceCount: this.sequences.size,
        sequenceExecutions: this.metrics.sequencesExecuted,
        eventBusStats,
        conductorStats,
        ...this.metrics
      };
    }
  };
  var eventBus = new ConductorEventBus();

  // dist/modules/communication/index.js
  init_event_types();

  // dist/modules/communication/sequences/MusicalConductor.js
  init_SequenceTypes();

  // dist/modules/communication/SPAValidator.js
  var SPAValidator = class _SPAValidator {
    constructor(config = {}) {
      this.violations = [];
      this.originalEventBusEmit = null;
      this.originalEventBusSubscribe = null;
      this.registeredPlugins = /* @__PURE__ */ new Set();
      this.config = {
        strictMode: true,
        allowedPlugins: [],
        logViolations: true,
        throwOnViolation: false,
        enableRuntimeChecks: true,
        enforceConductorLogger: "warn",
        ...config
      };
      if (this.config.strictMode && this.config.enforceConductorLogger !== "off") {
        this.config.enforceConductorLogger = "error";
      }
      if (this.config.enableRuntimeChecks) {
        this.initializeRuntimeChecks();
      }
    }
    /**
     * Initialize runtime checks by intercepting eventBus.emit calls and subscribe calls
     */
    initializeRuntimeChecks() {
      this.originalEventBusEmit = EventBus.prototype.emit;
      EventBus.prototype.emit = this.createValidatedEmit();
      this.originalEventBusSubscribe = EventBus.prototype.subscribe;
      EventBus.prototype.subscribe = this.createValidatedSubscribe();
      this.interceptGlobalAccess();
      console.log("\u{1F3BC} SPA Validator: Runtime checks initialized");
    }
    /**
     * Create validated emit function that checks for plugin violations
     */
    createValidatedEmit() {
      return function(eventName, data, options = {}) {
        const validator = _SPAValidator.getInstance();
        if (typeof eventName === "string" && (eventName.startsWith("musical-conductor:") || eventName.startsWith("conductor:"))) {
          return validator.originalEventBusEmit.call(this, eventName, data, options);
        }
        if (eventName === "stage:cue" && data && data.meta && data.meta.__stageCrewInternal) {
          return validator.originalEventBusEmit.call(this, eventName, data, options);
        }
        const stack = new Error().stack || "";
        const callerInfo = validator.analyzeCallStack(stack);
        if (validator.isPluginCall(callerInfo)) {
          const loc = validator.extractLocationFromStack(stack);
          const violation = validator.createViolation("RUNTIME_DIRECT_EVENTBUS_EMIT", callerInfo.pluginId, `Plugin '${callerInfo.pluginId}' directly called eventBus.emit('${eventName}')`, stack, "critical", {
            fileUrl: loc.fileUrl,
            lineNumber: loc.lineNumber,
            columnNumber: loc.columnNumber,
            codeSnippet: loc.stackLine
          });
          validator.handleViolation(violation);
          if (validator.config.strictMode) {
            console.error(`\u{1F6AB} SPA Validator: Blocked direct eventBus.emit() call from plugin '${callerInfo.pluginId}'`);
            console.error(`\u{1F4A1} Use conductor.play('${callerInfo.pluginId}', 'SEQUENCE_NAME', data) instead`);
            return;
          }
        }
        return validator.originalEventBusEmit.call(this, eventName, data, options);
      };
    }
    /**
     * Create validated subscribe function that checks for React component violations
     */
    createValidatedSubscribe() {
      return function(eventName, callback, context) {
        const validator = _SPAValidator.getInstance();
        const stack = new Error().stack || "";
        const callerInfo = validator.analyzeCallStack(stack);
        if (callerInfo.isMusicalConductor) {
          return validator.originalEventBusSubscribe.call(this, eventName, callback, context);
        }
        if (callerInfo.isReactComponent) {
          const loc = validator.extractLocationFromStack(stack);
          const violation = validator.createViolation("RUNTIME_REACT_COMPONENT_EVENTBUS_SUBSCRIBE", "react-component", `React component directly called eventBus.subscribe('${eventName}') - should use conductor.subscribe()`, stack, "critical", {
            fileUrl: loc.fileUrl,
            lineNumber: loc.lineNumber,
            columnNumber: loc.columnNumber,
            codeSnippet: loc.stackLine
          });
          validator.handleViolation(violation);
          if (validator.config.strictMode) {
            throw new Error(`React component violation: Use conductor.subscribe('${eventName}', callback) instead of eventBus.subscribe()`);
          }
        }
        if (callerInfo.isPlugin && !callerInfo.isInMountMethod) {
          const loc = validator.extractLocationFromStack(stack);
          const violation = validator.createViolation("RUNTIME_PLUGIN_EVENTBUS_SUBSCRIBE_OUTSIDE_MOUNT", callerInfo.pluginId, `Plugin '${callerInfo.pluginId}' called eventBus.subscribe() outside mount method`, stack, "error", {
            fileUrl: loc.fileUrl,
            lineNumber: loc.lineNumber,
            columnNumber: loc.columnNumber,
            codeSnippet: loc.stackLine
          });
          validator.handleViolation(violation);
        }
        return validator.originalEventBusSubscribe.call(this, eventName, callback, context);
      };
    }
    /**
     * Intercept global eventBus access through window.renderxCommunicationSystem
     */
    interceptGlobalAccess() {
      if (typeof window === "undefined")
        return;
      const originalDescriptor = Object.getOwnPropertyDescriptor(window, "renderxCommunicationSystem");
      let communicationSystem = null;
      Object.defineProperty(window, "renderxCommunicationSystem", {
        get: () => {
          const stack = new Error().stack || "";
          const callerInfo = this.analyzeCallStack(stack);
          if (this.isViolatingGlobalAccess(callerInfo, stack)) {
            this.handleGlobalAccessViolation(callerInfo, stack);
          }
          return communicationSystem;
        },
        set: (value) => {
          communicationSystem = value;
        },
        configurable: true
      });
    }
    /**
     * Check if global access is violating SPA principles
     */
    isViolatingGlobalAccess(callerInfo, stack) {
      if (callerInfo.source === "MusicalConductor" || stack.includes("AppContent")) {
        return false;
      }
      if (stack.includes(".eventBus")) {
        return true;
      }
      return false;
    }
    /**
     * Handle global access violations
     */
    handleGlobalAccessViolation(callerInfo, stack) {
      const loc = this.extractLocationFromStack(stack);
      const violation = this.createViolation("RUNTIME_GLOBAL_EVENTBUS_ACCESS", callerInfo.pluginId || callerInfo.source, `Global eventBus access detected - should use conductor methods instead`, stack, "critical", {
        fileUrl: loc.fileUrl,
        lineNumber: loc.lineNumber,
        columnNumber: loc.columnNumber,
        codeSnippet: loc.stackLine
      });
      this.handleViolation(violation);
    }
    /**
     * Analyze call stack to identify plugin calls, React components, and mount methods
     */
    analyzeCallStack(stack) {
      const lines = stack.split("\n");
      let isReactComponent = false;
      let isInMountMethod = false;
      let isMusicalConductor = false;
      let source = "unknown";
      for (const line of lines) {
        const normalized = String(line).replace(/\\\\/g, "/");
        if (normalized.includes("/node_modules/musical-conductor/") || normalized.includes("/musical-conductor/dist/") || normalized.includes("/musical-conductor/") || normalized.includes("/dist/modules/communication/") || normalized.includes("/modules/communication/")) {
          return {
            isPlugin: false,
            pluginId: "MusicalConductor",
            fileName: line,
            isReactComponent: false,
            isInMountMethod: false,
            source: "MusicalConductor",
            isMusicalConductor: true
          };
        }
        if (normalized.includes("MusicalConductor") || normalized.includes("/sequences/MusicalConductor.ts") || normalized.includes("/sequences/core/") || normalized.includes("/sequences/plugins/PluginManager") || normalized.includes("/sequences/plugins/PluginInterfaceFacade") || normalized.includes("/sequences/plugins/PluginLoader") || normalized.includes("/sequences/plugins/PluginValidator") || normalized.includes("/sequences/plugins/PluginManifestLoader") || normalized.includes("SequenceRegistry") || normalized.includes("EventSubscriptionManager") || normalized.includes("ConductorCore") || normalized.includes("EventOrchestrator") || normalized.includes("SequenceOrchestrator") || normalized.includes("/communication/EventBus") || normalized.includes("/communication/SPAValidator") || // Handle filename-only patterns (common in minified/bundled code)
        normalized.includes("PluginManager.js") || normalized.includes("PluginInterfaceFacade.js") || normalized.includes("PluginLoader.js") || normalized.includes("PluginValidator.js") || normalized.includes("PluginManifestLoader.js") || normalized.includes("SequenceRegistry.js") || normalized.includes("EventSubscriptionManager.js") || normalized.includes("ConductorCore.js") || normalized.includes("EventOrchestrator.js") || normalized.includes("SequenceOrchestrator.js") || normalized.includes("EventBus.js") || normalized.includes("SPAValidator.js")) {
          isMusicalConductor = true;
          source = "MusicalConductor";
          return {
            isPlugin: false,
            pluginId: "MusicalConductor",
            fileName: line,
            isReactComponent: false,
            isInMountMethod: false,
            source,
            isMusicalConductor: true
          };
        }
        const reactMatch = normalized.match(/\/components\/([^\/]+\.tsx?)/);
        if (reactMatch) {
          isReactComponent = true;
          source = `React:${reactMatch[1]}`;
        }
        if (line.includes(".mount(") || line.includes("mount:")) {
          isInMountMethod = true;
        }
        const pluginMatch = line.match(/\/plugins\/([^\/]+)/);
        if (pluginMatch) {
          return {
            isPlugin: true,
            pluginId: pluginMatch[1],
            fileName: line,
            isReactComponent,
            isInMountMethod,
            source: `Plugin:${pluginMatch[1]}`,
            isMusicalConductor: false
          };
        }
        const symphonyMatch = line.match(/([^\/]+\.symphony)/);
        if (symphonyMatch) {
          return {
            isPlugin: true,
            pluginId: symphonyMatch[1],
            fileName: line,
            isReactComponent,
            isInMountMethod,
            source: `Plugin:${symphonyMatch[1]}`,
            isMusicalConductor: false
          };
        }
        if (line.includes("MusicalConductor")) {
          source = "MusicalConductor";
        }
      }
      return {
        isPlugin: false,
        pluginId: "unknown",
        fileName: "unknown",
        isReactComponent,
        isInMountMethod,
        source,
        isMusicalConductor: false
      };
    }
    /**
     * Best-effort extraction of file URL, line and column from a JS stack trace
     */
    extractLocationFromStack(stack) {
      if (!stack)
        return {};
      const lines = stack.split("\n");
      for (const raw of lines) {
        const line = String(raw).trim();
        if (!line)
          continue;
        if (line.includes("SPAValidator") || line.includes("EventBus"))
          continue;
        const match = line.match(/(https?:\/\/[^\s\)]+|file:\/\/[^\s\)]+|\/[\w\-\.\/]+):(\d+):(\d+)/);
        if (match) {
          const fileUrl = match[1];
          const lineNumber = Number(match[2]);
          const columnNumber = Number(match[3]);
          return { fileUrl, lineNumber, columnNumber, stackLine: line };
        }
        const parenMatch = line.match(/\(([^\s\)]+):(\d+):(\d+)\)/);
        if (parenMatch) {
          const fileUrl = parenMatch[1];
          const lineNumber = Number(parenMatch[2]);
          const columnNumber = Number(parenMatch[3]);
          return { fileUrl, lineNumber, columnNumber, stackLine: line };
        }
      }
      return { stackLine: lines[1] || lines[0] };
    }
    /**
     * Check if call is from a plugin
     */
    isPluginCall(callerInfo) {
      if (!callerInfo.isPlugin)
        return false;
      if (callerInfo.isMusicalConductor)
        return false;
      if (this.config.allowedPlugins.includes(callerInfo.pluginId)) {
        return false;
      }
      return true;
    }
    /**
     * Create violation record
     */
    createViolation(type, pluginId, description, stackTrace, severity, extras = {}) {
      return {
        type,
        pluginId,
        description,
        stackTrace,
        timestamp: /* @__PURE__ */ new Date(),
        severity,
        ...extras
      };
    }
    /**
     * Handle violation based on configuration
     */
    handleViolation(violation) {
      this.violations.push(violation);
      if (this.config.logViolations) {
        console.error(`\u{1F3BC} SPA Violation [${violation.severity.toUpperCase()}]: ${violation.description}`);
        console.error(`   Plugin: ${violation.pluginId}`);
        console.error(`   Time: ${violation.timestamp.toISOString()}`);
        if (violation.fileUrl && typeof violation.lineNumber === "number") {
          const col = typeof violation.columnNumber === "number" ? `:${violation.columnNumber}` : "";
          console.error(`   Location: ${violation.fileUrl}:${violation.lineNumber}${col}`);
        }
        if (violation.codeSnippet) {
          console.error(`   Code: ${violation.codeSnippet.trim()}`);
        }
        if (violation.severity === "critical") {
          console.error(`   Stack: ${violation.stackTrace.split("\n").slice(0, 3).join("\n")}`);
        }
      }
      if (this.config.throwOnViolation && violation.severity === "critical") {
        throw new Error(`SPA Violation: ${violation.description}`);
      }
    }
    /**
     * Register a plugin as allowed to use eventBus directly (for migration)
     */
    registerPlugin(pluginId) {
      this.registeredPlugins.add(pluginId);
    }
    /**
     * Validate plugin compliance before mounting
     */
    /**
     * Detect direct console usage in a function's source
     */
    detectDirectConsoleUsage(fn) {
      try {
        const src = Function.prototype.toString.call(fn);
        return /(\b|\.)console\.(log|info|warn|error|debug)\b/.test(src);
      } catch {
        return false;
      }
    }
    validatePluginMount(pluginId, pluginCode) {
      const violations = [];
      const lines = pluginCode.split(/\r?\n/);
      const directEmitRegex = /(^|[^\.\w])eventBus\.emit\s*\(/;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmed = String(line).trim();
        if (/^\s*\/\//.test(trimmed) || /^\s*$/.test(trimmed))
          continue;
        if (directEmitRegex.test(line)) {
          violations.push(`eventBus.emit() at line ${i + 1}: ${trimmed}`);
        }
      }
      const globalEmitRegex = /window\..*eventBus\.emit\s*\(/;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmed = String(line).trim();
        if (/^\s*\/\//.test(trimmed) || /^\s*$/.test(trimmed))
          continue;
        if (globalEmitRegex.test(line)) {
          violations.push(`global eventBus access at line ${i + 1}: ${trimmed}`);
        }
      }
      const hasEmitFindings = violations.some((v) => v.includes("eventBus"));
      if (hasEmitFindings && !/conductor\.play\s*\(/.test(pluginCode)) {
        violations.push(`Uses eventBus.emit() but no conductor.play() - migrate to SPA`);
      }
      return {
        valid: violations.length === 0,
        violations
      };
    }
    /**
     * Get all violations
     */
    getViolations() {
      return [...this.violations];
    }
    /**
     * Get violations by plugin
     */
    getViolationsByPlugin(pluginId) {
      return this.violations.filter((v) => v.pluginId === pluginId);
    }
    /**
     * Clear violations
     */
    clearViolations() {
      this.violations = [];
    }
    /**
     * Generate compliance report
     */
    generateComplianceReport() {
      const violationsByPlugin = {};
      const violationsBySeverity = {};
      const recommendations = [];
      for (const violation of this.violations) {
        violationsByPlugin[violation.pluginId] = (violationsByPlugin[violation.pluginId] || 0) + 1;
        violationsBySeverity[violation.severity] = (violationsBySeverity[violation.severity] || 0) + 1;
      }
      for (const [pluginId, count] of Object.entries(violationsByPlugin)) {
        recommendations.push(`Plugin '${pluginId}' has ${count} violation(s) - migrate to conductor.play() pattern`);
      }
      return {
        totalViolations: this.violations.length,
        violationsByPlugin,
        violationsBySeverity,
        recommendations
      };
    }
    static getInstance() {
      if (!_SPAValidator.instance) {
        _SPAValidator.instance = new _SPAValidator();
      }
      return _SPAValidator.instance;
    }
    /**
     * Initialize SPA validation with configuration
     */
    static initialize(config = {}) {
      _SPAValidator.instance = new _SPAValidator(config);
      return _SPAValidator.instance;
    }
    /**
     * Disable runtime checks (for testing or migration)
     */
    disableRuntimeChecks() {
      if (this.originalEventBusEmit) {
        EventBus.prototype.emit = this.originalEventBusEmit;
        console.log("\u{1F3BC} SPA Validator: Runtime checks disabled");
      }
    }
  };

  // dist/modules/communication/sequences/core/ConductorCore.js
  init_ConductorEnv();
  var ConductorCore = class _ConductorCore {
    constructor(eventBus2) {
      this.eventSubscriptions = [];
      this.beatLoggingInitialized = false;
      this.eventBus = eventBus2;
      this.spaValidator = SPAValidator.getInstance();
      void this.initialize();
    }
    /**
     * Get singleton instance of ConductorCore
     * @param eventBus - Required for first initialization
     * @returns ConductorCore instance
     */
    static getInstance(eventBus2) {
      if (!_ConductorCore.instance) {
        if (!eventBus2) {
          throw new Error("EventBus is required for first initialization");
        }
        _ConductorCore.instance = new _ConductorCore(eventBus2);
      }
      return _ConductorCore.instance;
    }
    /**
     * Reset the singleton instance (primarily for testing)
     */
    static resetInstance() {
      if (_ConductorCore.instance) {
        _ConductorCore.instance.cleanup();
        _ConductorCore.instance = null;
      }
    }
    /**
     * Get the EventBus instance
     */
    getEventBus() {
      return this.eventBus;
    }
    /**
     * Get the SPAValidator instance
     */
    getSPAValidator() {
      return this.spaValidator;
    }
    /**
     * Initialize core functionality
     */
    async initialize() {
      this.setupBeatExecutionLogging();
      try {
        const isDev = isDevEnv();
        if (isDev) {
          const { ConductorLogger: ConductorLogger2 } = await Promise.resolve().then(() => (init_ConductorLogger(), ConductorLogger_exports));
          const logger = new ConductorLogger2(this.eventBus, true);
          logger.init();
        }
      } catch (e) {
        console.warn("\u26A0\uFE0F ConductorLogger initialization skipped:", e?.message || e);
      }
      console.log("\u{1F3BC} ConductorCore: Initialized successfully");
    }
    /**
     * Setup beat execution logging with hierarchical support
     */
    setupBeatExecutionLogging() {
      if (this.beatLoggingInitialized) {
        console.log("\u{1F3BC} Beat execution logging already initialized, skipping...");
        return;
      }
      console.log("\u{1F3BC} ConductorCore: Setting up beat execution logging...");
      const beatStartedUnsubscribe = this.eventBus.subscribe("musical-conductor:beat:started", (data) => {
        if (this.shouldEnableHierarchicalLogging()) {
          this.logBeatStartedHierarchical(data);
        }
      });
      const beatCompletedUnsubscribe = this.eventBus.subscribe("musical-conductor:beat:completed", (data) => {
        if (this.shouldEnableHierarchicalLogging()) {
          this.logBeatCompletedHierarchical(data);
        }
      });
      const beatErrorUnsubscribe = this.eventBus.subscribe("musical-conductor:beat:error", (data) => {
        if (!this.shouldEnableHierarchicalLogging()) {
          console.error("\u{1F3BC} Beat execution error:", data);
        }
      });
      this.eventSubscriptions.push(beatStartedUnsubscribe, beatCompletedUnsubscribe, beatErrorUnsubscribe);
      this.beatLoggingInitialized = true;
      console.log("\u2705 Beat execution logging initialized");
    }
    /**
     * Log beat started event in hierarchical format
     */
    logBeatStartedHierarchical(data) {
      const { sequenceName, movementName, beatNumber, eventType, timing } = data;
      console.log(`\u{1F3BC} \u250C\u2500 Beat ${beatNumber} Started`);
      console.log(`\u{1F3BC} \u2502  Sequence: ${sequenceName}`);
      console.log(`\u{1F3BC} \u2502  Movement: ${movementName}`);
      console.log(`\u{1F3BC} \u2502  Event: ${eventType}`);
      console.log(`\u{1F3BC} \u2502  Timing: ${timing}`);
      if (data.payload) {
        console.log(`\u{1F3BD} \u2502  Data Baton:`, data.payload);
      }
    }
    /**
     * Log beat completed event in hierarchical format
     */
    logBeatCompletedHierarchical(data) {
      const { sequenceName, movementName, beatNumber, duration } = data;
      console.log(`\u{1F3BC} \u2514\u2500 Beat ${beatNumber} Completed`);
      console.log(`\u{1F3BC}    Duration: ${duration}ms`);
      console.log(`\u{1F3BC}    Sequence: ${sequenceName}`);
      console.log(`\u{1F3BC}    Movement: ${movementName}`);
    }
    /**
     * Determine if hierarchical logging should be enabled
     * This can be configured based on environment or settings
     */
    shouldEnableHierarchicalLogging() {
      return true;
    }
    /**
     * Cleanup resources and event subscriptions
     */
    cleanup() {
      console.log("\u{1F3BC} ConductorCore: Cleaning up...");
      this.eventSubscriptions.forEach((unsubscribe) => {
        try {
          unsubscribe();
        } catch (error) {
          console.warn("\u{1F3BC} Error during event unsubscription:", error);
        }
      });
      this.eventSubscriptions = [];
      this.beatLoggingInitialized = false;
      console.log("\u2705 ConductorCore: Cleanup completed");
    }
    /**
     * Check if the core is properly initialized
     */
    isInitialized() {
      return this.beatLoggingInitialized && !!this.eventBus && !!this.spaValidator;
    }
  };
  ConductorCore.instance = null;

  // dist/modules/communication/sequences/core/SequenceRegistry.js
  init_SequenceTypes();
  var SequenceRegistry = class {
    constructor(eventBus2) {
      this.sequences = /* @__PURE__ */ new Map();
      this.eventSubscriptionManager = null;
      this.eventBus = eventBus2;
    }
    /**
     * Set the EventSubscriptionManager for SPA-compliant event emission
     * @param eventSubscriptionManager - The EventSubscriptionManager instance
     */
    setEventSubscriptionManager(eventSubscriptionManager) {
      this.eventSubscriptionManager = eventSubscriptionManager;
    }
    /**
     * Register a musical sequence
     * @param sequence - The sequence to register
     */
    register(sequence) {
      if (!sequence) {
        throw new Error("Sequence cannot be null or undefined");
      }
      if (!sequence.id) {
        throw new Error("Sequence must have an id");
      }
      if (!sequence.name) {
        throw new Error("Sequence must have a name");
      }
      this.validateSequence(sequence);
      this.sequences.set(sequence.id, sequence);
      console.log(`\u{1F3BC} SequenceRegistry: Registered sequence "${sequence.name}" (id: ${sequence.id})`);
      if (this.eventSubscriptionManager) {
        this.eventSubscriptionManager.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_REGISTERED, {
          sequenceId: sequence.id,
          sequenceName: sequence.name,
          category: sequence.category
        }, "SequenceRegistry");
      } else {
        console.warn("\u{1F3BC} SequenceRegistry: EventSubscriptionManager not set, using direct eventBus.emit()");
        this.eventBus.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_REGISTERED, {
          sequenceId: sequence.id,
          sequenceName: sequence.name,
          category: sequence.category
        });
      }
    }
    /**
     * Unregister a sequence by id
     * @param sequenceId - ID of the sequence to unregister
     */
    unregister(sequenceId) {
      if (!sequenceId) {
        throw new Error("Sequence ID is required");
      }
      const sequence = this.sequences.get(sequenceId);
      if (sequence) {
        this.sequences.delete(sequenceId);
        console.log(`\u{1F3BC} SequenceRegistry: Unregistered sequence "${sequence.name}" (id: ${sequenceId})`);
        if (this.eventSubscriptionManager) {
          this.eventSubscriptionManager.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_UNREGISTERED, {
            sequenceId,
            sequenceName: sequence.name
          }, "SequenceRegistry");
        } else {
          console.warn("\u{1F3BC} SequenceRegistry: EventSubscriptionManager not set, using direct eventBus.emit()");
          this.eventBus.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_UNREGISTERED, {
            sequenceId,
            sequenceName: sequence.name
          });
        }
      } else {
        console.warn(`\u{1F3BC} SequenceRegistry: Sequence with ID "${sequenceId}" not found for unregistration`);
      }
    }
    /**
     * Expose the underlying registry map for conductor integration
     * Note: Returned map is live; mutations occur through register/unregister
     */
    getSequenceMap() {
      return this.sequences;
    }
    /**
     * Get a sequence by id
     * @param sequenceId - ID of the sequence to retrieve
     * @returns The sequence or undefined if not found
     */
    get(sequenceId) {
      if (!sequenceId) {
        return void 0;
      }
      return this.sequences.get(sequenceId);
    }
    /**
     * Get all registered sequences
     * @returns Array of all registered sequences
     */
    getAll() {
      return Array.from(this.sequences.values());
    }
    /**
     * Get all sequence IDs
     * @returns Array of sequence IDs
     */
    getIds() {
      return Array.from(this.sequences.keys());
    }
    /**
     * Get all sequence names
     * @returns Array of sequence names
     */
    getNames() {
      return Array.from(this.sequences.values()).map((seq) => seq.name);
    }
    /**
     * Check if a sequence is registered
     * @param sequenceId - ID of the sequence to check
     * @returns True if the sequence is registered
     */
    has(sequenceId) {
      if (!sequenceId) {
        return false;
      }
      return this.sequences.has(sequenceId);
    }
    /**
     * Get the number of registered sequences
     * @returns Number of registered sequences
     */
    size() {
      return this.sequences.size;
    }
    /**
     * Clear all registered sequences
     */
    clear() {
      const sequences = this.getAll();
      this.sequences.clear();
      console.log(`\u{1F3BC} SequenceRegistry: Cleared ${sequences.length} sequences`);
      sequences.forEach((sequence) => {
        if (this.eventSubscriptionManager) {
          this.eventSubscriptionManager.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_UNREGISTERED, {
            sequenceId: sequence.id,
            sequenceName: sequence.name
          }, "SequenceRegistry");
        } else {
          console.warn("\u{1F3BC} SequenceRegistry: EventSubscriptionManager not set, using direct eventBus.emit()");
          this.eventBus.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_UNREGISTERED, {
            sequenceId: sequence.id,
            sequenceName: sequence.name
          });
        }
      });
    }
    /**
     * Get sequences by category
     * @param category - The category to filter by
     * @returns Array of sequences in the specified category
     */
    getByCategory(category) {
      if (!category) {
        return [];
      }
      return this.getAll().filter((sequence) => sequence.category === category);
    }
    /**
     * Find a sequence by name (for backward compatibility)
     * @param sequenceName - Name of the sequence to find
     * @returns The sequence or undefined if not found
     */
    findByName(sequenceName) {
      if (!sequenceName) {
        return void 0;
      }
      return this.getAll().find((sequence) => sequence.name === sequenceName);
    }
    /**
     * Validate sequence structure
     * @param sequence - The sequence to validate
     */
    validateSequence(sequence) {
      if (!sequence.movements || !Array.isArray(sequence.movements)) {
        throw new Error(`Sequence "${sequence.name}" (id: ${sequence.id}) must have a movements array`);
      }
      if (sequence.movements.length === 0) {
        throw new Error(`Sequence "${sequence.name}" (id: ${sequence.id}) must have at least one movement`);
      }
      sequence.movements.forEach((movement, index) => {
        if (!movement.id) {
          throw new Error(`Movement ${index} in sequence "${sequence.name}" (id: ${sequence.id}) must have an id`);
        }
        if (!movement.name) {
          throw new Error(`Movement ${index} in sequence "${sequence.name}" (id: ${sequence.id}) must have a name`);
        }
        if (!movement.beats || !Array.isArray(movement.beats)) {
          throw new Error(`Movement "${movement.name}" in sequence "${sequence.name}" must have a beats array`);
        }
        if (movement.beats.length === 0) {
          throw new Error(`Movement "${movement.name}" in sequence "${sequence.name}" must have at least one beat`);
        }
        movement.beats.forEach((beat, beatIndex) => {
          if (typeof beat.beat !== "number" || beat.beat < 1) {
            throw new Error(`Beat ${beatIndex} in movement "${movement.name}" must have a valid beat number (>= 1)`);
          }
          if (!beat.event || typeof beat.event !== "string") {
            throw new Error(`Beat ${beatIndex} in movement "${movement.name}" must have a valid event name`);
          }
          if (!beat.dynamics) {
            throw new Error(`Beat ${beatIndex} in movement "${movement.name}" must have dynamics specified`);
          }
        });
      });
      console.log(`\u2705 SequenceRegistry: Sequence "${sequence.name}" validation passed`);
    }
    /**
     * Get registry statistics
     * @returns Statistics about the registry
     */
    getStatistics() {
      const sequences = this.getAll();
      const sequencesByCategory = {};
      let totalMovements = 0;
      let totalBeats = 0;
      sequences.forEach((sequence) => {
        const category = sequence.category || "uncategorized";
        sequencesByCategory[category] = (sequencesByCategory[category] || 0) + 1;
        totalMovements += sequence.movements.length;
        sequence.movements.forEach((movement) => {
          totalBeats += movement.beats.length;
        });
      });
      return {
        totalSequences: sequences.length,
        sequencesByCategory,
        totalMovements,
        totalBeats
      };
    }
  };

  // dist/modules/communication/sequences/core/EventSubscriptionManager.js
  var EventSubscriptionManager = class {
    constructor(eventBus2, spaValidator) {
      this.eventBus = eventBus2;
      this.spaValidator = spaValidator;
    }
    /**
     * Subscribe to events through the conductor (SPA-compliant)
     * This method ensures all event subscriptions go through the conductor
     * and prevents direct eventBus access violations
     * @param eventName - The event name to subscribe to
     * @param callback - The callback function to execute
     * @param context - Optional context for the subscription
     * @returns Unsubscribe function
     */
    subscribe(eventName, callback, context) {
      const stack = new Error().stack || "";
      const callerInfo = this.spaValidator.analyzeCallStack(stack);
      if (!this.isAuthorizedSubscriber(callerInfo)) {
        const violation = this.spaValidator.createViolation("UNAUTHORIZED_CONDUCTOR_SUBSCRIBE", callerInfo.pluginId || "unknown", `Unauthorized conductor.subscribe() call from ${callerInfo.source}`, stack, "error");
        this.spaValidator.handleViolation(violation);
        if (this.spaValidator.config.strictMode) {
          throw new Error(`Unauthorized conductor.subscribe() call from ${callerInfo.source}`);
        }
      }
      return this.eventBus.subscribe(eventName, callback, {
        ...context,
        conductorManaged: true,
        subscribedVia: "conductor"
      });
    }
    /**
     * Unsubscribe from events through the conductor (SPA-compliant)
     * @param eventName - The event name to unsubscribe from
     * @param callback - The callback function to remove
     */
    unsubscribe(eventName, callback) {
      const stack = new Error().stack || "";
      const callerInfo = this.spaValidator.analyzeCallStack(stack);
      if (!this.isAuthorizedSubscriber(callerInfo)) {
        const violation = this.spaValidator.createViolation("UNAUTHORIZED_CONDUCTOR_UNSUBSCRIBE", callerInfo.pluginId || "unknown", `Unauthorized conductor.unsubscribe() call from ${callerInfo.source}`, stack, "error");
        this.spaValidator.handleViolation(violation);
        if (this.spaValidator.config.strictMode) {
          throw new Error(`Unauthorized conductor.unsubscribe() call from ${callerInfo.source}`);
        }
      }
      this.eventBus.unsubscribe(eventName, callback);
    }
    /**
     * Check if the caller is authorized to subscribe/unsubscribe
     * @param callerInfo - Information about the caller from stack analysis
     * @returns True if authorized
     */
    isAuthorizedSubscriber(callerInfo) {
      if (callerInfo.isReactComponent) {
        return true;
      }
      if (callerInfo.isPlugin && callerInfo.isInMountMethod) {
        return true;
      }
      if (callerInfo.source === "MusicalConductor") {
        return true;
      }
      if (callerInfo.source?.includes("ConductorCore") || callerInfo.source?.includes("SequenceExecutor") || callerInfo.source?.includes("PluginManager")) {
        return true;
      }
      return false;
    }
    /**
     * Create a managed subscription that tracks the subscriber
     * @param eventName - The event name to subscribe to
     * @param callback - The callback function
     * @param subscriberId - Identifier for the subscriber
     * @param context - Optional context
     * @returns Unsubscribe function
     */
    createManagedSubscription(eventName, callback, subscriberId, context) {
      console.log(`\u{1F3BC} EventSubscriptionManager: Creating managed subscription for ${subscriberId} -> ${eventName}`);
      const enhancedCallback = (data) => {
        try {
          callback(data);
        } catch (error) {
          console.error(`\u{1F3BC} EventSubscriptionManager: Error in subscription callback for ${eventName}:`, error);
          console.error(`\u{1F3BC} Subscriber: ${subscriberId}`);
        }
      };
      return this.eventBus.subscribe(eventName, enhancedCallback, {
        ...context,
        subscriberId,
        managedByEventSubscriptionManager: true
      });
    }
    /**
     * Emit an event through the subscription manager
     * This provides a controlled way to emit events with validation
     * @param eventName - The event name to emit
     * @param data - The data to emit
     * @param emitterId - Identifier for the emitter
     */
    emit(eventName, data, emitterId) {
      if (emitterId) {
        console.log(`\u{1F3BC} EventSubscriptionManager: ${emitterId} emitting ${eventName}`);
      }
      this.eventBus.emit(eventName, data);
    }
    /**
     * Get subscription statistics
     * @returns Statistics about current subscriptions
     */
    getSubscriptionStatistics() {
      const debugInfo = this.eventBus.getDebugInfo();
      return {
        totalSubscriptions: debugInfo.totalSubscriptions,
        subscriptionCounts: debugInfo.subscriptionCounts
      };
    }
    /**
     * Validate that an event subscription is properly authorized
     * @param eventName - The event name being subscribed to
     * @param callerInfo - Information about the caller
     * @returns Validation result
     */
    validateSubscription(eventName, callerInfo) {
      if (callerInfo.isDirectEventBusAccess) {
        return {
          isValid: false,
          reason: "Direct EventBus access detected",
          recommendation: "Use conductor.subscribe() instead of eventBus.subscribe()"
        };
      }
      if (callerInfo.isPlugin && !callerInfo.isInMountMethod) {
        return {
          isValid: false,
          reason: "Plugin subscribing outside of mount method",
          recommendation: "Move event subscriptions to the plugin's mount method"
        };
      }
      if (callerInfo.isReactComponent && callerInfo.isDirectEventBusAccess) {
        return {
          isValid: false,
          reason: "React component using direct EventBus access",
          recommendation: "Use conductor.subscribe() in React components"
        };
      }
      return { isValid: true };
    }
  };

  // dist/modules/communication/sequences/execution/ExecutionQueue.js
  init_SequenceTypes();
  var ExecutionQueue = class {
    constructor() {
      this.queue = [];
      this.priorities = /* @__PURE__ */ new Map();
      this.completedCount = 0;
      this.currentlyExecuting = null;
    }
    /**
     * Add a sequence request to the queue
     * @param request - The sequence request to enqueue
     */
    enqueue(request) {
      if (!request) {
        throw new Error("Request cannot be null or undefined");
      }
      if (request.priority) {
        this.priorities.set(request.requestId, request.priority);
      }
      this.insertByPriority(request);
      console.log(`\u{1F3BC} ExecutionQueue: Enqueued "${request.sequenceName}" with priority ${request.priority || "NORMAL"} (Queue size: ${this.queue.length})`);
    }
    /**
     * Remove and return the next sequence request from the queue
     * @returns The next sequence request or null if queue is empty
     */
    dequeue() {
      if (this.queue.length === 0) {
        return null;
      }
      const request = this.queue.shift();
      console.log(`\u{1F3BC} ExecutionQueue: Dequeued "${request.sequenceName}"`);
      return request;
    }
    /**
     * Peek at the next sequence request without removing it
     * @returns The next sequence request or null if queue is empty
     */
    peek() {
      return this.queue.length > 0 ? this.queue[0] : null;
    }
    /**
     * Clear all requests from the queue
     * @returns Number of requests that were cleared
     */
    clear() {
      const clearedCount = this.queue.length;
      this.queue = [];
      this.priorities.clear();
      console.log(`\u{1F3BC} ExecutionQueue: Cleared ${clearedCount} requests from queue`);
      return clearedCount;
    }
    /**
     * Get the current queue status
     * @returns Queue status information
     */
    getStatus() {
      return {
        pending: this.queue.length,
        executing: this.currentlyExecuting ? 1 : 0,
        completed: this.completedCount,
        length: this.queue.length,
        activeSequence: this.currentlyExecuting?.sequenceName || null
      };
    }
    /**
     * Check if the queue is empty
     * @returns True if the queue is empty
     */
    isEmpty() {
      return this.queue.length === 0;
    }
    /**
     * Get the current queue size
     * @returns Number of requests in the queue
     */
    size() {
      return this.queue.length;
    }
    /**
     * Set the currently executing request
     * @param request - The request that is now executing
     */
    setCurrentlyExecuting(request) {
      this.currentlyExecuting = request;
      if (request) {
        console.log(`\u{1F3BC} ExecutionQueue: Now executing "${request.sequenceName}"`);
      } else {
        console.log(`\u{1F3BC} ExecutionQueue: No sequence currently executing`);
      }
    }
    /**
     * Mark a sequence as completed
     * @param request - The completed request
     */
    markCompleted(request) {
      this.completedCount++;
      if (this.currentlyExecuting?.requestId === request.requestId) {
        this.currentlyExecuting = null;
      }
      console.log(`\u{1F3BC} ExecutionQueue: Marked "${request.sequenceName}" as completed (Total completed: ${this.completedCount})`);
    }
    /**
     * Get all queued sequence requests
     * @returns Array of queued requests
     */
    getQueuedRequests() {
      return [...this.queue];
    }
    /**
     * Get the currently executing request
     * @returns The currently executing request or null
     */
    getCurrentlyExecuting() {
      return this.currentlyExecuting;
    }
    /**
     * Set priority for a specific event type
     * @param eventType - The event type
     * @param priority - The priority level
     */
    setPriority(eventType, priority) {
      this.priorities.set(eventType, priority);
      console.log(`\u{1F3BC} ExecutionQueue: Set priority for "${eventType}" to ${priority}`);
    }
    /**
     * Get priority for a specific event type
     * @param eventType - The event type
     * @returns The priority level or NORMAL if not set
     */
    getPriority(eventType) {
      return this.priorities.get(eventType) || SEQUENCE_PRIORITIES.NORMAL;
    }
    /**
     * Insert a request into the queue based on priority
     * @param request - The request to insert
     */
    insertByPriority(request) {
      const priority = request.priority || SEQUENCE_PRIORITIES.NORMAL;
      if (priority === SEQUENCE_PRIORITIES.HIGH) {
        this.queue.unshift(request);
        return;
      }
      if (priority === SEQUENCE_PRIORITIES.CHAINED) {
        let insertIndex = 0;
        while (insertIndex < this.queue.length && this.queue[insertIndex].priority === SEQUENCE_PRIORITIES.HIGH) {
          insertIndex++;
        }
        this.queue.splice(insertIndex, 0, request);
        return;
      }
      this.queue.push(request);
    }
    /**
     * Get queue statistics
     * @returns Statistics about the queue
     */
    getStatistics() {
      const priorityDistribution = {};
      this.queue.forEach((request) => {
        const priority = request.priority || SEQUENCE_PRIORITIES.NORMAL;
        priorityDistribution[priority] = (priorityDistribution[priority] || 0) + 1;
      });
      return {
        totalEnqueued: this.completedCount + this.queue.length + (this.currentlyExecuting ? 1 : 0),
        totalCompleted: this.completedCount,
        currentQueueLength: this.queue.length,
        priorityDistribution
      };
    }
    /**
     * Find requests by sequence name
     * @param sequenceName - The sequence name to search for
     * @returns Array of matching requests
     */
    findBySequenceName(sequenceName) {
      return this.queue.filter((request) => request.sequenceName === sequenceName);
    }
    /**
     * Remove requests by sequence name
     * @param sequenceName - The sequence name to remove
     * @returns Number of requests removed
     */
    removeBySequenceName(sequenceName) {
      const initialLength = this.queue.length;
      this.queue = this.queue.filter((request) => request.sequenceName !== sequenceName);
      const removedCount = initialLength - this.queue.length;
      if (removedCount > 0) {
        console.log(`\u{1F3BC} ExecutionQueue: Removed ${removedCount} requests for sequence "${sequenceName}"`);
      }
      return removedCount;
    }
  };

  // dist/modules/communication/sequences/execution/SequenceExecutor.js
  init_SequenceTypes();

  // dist/modules/communication/sequences/execution/MovementExecutor.js
  init_SequenceTypes();

  // dist/modules/communication/sequences/execution/BeatExecutor.js
  init_SequenceTypes();
  init_DataBaton();
  var BeatExecutor = class {
    constructor(eventBus2, spaValidator, statisticsManager) {
      this.isExecutingBeat = false;
      this.beatExecutionQueue = [];
      this.eventBus = eventBus2;
      this.spaValidator = spaValidator;
    }
    /**
     * Execute a single beat
     * @param beat - The beat to execute
     * @param executionContext - The sequence execution context
     * @param sequence - The parent sequence
     * @param movement - The parent movement
     */
    async executeBeat(beat, executionContext, sequence, movement) {
      if (this.isExecutingBeat) {
        return new Promise((resolve, reject) => {
          this.beatExecutionQueue.push({
            beat,
            context: executionContext,
            resolve,
            reject
          });
        });
      }
      this.isExecutingBeat = true;
      try {
        const startTime = Date.now();
        this.eventBus.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.BEAT_STARTED, {
          sequenceName: sequence.name,
          movementName: movement.name,
          beat: beat.beat,
          event: beat.event,
          title: beat.title,
          dynamics: beat.dynamics,
          timing: beat.timing,
          requestId: executionContext.id,
          payload: executionContext.data
        });
        const contextualEventData = this.createContextualEventData(beat, executionContext, sequence, movement);
        const prevSnap = DataBaton.snapshot(executionContext.payload);
        contextualEventData._baton = executionContext.payload;
        await this.eventBus.emitAsync(beat.event, contextualEventData);
        const nextSnap = DataBaton.snapshot(executionContext.payload);
        DataBaton.log({
          sequenceName: sequence.name,
          movementName: movement.name,
          beatEvent: beat.event,
          beatNumber: beat.beat,
          requestId: executionContext.id
        }, prevSnap, nextSnap);
        const executionTime = Date.now() - startTime;
        this.statisticsManager?.recordBeatExecution();
        this.eventBus.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.BEAT_COMPLETED, {
          sequenceName: sequence.name,
          movementName: movement.name,
          beat: beat.beat,
          event: beat.event,
          executionTime,
          requestId: executionContext.id
        });
        const depth = this.eventBus.__conductorLogger?.getDepth?.(executionContext.id) ?? 0;
        const indent = "  ".repeat(Math.max(0, depth));
        console.log(`${indent}\u2705 BeatExecutor: Beat ${beat.beat} (${beat.event}) completed in ${executionTime}ms`);
      } catch (error) {
        console.error(`\u274C BeatExecutor: Beat ${beat.beat} (${beat.event}) failed:`, error);
        executionContext.errors.push({
          beat: beat.beat,
          error: error instanceof Error ? error.message : String(error),
          timestamp: Date.now()
        });
        this.eventBus.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.BEAT_FAILED, {
          sequenceName: sequence.name,
          movementName: movement.name,
          beat: beat.beat,
          event: beat.event,
          error: error instanceof Error ? error.message : String(error),
          requestId: executionContext.id
        });
        if (beat.errorHandling === "abort-sequence" || beat.errorHandling === "abort") {
          throw error;
        } else if (beat.errorHandling === "continue") {
          console.log(`\u26A0\uFE0F BeatExecutor: Continuing execution despite beat error (errorHandling: continue)`);
        }
      } finally {
        this.isExecutingBeat = false;
        if (this.beatExecutionQueue.length > 0) {
          const nextBeat = this.beatExecutionQueue.shift();
          setImmediate(() => {
            this.executeBeat(nextBeat.beat, nextBeat.context, sequence, movement).then(nextBeat.resolve).catch(nextBeat.reject);
          });
        }
      }
    }
    /**
     * Create contextual event data for beat execution
     * @param beat - The beat being executed
     * @param executionContext - The sequence execution context
     * @param sequence - The parent sequence
     * @param movement - The parent movement
     * @returns Contextual event data
     */
    createContextualEventData(beat, executionContext, sequence, movement) {
      const contextualData = {
        ...executionContext.data,
        ...beat.data
      };
      const musicalContext = {
        sequence: {
          name: sequence.name,
          tempo: sequence.tempo,
          key: sequence.key,
          timeSignature: sequence.timeSignature
        },
        movement: {
          name: movement.name,
          description: movement.description
        },
        beat: {
          number: beat.beat,
          event: beat.event,
          title: beat.title,
          description: beat.description,
          dynamics: beat.dynamics,
          timing: beat.timing
        },
        execution: {
          requestId: executionContext.id,
          priority: executionContext.priority,
          currentMovement: executionContext.currentMovement,
          currentBeat: executionContext.currentBeat,
          completedBeats: executionContext.completedBeats.length,
          totalBeats: this.calculateTotalBeats(executionContext.sequence)
        }
      };
      return {
        ...contextualData,
        _musicalContext: musicalContext,
        _timestamp: Date.now(),
        _eventBus: this.eventBus
      };
    }
    /**
     * Validate beat structure
     * @param beat - The beat to validate
     * @returns True if valid
     */
    validateBeat(beat) {
      try {
        if (typeof beat.beat !== "number" || beat.beat < 1) {
          throw new Error("Beat must have a valid beat number (>= 1)");
        }
        if (!beat.event || typeof beat.event !== "string") {
          throw new Error("Beat must have a valid event name");
        }
        if (!beat.title || typeof beat.title !== "string") {
          throw new Error("Beat must have a valid title");
        }
        if (!beat.dynamics || !Object.values(MUSICAL_DYNAMICS).includes(beat.dynamics)) {
          throw new Error("Beat must have valid dynamics");
        }
        if (!beat.timing || !Object.values(MUSICAL_TIMING).includes(beat.timing)) {
          throw new Error("Beat must have valid timing");
        }
        if (!beat.errorHandling || !["continue", "abort-sequence", "retry", "abort"].includes(beat.errorHandling)) {
          throw new Error("Beat must have valid error handling strategy");
        }
        return true;
      } catch (error) {
        console.error(`\u274C BeatExecutor: Beat validation failed for beat ${beat.beat}:`, error);
        return false;
      }
    }
    /**
     * Get beat execution statistics
     * @param beat - The beat to analyze
     * @returns Beat statistics
     */
    getBeatStatistics(beat) {
      return {
        beatNumber: beat.beat,
        event: beat.event,
        dynamics: beat.dynamics || "unknown",
        timing: beat.timing || "unknown",
        errorHandling: beat.errorHandling || "continue",
        hasData: !!beat.data && Object.keys(beat.data).length > 0,
        dataKeys: beat.data ? Object.keys(beat.data) : []
      };
    }
    /**
     * Estimate beat execution time based on dynamics and timing
     * @param beat - The beat to analyze
     * @param baseTempo - Base tempo in BPM
     * @returns Estimated execution time in milliseconds
     */
    estimateBeatExecutionTime(beat, baseTempo = 120) {
      const baseDuration = 60 / baseTempo * 1e3;
      let dynamicsMultiplier = 1;
      switch (beat.dynamics) {
        case MUSICAL_DYNAMICS.PIANISSIMO:
          dynamicsMultiplier = 0.8;
          break;
        case MUSICAL_DYNAMICS.PIANO:
          dynamicsMultiplier = 0.9;
          break;
        case MUSICAL_DYNAMICS.MEZZO_PIANO:
          dynamicsMultiplier = 0.95;
          break;
        case MUSICAL_DYNAMICS.MEZZO_FORTE:
          dynamicsMultiplier = 1.05;
          break;
        case MUSICAL_DYNAMICS.FORTE:
          dynamicsMultiplier = 1.1;
          break;
        case MUSICAL_DYNAMICS.FORTISSIMO:
          dynamicsMultiplier = 1.2;
          break;
        default:
          dynamicsMultiplier = 1;
      }
      let timingMultiplier = 1;
      switch (beat.timing) {
        case MUSICAL_TIMING.IMMEDIATE:
          timingMultiplier = 0;
          break;
        case MUSICAL_TIMING.AFTER_BEAT:
          timingMultiplier = 1;
          break;
        case MUSICAL_TIMING.SYNCHRONIZED:
          timingMultiplier = 0.5;
          break;
        case MUSICAL_TIMING.DELAYED:
          timingMultiplier = 1.5;
          break;
        default:
          timingMultiplier = 1;
      }
      return Math.round(baseDuration * dynamicsMultiplier * timingMultiplier);
    }
    /**
     * Clear the beat execution queue
     */
    clearBeatQueue() {
      this.beatExecutionQueue = [];
      console.log("\u{1F9F9} BeatExecutor: Beat execution queue cleared");
    }
    /**
     * Get current beat execution status
     * @returns Execution status information
     */
    getExecutionStatus() {
      return {
        isExecuting: this.isExecutingBeat,
        queueLength: this.beatExecutionQueue.length
      };
    }
    /**
     * Calculate total beats in a sequence
     * @param sequence - The sequence to analyze
     * @returns Total number of beats
     */
    calculateTotalBeats(sequence) {
      return sequence.movements.reduce((total, movement) => total + movement.beats.length, 0);
    }
  };

  // dist/modules/communication/sequences/execution/MovementExecutor.js
  init_ConductorEnv();
  var MovementExecutor = class {
    constructor(eventBus2, spaValidator, statisticsManager, performanceTracker) {
      this.eventBus = eventBus2;
      this.spaValidator = spaValidator;
      this.performanceTracker = performanceTracker;
      this.beatExecutor = new BeatExecutor(eventBus2, spaValidator, statisticsManager);
    }
    /**
     * Execute a movement within a sequence
     * @param movement - The movement to execute
     * @param executionContext - The sequence execution context
     * @param sequence - The parent sequence
     */
    async executeMovement(movement, executionContext, sequence) {
      console.log(`\u{1F3B5} MovementExecutor: Starting movement "${movement.name}" with ${movement.beats.length} beats`);
      if (this.performanceTracker) {
        this.performanceTracker.startMovementTiming(sequence.name, movement.name, executionContext.id);
      }
      this.eventBus.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.MOVEMENT_STARTED, {
        sequenceName: sequence.name,
        movementName: movement.name,
        requestId: executionContext.id,
        beatsCount: movement.beats.length
      });
      try {
        for (let beatIndex = 0; beatIndex < movement.beats.length; beatIndex++) {
          const beat = movement.beats[beatIndex];
          executionContext.currentBeat = beat.beat;
          console.log(`\u{1F941} MovementExecutor: Executing beat ${beat.beat} (${beatIndex + 1}/${movement.beats.length})`);
          await this.handleBeatTiming(beat, sequence);
          await this.beatExecutor.executeBeat(beat, executionContext, sequence, movement);
          executionContext.completedBeats.push(beat.beat);
        }
        let movementDuration = null;
        if (this.performanceTracker) {
          movementDuration = this.performanceTracker.endMovementTiming(sequence.name, movement.name, executionContext.id, movement.beats.length);
        }
        this.eventBus.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.MOVEMENT_COMPLETED, {
          sequenceName: sequence.name,
          movementName: movement.name,
          requestId: executionContext.id,
          beatsExecuted: movement.beats.length,
          duration: movementDuration
        });
        console.log(`\u2705 MovementExecutor: Movement "${movement.name}" completed successfully`);
      } catch (error) {
        if (this.performanceTracker) {
          this.performanceTracker.cleanupFailedMovement(sequence.name, movement.name, executionContext.id);
        }
        console.error(`\u274C MovementExecutor: Movement "${movement.name}" failed:`, error);
        executionContext.errors.push({
          beat: executionContext.currentBeat,
          error: error instanceof Error ? error.message : String(error),
          timestamp: Date.now()
        });
        this.eventBus.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.MOVEMENT_FAILED, {
          sequenceName: sequence.name,
          movementName: movement.name,
          requestId: executionContext.id,
          error: error instanceof Error ? error.message : String(error)
        });
        throw error;
      }
    }
    /**
     * Handle timing between beats based on sequence tempo and beat timing
     * @param beat - The current beat
     * @param sequence - The parent sequence
     */
    async handleBeatTiming(beat, sequence) {
      if (beat.timing === MUSICAL_TIMING.IMMEDIATE) {
        return;
      }
      const effectiveTempo = typeof beat?.tempo === "number" && beat.tempo > 0 ? beat.tempo : (typeof sequence.movements?.[sequence.movements.indexOf]?.tempo === "number" ? sequence.movements?.[0]?.tempo : sequence.tempo) || 120;
      const beatDuration = 60 / effectiveTempo * 1e3;
      let delay = 0;
      switch (beat.timing) {
        case MUSICAL_TIMING.AFTER_BEAT:
        case MUSICAL_TIMING.ON_BEAT:
          delay = beatDuration;
          break;
        case MUSICAL_TIMING.DELAYED:
          delay = beatDuration * 1.5;
          break;
        case MUSICAL_TIMING.SYNCHRONIZED:
          delay = beatDuration / 2;
          break;
        case MUSICAL_TIMING.IMMEDIATE:
        default:
          delay = 0;
      }
      try {
        const ce = getConductorEnv?.();
        const maxDelay = ce?.flags?.timing?.maxDelayMs;
        if (typeof maxDelay === "number" && maxDelay >= 0) {
          delay = Math.min(delay, maxDelay);
        }
        const scale = ce?.flags?.timing?.scale;
        if (typeof scale === "number" && isFinite(scale) && scale > 0) {
          delay = Math.round(delay * scale);
        }
      } catch {
      }
      if (delay > 0) {
        console.log(`\u23F1\uFE0F MovementExecutor: Waiting ${delay}ms for beat timing (${beat.timing})`);
        await this.sleep(delay);
      }
    }
    /**
     * Sleep for a specified duration
     * @param ms - Milliseconds to sleep
     */
    sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    /**
     * Validate movement structure
     * @param movement - The movement to validate
     * @returns True if valid
     */
    validateMovement(movement) {
      try {
        if (!movement.name || typeof movement.name !== "string") {
          throw new Error("Movement must have a valid name");
        }
        if (!movement.beats || !Array.isArray(movement.beats)) {
          throw new Error("Movement must have a beats array");
        }
        if (movement.beats.length === 0) {
          throw new Error("Movement must have at least one beat");
        }
        movement.beats.forEach((beat, index) => {
          if (typeof beat.beat !== "number" || beat.beat < 1) {
            throw new Error(`Beat ${index} must have a valid beat number (>= 1)`);
          }
          if (!beat.event || typeof beat.event !== "string") {
            throw new Error(`Beat ${index} must have a valid event name`);
          }
          if (!beat.dynamics) {
            throw new Error(`Beat ${index} must have dynamics specified`);
          }
          if (!beat.timing) {
            throw new Error(`Beat ${index} must have timing specified`);
          }
        });
        return true;
      } catch (error) {
        console.error(`\u274C MovementExecutor: Movement validation failed for "${movement.name}":`, error);
        return false;
      }
    }
    /**
     * Get movement execution statistics
     * @param movement - The movement to analyze
     * @returns Movement statistics
     */
    getMovementStatistics(movement) {
      const beatTypes = {};
      const timingDistribution = {};
      const dynamicsDistribution = {};
      movement.beats.forEach((beat) => {
        beatTypes[beat.event] = (beatTypes[beat.event] || 0) + 1;
        const timing = beat.timing || "unknown";
        timingDistribution[timing] = (timingDistribution[timing] || 0) + 1;
        const dynamics = beat.dynamics || "unknown";
        dynamicsDistribution[dynamics] = (dynamicsDistribution[dynamics] || 0) + 1;
      });
      return {
        name: movement.name,
        totalBeats: movement.beats.length,
        beatTypes,
        timingDistribution,
        dynamicsDistribution
      };
    }
    /**
     * Estimate movement execution time
     * @param movement - The movement to analyze
     * @param tempo - The sequence tempo (BPM)
     * @returns Estimated execution time in milliseconds
     */
    estimateExecutionTime(movement, tempo = 120) {
      const beatDuration = 60 / tempo * 1e3;
      let totalTime = 0;
      movement.beats.forEach((beat) => {
        switch (beat.timing) {
          case MUSICAL_TIMING.IMMEDIATE:
            totalTime += 0;
            break;
          case MUSICAL_TIMING.AFTER_BEAT:
            totalTime += beatDuration;
            break;
          case MUSICAL_TIMING.SYNCHRONIZED:
            totalTime += beatDuration / 2;
            break;
          case MUSICAL_TIMING.DELAYED:
            totalTime += beatDuration * 1.5;
            break;
          default:
            totalTime += beatDuration;
        }
      });
      return Math.round(totalTime);
    }
  };

  // dist/modules/communication/sequences/execution/SequenceExecutor.js
  var SequenceExecutor = class {
    constructor(eventBus2, spaValidator, executionQueue, statisticsManager, performanceTracker) {
      this.activeSequence = null;
      this.sequenceHistory = [];
      this.isExecutingBeat = false;
      this.beatExecutionQueue = [];
      this.eventBus = eventBus2;
      this.spaValidator = spaValidator;
      this.executionQueue = executionQueue;
      this.statisticsManager = statisticsManager;
      this.performanceTracker = performanceTracker;
      this.movementExecutor = new MovementExecutor(eventBus2, spaValidator, statisticsManager, performanceTracker);
    }
    /**
     * Execute a sequence with proper orchestration
     * @param sequenceRequest - The sequence request to execute
     * @param sequence - The musical sequence to execute
     * @returns Promise that resolves when sequence completes
     */
    async executeSequence(sequenceRequest, sequence) {
      const startTime = Date.now();
      const executionId = sequenceRequest.requestId;
      const executionContext = {
        id: executionId,
        sequenceId: sequence.id,
        sequenceName: sequence.name,
        sequence,
        data: sequenceRequest.data || {},
        payload: {},
        startTime,
        currentMovement: 0,
        currentBeat: 0,
        completedBeats: [],
        errors: [],
        priority: sequenceRequest.priority || SEQUENCE_PRIORITIES.NORMAL,
        executionType: "IMMEDIATE"
      };
      this.activeSequence = executionContext;
      this.executionQueue.setCurrentlyExecuting(sequenceRequest);
      try {
        this.eventBus.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_STARTED, {
          sequenceName: sequence.name,
          requestId: executionId,
          priority: sequenceRequest.priority,
          data: sequenceRequest.data
        });
        for (let i = 0; i < sequence.movements.length; i++) {
          const movement = sequence.movements[i];
          executionContext.currentMovement = i;
          executionContext.currentBeat = 0;
          console.log(`\u{1F3BC} SequenceExecutor: Executing movement "${movement.name}" (${i + 1}/${sequence.movements.length})`);
          await this.movementExecutor.executeMovement(movement, executionContext, sequence);
        }
        const executionTime = Date.now() - startTime;
        this.eventBus.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_COMPLETED, {
          sequenceName: sequence.name,
          requestId: executionId,
          executionTime,
          beatsExecuted: executionContext.completedBeats.length,
          errors: executionContext.errors.length
        });
        this.sequenceHistory.push(executionContext);
        this.activeSequence = null;
        this.executionQueue.markCompleted(sequenceRequest);
        console.log(`\u2705 SequenceExecutor: Sequence "${sequence.name}" completed in ${executionTime}ms`);
        return executionId;
      } catch (error) {
        const executionTime = Date.now() - startTime;
        executionContext.errors.push({
          beat: executionContext.currentBeat,
          error: error instanceof Error ? error.message : String(error),
          timestamp: Date.now()
        });
        this.eventBus.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_FAILED, {
          sequenceName: sequence.name,
          requestId: executionId,
          error: error instanceof Error ? error.message : String(error),
          executionTime
        });
        this.sequenceHistory.push(executionContext);
        this.activeSequence = null;
        this.executionQueue.markCompleted(sequenceRequest);
        console.error(`\u274C SequenceExecutor: Sequence "${sequence.name}" failed:`, error);
        throw error;
      }
    }
    /**
     * Check if a sequence is currently executing
     * @param sequenceName - Optional sequence name to check
     * @returns True if executing
     */
    isSequenceRunning(sequenceName) {
      if (!this.activeSequence) {
        return false;
      }
      if (sequenceName) {
        return this.activeSequence.sequenceName === sequenceName;
      }
      return true;
    }
    /**
     * Get the currently executing sequence
     * @returns Current sequence context or null
     */
    getCurrentSequence() {
      return this.activeSequence;
    }
    /**
     * Stop the current sequence execution
     */
    stopExecution() {
      if (this.activeSequence) {
        console.log(`\u{1F6D1} SequenceExecutor: Stopping execution of "${this.activeSequence.sequenceName}"`);
        this.activeSequence.errors.push({
          beat: this.activeSequence.currentBeat,
          error: "Sequence execution cancelled",
          timestamp: Date.now()
        });
        this.eventBus.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_CANCELLED, {
          sequenceName: this.activeSequence.sequenceName,
          requestId: this.activeSequence.id
        });
        this.sequenceHistory.push(this.activeSequence);
        this.activeSequence = null;
      }
    }
    /**
     * Get execution history
     * @returns Array of completed sequence executions
     */
    getExecutionHistory() {
      return [...this.sequenceHistory];
    }
    /**
     * Clear execution history
     */
    clearExecutionHistory() {
      this.sequenceHistory = [];
      console.log("\u{1F9F9} SequenceExecutor: Execution history cleared");
    }
    /**
     * Calculate total beats in a sequence
     * @param sequence - The sequence to analyze
     * @returns Total number of beats
     */
    calculateTotalBeats(sequence) {
      return sequence.movements.reduce((total, movement) => total + movement.beats.length, 0);
    }
    /**
     * Update execution statistics
     * @param context - The completed execution context
     * @param executionTime - The execution time in milliseconds
     */
    // Note: Statistics are now managed centrally in StatisticsManager
    /**
     * Get execution statistics
     * @returns Current execution statistics
     */
    getStatistics() {
      const stats = this.statisticsManager.getStatistics();
      return {
        totalSequencesExecuted: stats.totalSequencesExecuted,
        totalBeatsExecuted: stats.totalBeatsExecuted,
        averageExecutionTime: stats.averageExecutionTime,
        sequenceCompletionRate: stats.sequenceCompletionRate,
        currentlyExecuting: !!this.activeSequence,
        executionHistorySize: this.sequenceHistory.length
      };
    }
  };

  // dist/modules/communication/sequences/plugins/PluginManager.js
  init_DataBaton();

  // dist/modules/communication/sequences/plugins/PluginLoader.js
  init_ConductorEnv();
  var PluginLoader = class {
    constructor() {
      this.moduleCache = /* @__PURE__ */ new Map();
    }
    /**
     * Load a plugin module with caching and fallback strategies
     * @param pluginPath - Path to the plugin module (e.g., "/plugins/App.app-shell-symphony/index.js")
     * @returns Plugin module with exports
     */
    async loadPluginModule(pluginPath) {
      if (this.moduleCache.has(pluginPath)) {
        console.log(`\u{1F4E6} Loading plugin from cache: ${pluginPath}`);
        return this.moduleCache.get(pluginPath);
      }
      try {
        const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
        if (!isBrowser && pluginPath.startsWith("/plugins/")) {
          const path = await import("node:path");
          const { pathToFileURL } = await import("node:url");
          const localPath = path.resolve(process.cwd(), pluginPath.replace(/^\/?plugins\//, "RenderX/public/plugins/"));
          const fileUrl = pathToFileURL(localPath).href;
          console.log(`\u{1F504} [node] Importing plugin via file URL: ${fileUrl}`);
          let module = null;
          try {
            module = await import(fileUrl);
            if (module && module.default && !module.sequence && !module.handlers) {
              const def = module.default;
              if (def && (def.sequence || def.handlers))
                module = def;
            }
          } catch (importErr) {
            console.warn(`\u26A0\uFE0F file:// import failed for ${fileUrl}. Trying transform fallback.`, importErr);
          }
          if (!module?.sequence && !module?.handlers) {
            try {
              const fs = await import("node:fs");
              const src = fs.readFileSync(localPath, "utf-8");
              const transformed = src.replace(/^\s*import\s+[^;]+;?/gm, "").replace(/export const (\w+)\s*=\s*/g, "moduleExports.$1 = ").replace(/export\s+async\s+function\s+(\w+)\s*\(/g, "moduleExports.$1 = async function $1(").replace(/export\s+function\s+(\w+)\s*\(/g, "moduleExports.$1 = function $1(").replace(/export default\s+/g, "moduleExports.default = ");
              const moduleExports = {};
              const evaluator = new Function("moduleExports", "fetch", transformed);
              evaluator(moduleExports, globalThis.fetch);
              module = moduleExports;
            } catch (fallbackErr) {
              console.warn("\u26A0\uFE0F PluginLoader fallback transform failed:", fallbackErr);
            }
          }
          if (!module) {
            throw new Error(`Failed to load plugin module at ${fileUrl}`);
          }
          this.moduleCache.set(pluginPath, module);
          return module;
        }
      } catch (nodeImportErr) {
        console.warn("\u26A0\uFE0F Node/Jest import path mapping failed, falling back to web import:", nodeImportErr);
      }
      const pluginDir = pluginPath.substring(0, pluginPath.lastIndexOf("/"));
      const bundledPath = `${pluginDir}/dist/plugin.js`;
      const isDev = isDevEnv();
      if (isDev) {
        try {
          console.log(`\u{1F504} Attempting to load plugin: ${pluginPath}`);
          const module = await import(pluginPath);
          this.moduleCache.set(pluginPath, module);
          console.log(`\u2705 Successfully loaded plugin: ${pluginPath}`);
          return module;
        } catch (originalError) {
          console.log(`\u26A0\uFE0F Dev load failed (${pluginPath}), trying bundled path as fallback`);
        }
        try {
          console.log(`\u{1F504} Attempting to load bundled plugin: ${bundledPath}`);
          let module = await import(bundledPath);
          if (module && module.default && !module.sequence && !module.handlers) {
            const def = module.default;
            if (def && (def.sequence || def.handlers))
              module = def;
          }
          this.moduleCache.set(pluginPath, module);
          console.log(`\u2705 Successfully loaded bundled plugin: ${bundledPath}`);
          return module;
        } catch (bundledError) {
          console.warn(`\u26A0\uFE0F Failed to load plugin from both dev and bundled paths for ${pluginPath}`);
        }
      } else {
        try {
          console.log(`\u{1F504} Attempting to load bundled plugin: ${bundledPath}`);
          let module = await import(bundledPath);
          if (module && module.default && !module.sequence && !module.handlers) {
            const def = module.default;
            if (def && (def.sequence || def.handlers))
              module = def;
          }
          this.moduleCache.set(pluginPath, module);
          console.log(`\u2705 Successfully loaded bundled plugin: ${bundledPath}`);
          return module;
        } catch (bundledError) {
          console.log(`\u26A0\uFE0F Bundled version not available (${bundledPath}), trying original path`);
        }
        try {
          console.log(`\u{1F504} Attempting to load plugin: ${pluginPath}`);
          let module = await import(pluginPath);
          if (module && module.default && !module.sequence && !module.handlers) {
            const def = module.default;
            if (def && (def.sequence || def.handlers))
              module = def;
          }
          this.moduleCache.set(pluginPath, module);
          console.log(`\u2705 Successfully loaded plugin: ${pluginPath}`);
          return module;
        } catch (originalError) {
          console.warn(`\u26A0\uFE0F Failed to load plugin from original path: ${pluginPath}. Error: ${originalError instanceof Error ? originalError.message : originalError}`);
          return this.loadPluginModuleComplex(pluginPath);
        }
      }
    }
    /**
     * Complex plugin loading with full dependency resolution (fallback method)
     * @param pluginPath - Path to the plugin module
     * @returns Plugin module with exports
     */
    async loadPluginModuleComplex(pluginPath) {
      try {
        console.log(`\u{1F504} Loading plugin module with complex resolution: ${pluginPath}`);
        const pluginDir = pluginPath.substring(0, pluginPath.lastIndexOf("/"));
        const pluginName = pluginDir.substring(pluginDir.lastIndexOf("/") + 1);
        console.log(`\u{1F50D} Plugin directory: ${pluginDir}`);
        console.log(`\u{1F50D} Plugin name: ${pluginName}`);
        const resolutionStrategies = [
          `${pluginDir}/index.js`,
          `${pluginDir}/src/index.js`,
          `${pluginDir}/lib/index.js`,
          `${pluginDir}/dist/index.js`,
          `${pluginDir}/${pluginName}.js`,
          `${pluginDir}/main.js`
        ];
        for (const strategy of resolutionStrategies) {
          try {
            console.log(`\u{1F504} Trying resolution strategy: ${strategy}`);
            let module = await import(strategy);
            if (module && module.default && !module.sequence && !module.handlers) {
              const def = module.default;
              if (def && (def.sequence || def.handlers))
                module = def;
            }
            this.moduleCache.set(pluginPath, module);
            console.log(`\u2705 Successfully loaded plugin with strategy: ${strategy}`);
            return module;
          } catch (strategyError) {
            console.log(`\u26A0\uFE0F Strategy failed: ${strategy} - ${strategyError instanceof Error ? strategyError.message : strategyError}`);
          }
        }
        throw new Error(`Failed to load plugin module: ${pluginPath}. All resolution strategies failed.`);
      } catch (error) {
        console.error(`\u274C Complex plugin loading failed for ${pluginPath}:`, error);
        throw error;
      }
    }
    /**
     * Load plugin from a specific path with validation
     * @param pluginPath - Path to the plugin
     * @returns Plugin module or null if failed
     */
    async loadPlugin(pluginPath) {
      try {
        console.log(`\u{1F9E0} PluginLoader: Loading plugin from: ${pluginPath}`);
        const plugin = await this.loadPluginModule(pluginPath);
        if (!plugin || typeof plugin !== "object") {
          console.warn(`\u{1F9E0} Failed to load plugin: invalid plugin structure at ${pluginPath}`);
          return null;
        }
        if (!plugin.sequence && !plugin.handlers && !plugin.default) {
          console.warn(`\u{1F9E0} Plugin at ${pluginPath} missing required exports (sequence, handlers, or default)`);
          return null;
        }
        if (plugin.default && !plugin.sequence) {
          console.log(`\u{1F504} Using default export for plugin: ${pluginPath}`);
          return plugin.default;
        }
        console.log(`\u2705 Successfully loaded and validated plugin: ${pluginPath}`);
        return plugin;
      } catch (error) {
        console.error(`\u274C Failed to load plugin from ${pluginPath}:`, error);
        return null;
      }
    }
    /**
     * Preload multiple plugins
     * @param pluginPaths - Array of plugin paths to preload
     * @returns Array of loaded plugins (null for failed loads)
     */
    async preloadPlugins(pluginPaths) {
      console.log(`\u{1F504} Preloading ${pluginPaths.length} plugins...`);
      const loadPromises = pluginPaths.map(async (path) => {
        try {
          return await this.loadPlugin(path);
        } catch (error) {
          console.error(`\u274C Failed to preload plugin ${path}:`, error);
          return null;
        }
      });
      const results = await Promise.all(loadPromises);
      const successCount = results.filter((result) => result !== null).length;
      console.log(`\u2705 Preloaded ${successCount}/${pluginPaths.length} plugins successfully`);
      return results;
    }
    /**
     * Check if a plugin is cached
     * @param pluginPath - Plugin path to check
     * @returns True if cached
     */
    isCached(pluginPath) {
      return this.moduleCache.has(pluginPath);
    }
    /**
     * Clear the module cache
     */
    clearCache() {
      this.moduleCache.clear();
      console.log("\u{1F9F9} PluginLoader: Module cache cleared");
    }
    /**
     * Get cache statistics
     * @returns Cache statistics
     */
    getCacheStatistics() {
      return {
        cachedModules: this.moduleCache.size,
        cachedPaths: Array.from(this.moduleCache.keys())
      };
    }
    /**
     * Remove a specific module from cache
     * @param pluginPath - Plugin path to remove from cache
     * @returns True if removed, false if not found
     */
    removeCached(pluginPath) {
      const removed = this.moduleCache.delete(pluginPath);
      if (removed) {
        console.log(`\u{1F5D1}\uFE0F Removed plugin from cache: ${pluginPath}`);
      }
      return removed;
    }
    /**
     * Validate plugin module structure
     * @param pluginModule - Plugin module to validate
     * @returns Validation result
     */
    validatePluginModule(pluginModule) {
      const errors = [];
      const warnings = [];
      if (!pluginModule || typeof pluginModule !== "object") {
        errors.push("Plugin module is not a valid object");
        return { isValid: false, errors, warnings };
      }
      if (!pluginModule.sequence) {
        if (pluginModule.default?.sequence) {
          warnings.push("Using sequence from default export");
        } else {
          errors.push("Missing required 'sequence' export");
        }
      }
      if (!pluginModule.handlers) {
        if (pluginModule.default?.handlers) {
          warnings.push("Using handlers from default export");
        } else {
          warnings.push("Missing 'handlers' export - plugin may be event-bus driven");
        }
      }
      return {
        isValid: errors.length === 0,
        errors,
        warnings
      };
    }
  };

  // dist/modules/communication/sequences/plugins/PluginValidator.js
  var PluginValidator = class {
    /**
     * Validate plugin structure for CIA compliance
     * @param sequence - Musical sequence definition
     * @param handlers - Event handlers
     * @param pluginId - Plugin identifier
     * @returns Validation result
     */
    validatePluginStructure(sequence, handlers, pluginId) {
      const errors = [];
      const warnings = [];
      try {
        if (!pluginId || typeof pluginId !== "string" || pluginId.trim() === "") {
          errors.push("Plugin ID must be a non-empty string");
        }
        const sequenceValidation = this.validateSequence(sequence);
        errors.push(...sequenceValidation.errors);
        warnings.push(...sequenceValidation.warnings);
        const handlersValidation = this.validateHandlers(handlers);
        errors.push(...handlersValidation.errors);
        warnings.push(...handlersValidation.warnings);
        const ciaValidation = this.validateCIACompliance(sequence, handlers);
        errors.push(...ciaValidation.errors);
        warnings.push(...ciaValidation.warnings);
        return {
          isValid: errors.length === 0,
          errors,
          warnings
        };
      } catch (error) {
        errors.push(`Validation error: ${error instanceof Error ? error.message : String(error)}`);
        return {
          isValid: false,
          errors,
          warnings
        };
      }
    }
    /**
     * Validate musical sequence structure
     * @param sequence - Sequence to validate
     * @returns Validation result
     */
    validateSequence(sequence) {
      const errors = [];
      const warnings = [];
      if (!sequence) {
        errors.push("Sequence is required");
        return { isValid: false, errors, warnings };
      }
      if (typeof sequence !== "object") {
        errors.push("Sequence must be an object");
        return { isValid: false, errors, warnings };
      }
      if (!sequence.name || typeof sequence.name !== "string") {
        errors.push("Sequence must have a valid name (string)");
      }
      if (!sequence.movements || !Array.isArray(sequence.movements)) {
        errors.push("Sequence must have movements array");
      } else if (sequence.movements.length === 0) {
        warnings.push("Sequence has no movements");
      } else {
        sequence.movements.forEach((movement, index) => {
          const movementValidation = this.validateMovement(movement, index);
          errors.push(...movementValidation.errors);
          warnings.push(...movementValidation.warnings);
        });
      }
      if (sequence.description && typeof sequence.description !== "string") {
        warnings.push("Sequence description should be a string");
      }
      if (sequence.tempo && (typeof sequence.tempo !== "number" || sequence.tempo <= 0)) {
        warnings.push("Sequence tempo should be a positive number");
      }
      if (sequence.key && typeof sequence.key !== "string") {
        warnings.push("Sequence key should be a string");
      }
      return { isValid: errors.length === 0, errors, warnings };
    }
    /**
     * Validate movement structure
     * @param movement - Movement to validate
     * @param index - Movement index for error reporting
     * @returns Validation result
     */
    validateMovement(movement, index) {
      const errors = [];
      const warnings = [];
      if (!movement || typeof movement !== "object") {
        errors.push(`Movement ${index} must be an object`);
        return { isValid: false, errors, warnings };
      }
      if (!movement.name || typeof movement.name !== "string") {
        errors.push(`Movement ${index} must have a valid name (string)`);
      }
      if (!movement.beats || !Array.isArray(movement.beats)) {
        errors.push(`Movement ${index} must have beats array`);
      } else if (movement.beats.length === 0) {
        warnings.push(`Movement ${index} has no beats`);
      } else {
        movement.beats.forEach((beat, beatIndex) => {
          const beatValidation = this.validateBeat(beat, index, beatIndex);
          errors.push(...beatValidation.errors);
          warnings.push(...beatValidation.warnings);
        });
      }
      return { isValid: errors.length === 0, errors, warnings };
    }
    /**
     * Validate beat structure
     * @param beat - Beat to validate
     * @param movementIndex - Movement index for error reporting
     * @param beatIndex - Beat index for error reporting
     * @returns Validation result
     */
    validateBeat(beat, movementIndex, beatIndex) {
      const errors = [];
      const warnings = [];
      if (!beat || typeof beat !== "object") {
        errors.push(`Movement ${movementIndex}, Beat ${beatIndex} must be an object`);
        return { isValid: false, errors, warnings };
      }
      const beatRef = `Movement ${movementIndex}, Beat ${beatIndex}`;
      if (typeof beat.beat !== "number" || beat.beat < 1) {
        errors.push(`${beatRef} must have a valid beat number (>= 1)`);
      }
      if (!beat.event || typeof beat.event !== "string") {
        errors.push(`${beatRef} must have a valid event name (string)`);
      }
      if (!beat.title || typeof beat.title !== "string") {
        errors.push(`${beatRef} must have a valid title (string)`);
      }
      if (!beat.dynamics) {
        warnings.push(`${beatRef} missing dynamics property`);
      }
      if (!beat.timing) {
        warnings.push(`${beatRef} missing timing property`);
      }
      if (!beat.errorHandling) {
        warnings.push(`${beatRef} missing errorHandling property`);
      } else if (!["continue", "abort-sequence", "retry"].includes(beat.errorHandling)) {
        warnings.push(`${beatRef} has invalid errorHandling value: ${beat.errorHandling}`);
      }
      return { isValid: errors.length === 0, errors, warnings };
    }
    /**
     * Validate event handlers
     * @param handlers - Handlers to validate
     * @returns Validation result
     */
    validateHandlers(handlers) {
      const errors = [];
      const warnings = [];
      if (!handlers) {
        warnings.push("No handlers provided - plugin may be event-bus driven");
        return { isValid: true, errors, warnings };
      }
      if (typeof handlers !== "object") {
        errors.push("Handlers must be an object");
        return { isValid: false, errors, warnings };
      }
      Object.entries(handlers).forEach(([eventName, handler]) => {
        if (typeof handler !== "function") {
          errors.push(`Handler for event '${eventName}' must be a function`);
        }
      });
      if (Object.keys(handlers).length === 0) {
        warnings.push("Handlers object is empty");
      }
      return { isValid: errors.length === 0, errors, warnings };
    }
    /**
     * Validate CIA (Conductor Integration Architecture) compliance
     * @param sequence - Sequence to validate
     * @param handlers - Handlers to validate
     * @returns Validation result
     */
    validateCIACompliance(sequence, handlers) {
      const errors = [];
      const warnings = [];
      if (sequence) {
        if (!sequence.description) {
          warnings.push("CIA recommendation: Sequence should have a description");
        }
        if (!sequence.version) {
          warnings.push("CIA recommendation: Sequence should have a version");
        }
        if (sequence.movements) {
          sequence.movements.forEach((movement, movementIndex) => {
            if (movement.beats) {
              movement.beats.forEach((beat, beatIndex) => {
                if (beat.event) {
                  if (!beat.event.includes("-") && !beat.event.includes(".")) {
                    warnings.push(`CIA recommendation: Event '${beat.event}' should use kebab-case or dot notation`);
                  }
                }
              });
            }
          });
        }
      }
      if (handlers) {
        const handlerNames = Object.keys(handlers);
        if (handlerNames.length > 0) {
          handlerNames.forEach((eventName) => {
            if (eventName.toLowerCase().includes("window") || eventName.toLowerCase().includes("document")) {
              warnings.push(`CIA warning: Handler '${eventName}' may cause memory leaks in SPA environment`);
            }
          });
        }
      }
      return { isValid: errors.length === 0, errors, warnings };
    }
    /**
     * Validate plugin metadata
     * @param metadata - Plugin metadata to validate
     * @returns Validation result
     */
    validateMetadata(metadata) {
      const errors = [];
      const warnings = [];
      if (!metadata) {
        warnings.push("No metadata provided");
        return { isValid: true, errors, warnings };
      }
      if (typeof metadata !== "object") {
        errors.push("Metadata must be an object");
        return { isValid: false, errors, warnings };
      }
      if (!metadata.version) {
        warnings.push("Metadata should include version");
      } else if (typeof metadata.version !== "string") {
        warnings.push("Metadata version should be a string");
      }
      if (!metadata.description) {
        warnings.push("Metadata should include description");
      } else if (typeof metadata.description !== "string") {
        warnings.push("Metadata description should be a string");
      }
      if (metadata.author && typeof metadata.author !== "string") {
        warnings.push("Metadata author should be a string");
      }
      return { isValid: errors.length === 0, errors, warnings };
    }
  };

  // dist/modules/communication/sequences/plugins/PluginManifestLoader.js
  var PluginManifestLoader = class {
    constructor() {
      this.manifestCache = /* @__PURE__ */ new Map();
    }
    /**
     * Load plugin manifest from a URL or path
     * @param manifestPath - Path to the manifest file
     * @returns Plugin manifest data
     */
    async loadManifest(manifestPath) {
      if (this.manifestCache.has(manifestPath)) {
        console.log(`\u{1F4E6} Loading manifest from cache: ${manifestPath}`);
        return this.manifestCache.get(manifestPath);
      }
      try {
        console.log(`\u{1F504} Loading plugin manifest: ${manifestPath}`);
        const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
        if (!isBrowser && manifestPath.startsWith("/plugins/")) {
          try {
            const path = await import("node:path");
            const fs = await import("node:fs");
            const localPath = path.resolve(process.cwd(), manifestPath.replace(/^\/?plugins\//, "RenderX/public/plugins/"));
            if (fs.existsSync(localPath)) {
              const jsonText = fs.readFileSync(localPath, "utf-8");
              const manifestData2 = JSON.parse(jsonText);
              const validatedManifest2 = this.validateManifest(manifestData2);
              this.manifestCache.set(manifestPath, validatedManifest2);
              console.log(`\u2705 Successfully loaded manifest from local file: ${localPath}`);
              console.log(`\u{1F4CB} Found ${validatedManifest2.plugins.length} plugins in manifest`);
              return validatedManifest2;
            }
          } catch (nodeErr) {
            console.warn("\u26A0\uFE0F Node local manifest load failed, falling back to fetch:", nodeErr);
          }
        }
        const response = await fetch(manifestPath);
        if (!response.ok) {
          throw new Error(`Failed to fetch manifest: ${response.status} ${response.statusText}`);
        }
        const manifestData = await response.json();
        const validatedManifest = this.validateManifest(manifestData);
        this.manifestCache.set(manifestPath, validatedManifest);
        console.log(`\u2705 Successfully loaded manifest: ${manifestPath}`);
        console.log(`\u{1F4CB} Found ${validatedManifest.plugins.length} plugins in manifest`);
        return validatedManifest;
      } catch (error) {
        console.error(`\u274C Failed to load manifest from ${manifestPath}:`, error);
        const fallbackManifest = this.createFallbackManifest();
        console.log("\u{1F504} Using fallback manifest");
        return fallbackManifest;
      }
    }
    /**
     * Validate manifest structure and content
     * @param manifestData - Raw manifest data
     * @returns Validated manifest
     */
    validateManifest(manifestData) {
      if (!manifestData || typeof manifestData !== "object") {
        throw new Error("Manifest must be a valid JSON object");
      }
      if (!manifestData.version || typeof manifestData.version !== "string") {
        console.warn("\u26A0\uFE0F Manifest missing version, using default");
        manifestData.version = "1.0.0";
      }
      if (!manifestData.plugins || !Array.isArray(manifestData.plugins)) {
        throw new Error("Manifest must contain a plugins array");
      }
      const validatedPlugins = [];
      manifestData.plugins.forEach((plugin, index) => {
        try {
          const validatedPlugin = this.validatePluginEntry(plugin, index);
          validatedPlugins.push(validatedPlugin);
        } catch (error) {
          console.error(`\u274C Invalid plugin entry at index ${index}:`, error);
        }
      });
      if (validatedPlugins.length === 0) {
        console.warn("\u26A0\uFE0F No valid plugins found in manifest");
      }
      return {
        version: manifestData.version,
        plugins: validatedPlugins,
        metadata: manifestData.metadata || {}
      };
    }
    /**
     * Validate individual plugin entry
     * @param plugin - Plugin entry to validate
     * @param index - Index for error reporting
     * @returns Validated plugin entry
     */
    validatePluginEntry(plugin, index) {
      if (!plugin || typeof plugin !== "object") {
        throw new Error(`Plugin entry ${index} must be an object`);
      }
      if (!plugin.name || typeof plugin.name !== "string") {
        throw new Error(`Plugin entry ${index} must have a valid name`);
      }
      if (!plugin.path || typeof plugin.path !== "string") {
        throw new Error(`Plugin entry ${index} must have a valid path`);
      }
      if (!plugin.path.endsWith("/")) {
        plugin.path += "/";
      }
      const validatedPlugin = {
        name: plugin.name,
        path: plugin.path,
        version: plugin.version || "1.0.0",
        description: plugin.description || `Plugin: ${plugin.name}`,
        autoMount: plugin.autoMount !== false,
        // Default to true
        dependencies: Array.isArray(plugin.dependencies) ? plugin.dependencies : [],
        author: plugin.author || "Unknown",
        license: plugin.license || "MIT"
      };
      return validatedPlugin;
    }
    /**
     * Create a fallback manifest when loading fails
     * @returns Fallback manifest
     */
    createFallbackManifest() {
      return {
        version: "1.0.0",
        plugins: [
          {
            name: "fallback-plugin",
            path: "fallback/",
            version: "1.0.0",
            description: "Fallback plugin for when manifest loading fails",
            autoMount: false,
            dependencies: [],
            author: "System",
            license: "MIT"
          }
        ],
        metadata: {
          name: "Fallback Manifest",
          description: "Generated fallback manifest",
          author: "MusicalConductor",
          created: (/* @__PURE__ */ new Date()).toISOString()
        }
      };
    }
    /**
     * Load manifest from multiple sources with fallback
     * @param manifestPaths - Array of manifest paths to try
     * @returns First successfully loaded manifest
     */
    async loadManifestWithFallback(manifestPaths) {
      for (const path of manifestPaths) {
        try {
          const manifest = await this.loadManifest(path);
          console.log(`\u2705 Successfully loaded manifest from: ${path}`);
          return manifest;
        } catch (error) {
          console.warn(`\u26A0\uFE0F Failed to load manifest from ${path}, trying next...`);
        }
      }
      console.warn("\u26A0\uFE0F All manifest sources failed, using fallback");
      return this.createFallbackManifest();
    }
    /**
     * Parse manifest from JSON string
     * @param manifestJson - JSON string containing manifest
     * @returns Parsed and validated manifest
     */
    parseManifest(manifestJson) {
      try {
        const manifestData = JSON.parse(manifestJson);
        return this.validateManifest(manifestData);
      } catch (error) {
        console.error("\u274C Failed to parse manifest JSON:", error);
        throw new Error(`Invalid manifest JSON: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
    /**
     * Filter plugins by criteria
     * @param manifest - Manifest to filter
     * @param criteria - Filter criteria
     * @returns Filtered plugin entries
     */
    filterPlugins(manifest, criteria) {
      return manifest.plugins.filter((plugin) => {
        if (criteria.autoMount !== void 0 && plugin.autoMount !== criteria.autoMount) {
          return false;
        }
        if (criteria.name && !plugin.name.includes(criteria.name)) {
          return false;
        }
        if (criteria.version && plugin.version !== criteria.version) {
          return false;
        }
        if (criteria.author && plugin.author !== criteria.author) {
          return false;
        }
        return true;
      });
    }
    /**
     * Get manifest statistics
     * @param manifest - Manifest to analyze
     * @returns Manifest statistics
     */
    getManifestStatistics(manifest) {
      const autoMountPlugins = manifest.plugins.filter((p) => p.autoMount).length;
      const uniqueAuthors = [
        ...new Set(manifest.plugins.map((p) => p.author || "Unknown"))
      ];
      const versions = [...new Set(manifest.plugins.map((p) => p.version))];
      return {
        totalPlugins: manifest.plugins.length,
        autoMountPlugins,
        manualMountPlugins: manifest.plugins.length - autoMountPlugins,
        uniqueAuthors,
        versions
      };
    }
    /**
     * Clear manifest cache
     */
    clearCache() {
      this.manifestCache.clear();
      console.log("\u{1F9F9} PluginManifestLoader: Cache cleared");
    }
    /**
     * Get cached manifest paths
     * @returns Array of cached manifest paths
     */
    getCachedPaths() {
      return Array.from(this.manifestCache.keys());
    }
    /**
     * Remove specific manifest from cache
     * @param manifestPath - Path to remove from cache
     * @returns True if removed, false if not found
     */
    removeCached(manifestPath) {
      return this.manifestCache.delete(manifestPath);
    }
  };

  // dist/modules/communication/sequences/plugins/PluginManager.js
  init_CallbackRegistry();
  var PluginManager = class {
    constructor(eventBus2, spaValidator, sequenceRegistry) {
      this.mountedPlugins = /* @__PURE__ */ new Map();
      this.pluginHandlers = /* @__PURE__ */ new Map();
      this.pluginSubscriptions = /* @__PURE__ */ new Map();
      this.requestContexts = /* @__PURE__ */ new Map();
      this.pluginsRegistered = false;
      this.discoveredPluginIds = [];
      this.eventBus = eventBus2;
      this.spaValidator = spaValidator;
      this.sequenceRegistry = sequenceRegistry;
      this.pluginLoader = new PluginLoader();
      this.pluginValidator = new PluginValidator();
      this.manifestLoader = new PluginManifestLoader();
    }
    /**
     * Mount a plugin with sequence and handlers
     * @param sequence - Musical sequence definition
     * @param handlers - Event handlers for the sequence
     * @param pluginId - Optional plugin ID (defaults to sequence.name)
     * @param metadata - Optional plugin metadata
     * @returns Plugin mount result
     */
    async mount(sequence, handlers, pluginId, metadata) {
      const id = pluginId || sequence?.name || "unknown-plugin";
      const warnings = [];
      try {
        console.log(`\u{1F9E0} PluginManager: Attempting to mount plugin: ${id}`);
        const validationResult = this.pluginValidator.validatePluginStructure(sequence, handlers, id);
        if (!validationResult.isValid) {
          return {
            success: false,
            pluginId: id,
            message: `Plugin validation failed: ${validationResult.errors.join(", ")}`,
            reason: "validation_failed",
            warnings: validationResult.warnings
          };
        }
        warnings.push(...validationResult.warnings);
        this.spaValidator.registerPlugin(id);
        if (this.mountedPlugins.has(id)) {
          console.log(`\u{1F9E0} Plugin already mounted: ${id} \u2014 augmenting with additional sequence`);
        }
        if (handlers && typeof handlers === "object" && this.spaValidator.config.enforceConductorLogger !== "off") {
          for (const [name, fn] of Object.entries(handlers)) {
            if (typeof fn === "function") {
              const usesConsole = this.spaValidator.detectDirectConsoleUsage(fn);
              if (usesConsole) {
                const stack = new Error().stack || "";
                const violation = this.spaValidator.createViolation("PLUGIN_DIRECT_CONSOLE_USAGE", id, `Direct console usage detected in ${id}.${name}. Use context.logger.<level>(...) instead of console.<level>(...)`, stack, this.spaValidator.config.enforceConductorLogger === "error" ? "error" : "warning");
                this.spaValidator.handleViolation(violation);
                if (this.spaValidator.config.enforceConductorLogger === "error") {
                  warnings.push(`Handler ${name} disabled due to direct console usage`);
                  delete handlers[name];
                }
              }
            }
          }
        }
        this.sequenceRegistry.register(sequence);
        const plugin = {
          sequence,
          handlers: handlers || {},
          metadata: {
            id,
            version: metadata?.version || "1.0.0",
            author: metadata?.author
          }
        };
        const existingPlugin = this.mountedPlugins.get(id);
        if (existingPlugin) {
          const mergedHandlers = { ...existingPlugin.handlers, ...handlers };
          const updatedPlugin = {
            ...existingPlugin,
            handlers: mergedHandlers,
            metadata: {
              id,
              version: metadata?.version || existingPlugin.metadata?.version || "1.0.0",
              author: metadata?.author || existingPlugin.metadata?.author
            }
          };
          this.mountedPlugins.set(id, updatedPlugin);
        } else {
          this.mountedPlugins.set(id, plugin);
        }
        try {
          const unsubscribes = [];
          const movements = sequence?.movements || [];
          for (const movement of movements) {
            const beats = movement?.beats || [];
            for (const beat of beats) {
              const eventName = beat?.event;
              const handlerName = beat?.handler;
              if (!eventName || !handlerName)
                continue;
              const handlerFn = handlers?.[handlerName];
              if (typeof handlerFn !== "function")
                continue;
              const unsubscribe = this.eventBus.subscribe(eventName, (data) => {
                try {
                  const restored = CallbackRegistry.getInstance().rehydrateInPlace(data);
                  if (restored > 0) {
                    console.log(`\u{1F3BC} PluginManager: rehydrated ${restored} callback(s) for event ${eventName}`);
                  }
                } catch (e) {
                  console.warn("\u26A0\uFE0F PluginManager: callback rehydration skipped:", e?.message || e);
                }
                const requestId = data?._musicalContext?.execution?.requestId || `${id}::__global__`;
                let context = this.requestContexts.get(requestId);
                if (!context) {
                  context = {
                    payload: {},
                    onComponentsLoaded: data?.onComponentsLoaded,
                    plugin: { id, metadata: plugin.metadata },
                    sequence: plugin.sequence
                  };
                } else if (data?.onComponentsLoaded) {
                  context.onComponentsLoaded = data.onComponentsLoaded;
                }
                const run = async () => {
                  const logger = {
                    log: (...message) => this.eventBus.emit("musical-conductor:log", {
                      level: "log",
                      message,
                      requestId,
                      pluginId: id,
                      handlerName
                    }),
                    info: (...message) => this.eventBus.emit("musical-conductor:log", {
                      level: "info",
                      message,
                      requestId,
                      pluginId: id,
                      handlerName
                    }),
                    warn: (...message) => this.eventBus.emit("musical-conductor:log", {
                      level: "warn",
                      message,
                      requestId,
                      pluginId: id,
                      handlerName
                    }),
                    error: (...message) => this.eventBus.emit("musical-conductor:log", {
                      level: "error",
                      message,
                      requestId,
                      pluginId: id,
                      handlerName
                    })
                  };
                  this.eventBus.emit("plugin:handler:start", {
                    requestId,
                    pluginId: id,
                    handlerName
                  });
                  const prevSnap = DataBaton.snapshot(context.payload);
                  try {
                    const handlerContext = {
                      ...context,
                      logger,
                      // CIA-compliant: expose minimal conductor with play() only
                      conductor: {
                        play: (pluginId2, sequenceId, ctx, priority) => {
                          try {
                            try {
                              const key = __internal.CORRELATION_KEY;
                              if (ctx && typeof ctx === "object" && key && !(key in ctx) && data && typeof data[key] === "string") {
                                ctx[key] = data[key];
                              }
                            } catch {
                            }
                            const mc = MusicalConductor.getInstance(this.eventBus);
                            return mc.play(pluginId2, sequenceId, ctx, priority);
                          } catch (err) {
                            console.warn(`\u{1F9E0} PluginManager: conductor.play unavailable in handler context for ${id}.${handlerName}:`, err?.message || err);
                            return null;
                          }
                        }
                      },
                      // StageCrew V1: expose per-plugin facade for DOM write cueing
                      stageCrew: (() => {
                        try {
                          const key = __internal.CORRELATION_KEY;
                          const corr = data?.[key] || `mc-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;
                          const { StageCrew: StageCrew2 } = (init_StageCrew(), __toCommonJS(StageCrew_exports));
                          return new StageCrew2(this.eventBus, id);
                        } catch {
                          return void 0;
                        }
                      })(),
                      // Deprecated: emit removed per ADR-0002 (kept temporarily as no-op to avoid breaking plugins)
                      emit: void 0
                    };
                    const result = await handlerFn(data, handlerContext);
                    if (result && typeof result === "object") {
                      context.payload = { ...context.payload, ...result };
                    }
                    const nextSnap = DataBaton.snapshot(context.payload);
                    DataBaton.log({
                      sequenceName: context.sequence?.name,
                      beatEvent: eventName,
                      handlerName,
                      pluginId: id,
                      requestId
                    }, prevSnap, nextSnap);
                    if (handlerName === "notifyComponentsLoaded") {
                      const prepared = context.payload?.preparedComponents || [];
                      if (typeof context.onComponentsLoaded === "function") {
                        try {
                          context.onComponentsLoaded(prepared);
                        } catch {
                        }
                      }
                      this.eventBus.emit("components:loaded", {
                        components: prepared
                      });
                    }
                  } catch (err) {
                    console.error(`\u{1F9E0} PluginManager: Handler execution failed for ${id}.${handlerName}:`, err);
                  } finally {
                    this.eventBus.emit("plugin:handler:end", {
                      requestId,
                      pluginId: id,
                      handlerName
                    });
                  }
                };
                context.chain = (context.chain || Promise.resolve()).then(run).catch(() => {
                });
                this.requestContexts.set(requestId, context);
              }, { pluginId: `${id}:${sequence.id}` });
              unsubscribes.push(unsubscribe);
            }
          }
          if (unsubscribes.length > 0) {
            const existingUnsubscribes = this.pluginSubscriptions.get(id) || [];
            this.pluginSubscriptions.set(id, [...existingUnsubscribes, ...unsubscribes]);
          }
        } catch (wireErr) {
          console.warn(`\u{1F9E0} PluginManager: Failed wiring beat handlers for ${id}:`, wireErr);
        }
        if (handlers && typeof handlers === "object") {
          const existingHandlers = this.pluginHandlers.get(id) || {};
          this.pluginHandlers.set(id, { ...existingHandlers, ...handlers });
        }
        try {
          this.eventBus.subscribe(`${id}:sequence:completed`, (data) => {
            const requestId = data?._musicalContext?.execution?.requestId;
            if (requestId)
              this.requestContexts.delete(requestId);
          }, { pluginId: `${id}:${sequence.id}:cleanup` });
        } catch {
        }
        console.log(`\u2705 Plugin mounted successfully: ${id}`);
        console.log(`\u{1F3BC} Sequence registered: ${sequence.name}`);
        return {
          success: true,
          pluginId: id,
          message: `Successfully mounted plugin: ${id}`,
          warnings
        };
      } catch (error) {
        console.error(`\u274C Failed to mount plugin ${id}:`, error);
        return {
          success: false,
          pluginId: id,
          message: error instanceof Error ? error.message : String(error),
          reason: "mount_error",
          warnings
        };
      }
    }
    /**
     * Unmount a plugin and cleanup event subscriptions
     */
    async unmount(pluginId) {
      try {
        const subs = this.pluginSubscriptions.get(pluginId) || [];
        for (const unsub of subs) {
          try {
            unsub?.();
          } catch {
          }
        }
        this.pluginSubscriptions.delete(pluginId);
        this.mountedPlugins.delete(pluginId);
        this.pluginHandlers.delete(pluginId);
      } catch (err) {
        console.warn(`\u{1F9E0} PluginManager: Failed to unmount ${pluginId}:`, err);
      }
    }
    /**
     * Unmount a plugin
     * @param pluginId - Plugin ID to unmount
     * @returns True if successfully unmounted
     */
    unmountPlugin(pluginId) {
      try {
        if (!this.mountedPlugins.has(pluginId)) {
          console.warn(`\u{1F9E0} Plugin not found for unmounting: ${pluginId}`);
          return false;
        }
        const plugin = this.mountedPlugins.get(pluginId);
        this.sequenceRegistry.unregister(plugin.sequence.name);
        this.mountedPlugins.delete(pluginId);
        this.pluginHandlers.delete(pluginId);
        console.log(`\u2705 Plugin unmounted successfully: ${pluginId}`);
        return true;
      } catch (error) {
        console.error(`\u274C Failed to unmount plugin ${pluginId}:`, error);
        return false;
      }
    }
    /**
     * Register CIA-compliant plugins
     * Loads and mounts all plugins from the plugins directory
     */
    async registerCIAPlugins() {
      try {
        if (this.pluginsRegistered) {
          console.log("\u26A0\uFE0F Plugins already registered, skipping duplicate registration");
          return;
        }
        console.log("\u{1F9E0} Registering CIA-compliant plugins...");
        const beforeCount = this.getMountedPluginIds().length;
        const pluginManifest = await this.manifestLoader.loadManifest("/plugins/manifest.json");
        await this.registerPluginsFromManifest(pluginManifest);
        try {
          this.discoveredPluginIds = pluginManifest.plugins.map((p) => p.name);
        } catch {
        }
        const afterCount = this.getMountedPluginIds().length;
        if (afterCount > beforeCount) {
          this.pluginsRegistered = true;
          console.log(`\u2705 CIA-compliant plugins registered successfully (mounted: ${afterCount - beforeCount}, total: ${afterCount})`);
        } else {
          console.warn("\u26A0\uFE0F No CIA plugins were mounted. Leaving pluginsRegistered=false so a later retry can succeed.");
        }
      } catch (error) {
        console.error("\u274C Failed to register CIA plugins:", error);
        this.registerFallbackSequences();
      }
    }
    /**
     * Register plugins from manifest
     * @param manifest - Plugin manifest data
     */
    async registerPluginsFromManifest(manifest) {
      console.log("\u{1F3BC} PluginManager: Registering plugins from manifest...");
      console.log(`\u{1F50C} Processing ${manifest.plugins.length} plugins from manifest`);
      for (const plugin of manifest.plugins) {
        try {
          if (plugin.autoMount) {
            if (this.mountedPlugins.has(plugin.name)) {
              console.log(`\u26A0\uFE0F Plugin already mounted, skipping: ${plugin.name}`);
              continue;
            }
            console.log(`\u{1F50C} Auto-mounting plugin: ${plugin.name} from ${plugin.path}`);
            const pluginModule = await this.pluginLoader.loadPluginModule(`/plugins/${plugin.path}index.js`);
            if (!pluginModule.sequence || !pluginModule.handlers) {
              console.warn(`\u26A0\uFE0F Plugin ${plugin.name} missing required exports (sequence, handlers)`);
              continue;
            }
            const mountResult = await this.mount(pluginModule.sequence, pluginModule.handlers, pluginModule.sequence?.id || plugin.name, {
              version: plugin.version,
              description: plugin.description,
              path: plugin.path,
              autoMount: plugin.autoMount
            });
            if (mountResult.success) {
              console.log(`\u2705 Auto-mounted plugin: ${plugin.name}`);
            } else {
              console.error(`\u274C Failed to auto-mount plugin ${plugin.name}: ${mountResult.message}`);
            }
          } else {
            console.log(`\u23ED\uFE0F Skipping non-auto-mount plugin: ${plugin.name}`);
          }
        } catch (error) {
          console.error(`\u274C Error processing plugin ${plugin.name}:`, error);
        }
      }
    }
    /**
     * Register fallback sequences when plugin loading fails
     */
    registerFallbackSequences() {
      console.log("\u{1F504} Registering fallback sequences...");
      const fallbackSequences = [
        {
          name: "fallback-sequence",
          description: "Basic fallback sequence",
          movements: [
            {
              name: "fallback-movement",
              beats: [
                {
                  beat: 1,
                  event: "fallback-event",
                  title: "Fallback Event",
                  description: "Basic fallback event",
                  dynamics: "forte",
                  timing: "immediate",
                  errorHandling: "continue",
                  data: {}
                }
              ]
            }
          ]
        }
      ];
      fallbackSequences.forEach((sequence) => {
        this.sequenceRegistry.register(sequence);
      });
      console.log("\u2705 Fallback sequences registered");
    }
    /**
     * Get plugin information
     * @param pluginId - Plugin ID
     * @returns Plugin information or undefined
     */
    getPluginInfo(pluginId) {
      return this.mountedPlugins.get(pluginId);
    }
    /**
     * Get all mounted plugin IDs
     * @returns Array of plugin IDs
     */
    getMountedPluginIds() {
      const mountedIds = Array.from(this.mountedPlugins.keys());
      let sequenceIds = [];
      try {
        sequenceIds = this.sequenceRegistry.getAll().map((s) => s.id);
      } catch {
      }
      const all = /* @__PURE__ */ new Set();
      for (const id of mountedIds)
        if (id)
          all.add(id);
      for (const id of sequenceIds)
        if (id)
          all.add(id);
      for (const id of this.discoveredPluginIds || [])
        if (id)
          all.add(id);
      return Array.from(all);
    }
    /**
     * Get all mounted plugin names (alias for getMountedPluginIds)
     */
    getMountedPlugins() {
      return this.getMountedPluginIds();
    }
    /**
     * Get plugin handlers for a specific plugin
     * @param pluginId - Plugin ID
     * @returns Plugin handlers or null
     */
    getPluginHandlers(pluginId) {
      const plugin = this.mountedPlugins.get(pluginId);
      if (!plugin) {
        console.warn(`\u{1F9E0} Plugin not found: ${pluginId}. Available plugins: [${Array.from(this.mountedPlugins.keys()).join(", ")}]`);
        return null;
      }
      return this.pluginHandlers.get(pluginId) || null;
    }
    /**
     * Get plugin statistics
     * @returns Plugin statistics
     */
    getStatistics() {
      return {
        totalPlugins: this.mountedPlugins.size,
        mountedPlugins: this.getMountedPluginIds(),
        pluginsRegistered: this.pluginsRegistered
      };
    }
    /**
     * Get total number of sequences from all mounted plugins
     * @returns Total sequence count
     */
    getTotalSequences() {
      return Array.from(this.mountedPlugins.values()).reduce((count, plugin) => {
        return count + (plugin.sequence ? 1 : 0);
      }, 0);
    }
    /**
     * Reset plugin manager state (for testing)
     */
    reset() {
      this.mountedPlugins.clear();
      this.pluginHandlers.clear();
      this.pluginsRegistered = false;
      console.log("\u{1F9F9} PluginManager: State reset");
    }
  };

  // dist/modules/communication/sequences/plugins/PluginInterfaceFacade.js
  init_SequenceTypes();
  var PluginInterfaceFacade = class {
    constructor(pluginManager, spaValidator) {
      this.pluginManager = pluginManager;
      this.spaValidator = spaValidator;
    }
    /**
     * Get all mounted plugin names
     */
    getMountedPlugins() {
      return this.pluginManager.getMountedPlugins();
    }
    /**
     * Play a specific sequence of a mounted SPA plugin (CIA-compliant)
     * @param pluginId - The plugin identifier
     * @param sequenceName - The sequence name to execute
     * @param context - Context data to pass to the movement handler
     * @param priority - Sequence priority (NORMAL, HIGH, CHAINED)
     * @returns Execution result
     */
    play(pluginId, sequenceName, context = {}, priority = SEQUENCE_PRIORITIES.NORMAL, startSequenceCallback) {
      try {
        console.log(`\u{1F3BC} PluginInterfaceFacade.play(): ${pluginId} -> ${sequenceName}`);
        this.spaValidator.registerPlugin(pluginId);
        const plugin = this.pluginManager.getPluginInfo(pluginId);
        if (!plugin) {
          console.warn(`\u{1F9E0} Plugin not found: ${pluginId}. Available plugins: [${this.pluginManager.getMountedPluginIds().join(", ")}]`);
          return Promise.resolve(null);
        }
        return startSequenceCallback(sequenceName, context, priority);
      } catch (error) {
        console.error(`\u{1F9E0} PluginInterfaceFacade.play() failed for ${pluginId}.${sequenceName}:`, error.message);
        return Promise.resolve(null);
      }
    }
    /**
     * Mount an SPA plugin with comprehensive validation (CIA-compliant)
     * @param sequence - The sequence definition from the plugin
     * @param handlers - The handlers object from the plugin
     * @param pluginId - Optional plugin ID (defaults to sequence.name)
     * @returns Plugin mount result
     */
    async mount(sequence, handlers, pluginId, metadata) {
      return this.pluginManager.mount(sequence, handlers, pluginId, metadata);
    }
    /**
     * Register CIA-compliant plugins
     * Loads and mounts all plugins from the plugins directory
     */
    async registerCIAPlugins() {
      return this.pluginManager.registerCIAPlugins();
    }
    /**
     * Execute movement with handler validation (CIA-compliant)
     * @param sequenceName - Sequence name
     * @param movementName - Movement name
     * @param data - Movement data
     * @returns Handler execution result
     */
    executeMovementWithHandler(sequenceName, movementName, data) {
      try {
        const handlers = this.pluginManager.getPluginHandlers(sequenceName);
        if (!handlers) {
          console.warn(`\u{1F9E0} No handlers found for sequence: ${sequenceName}`);
          return null;
        }
        const handler = handlers[movementName];
        if (!handler || typeof handler !== "function") {
          console.warn(`\u{1F9E0} Handler not found or not a function: ${sequenceName}.${movementName}`);
          return null;
        }
        console.log(`\u{1F3BC} Executing handler: ${sequenceName}.${movementName} with data:`, data);
        return handler(data);
      } catch (error) {
        console.error(`\u{1F9E0} Handler execution failed for ${sequenceName}.${movementName}:`, error.message);
        return null;
      }
    }
    /**
     * Load plugin from dynamic import with error handling (CIA-compliant)
     * @param pluginPath - Path to the plugin module
     * @returns Plugin load result
     */
    async loadPlugin(pluginPath) {
      try {
        console.log(`\u{1F9E0} PluginInterfaceFacade: Loading plugin from: ${pluginPath}`);
        const plugin = await this.pluginManager.pluginLoader.loadPlugin(pluginPath);
        if (!plugin) {
          return {
            success: false,
            pluginId: "unknown",
            message: `Failed to load plugin: ${pluginPath}`,
            reason: "load_failed"
          };
        }
        return await this.mount(plugin.sequence, plugin.handlers);
      } catch (error) {
        console.warn(`\u{1F9E0} PluginInterfaceFacade: Failed to load plugin from ${pluginPath}:`, error.message);
        return {
          success: false,
          pluginId: "unknown",
          message: `Failed to load plugin from ${pluginPath}: ${error.message}`,
          reason: "load_error"
        };
      }
    }
    /**
     * Extract plugin code for SPA validation
     * @param sequence - Plugin sequence
     * @param handlers - Plugin handlers
     * @returns String representation of plugin code
     */
    extractPluginCode(sequence, handlers) {
      try {
        const sequenceCode = JSON.stringify(sequence, null, 2);
        const handlersCode = Object.keys(handlers).map((key) => `${key}: ${handlers[key].toString()}`).join("\n");
        return `${sequenceCode}
${handlersCode}`;
      } catch (error) {
        console.warn("\u{1F3BC} Failed to extract plugin code for validation:", error);
        return "";
      }
    }
    /**
     * Validate plugin pre-compilation status
     * @param pluginId - Plugin identifier
     * @returns Validation result
     */
    async validatePluginPreCompilation(pluginId) {
      try {
        const issues = [];
        const bundlePath = `/plugins/${pluginId}/dist/plugin.js`;
        try {
          const response = await fetch(bundlePath);
          if (!response.ok) {
            issues.push(`Missing bundled artifact: ${bundlePath}`);
          }
        } catch {
          issues.push(`Cannot access bundled artifact: ${bundlePath}`);
        }
        const requiredFiles = ["index.js", "sequence.js", "manifest.json"];
        for (const file of requiredFiles) {
          const filePath = `/plugins/${pluginId}/${file}`;
          try {
            const response = await fetch(filePath);
            if (!response.ok) {
              issues.push(`Missing required file: ${filePath}`);
            }
          } catch {
            issues.push(`Cannot access required file: ${filePath}`);
          }
        }
        return {
          valid: issues.length === 0,
          issues
        };
      } catch (error) {
        console.warn(`\u{1F528} Pre-compilation validation error for ${pluginId}:`, error);
        return {
          valid: false,
          issues: [`Validation error: ${error.message}`]
        };
      }
    }
    /**
     * Unmount a plugin (CIA-compliant)
     * @param pluginId - Plugin identifier
     * @returns Success status
     */
    unmountPlugin(pluginId) {
      return this.pluginManager.unmountPlugin(pluginId);
    }
    /**
     * Get mounted plugin information
     * @param pluginId - Plugin identifier
     * @returns Plugin information or undefined
     */
    getPluginInfo(pluginId) {
      return this.pluginManager.getPluginInfo(pluginId);
    }
    /**
     * Get all mounted plugin IDs
     * @returns Array of plugin IDs
     */
    getMountedPluginIds() {
      return this.pluginManager.getMountedPluginIds();
    }
    /**
     * Get plugin statistics
     * @returns Plugin statistics
     */
    getPluginStatistics() {
      const pluginIds = this.pluginManager.getMountedPluginIds();
      return {
        mountedPlugins: pluginIds.length,
        totalSequences: this.pluginManager.getTotalSequences(),
        pluginIds
      };
    }
  };

  // dist/modules/communication/sequences/resources/ResourceConflictResolver.js
  init_SequenceTypes();
  var ResourceConflictResolver = class {
    constructor(ownershipTracker) {
      this.ownershipTracker = ownershipTracker;
    }
    /**
     * Analyze priority-based conflicts
     * @param resourceId - Resource identifier
     * @param symphonyName - Requesting symphony name
     * @param priority - Requesting priority
     * @param currentOwner - Current resource owner
     * @returns Conflict analysis result
     */
    analyzePriorityConflict(resourceId, symphonyName, priority, currentOwner) {
      if (priority === SEQUENCE_PRIORITIES.HIGH) {
        return {
          hasConflict: true,
          conflictType: "PRIORITY_CONFLICT",
          currentOwner,
          resolution: "INTERRUPT",
          message: `HIGH priority ${symphonyName} can interrupt ${currentOwner.symphonyName} for resource ${resourceId}`
        };
      }
      return {
        hasConflict: true,
        conflictType: "SAME_RESOURCE",
        currentOwner,
        resolution: "REJECT",
        message: `Resource ${resourceId} is owned by ${currentOwner.symphonyName}, rejecting ${priority} priority request from ${symphonyName}`
      };
    }
    /**
     * Resolve conflict by rejecting the request
     * @param resourceId - Resource identifier
     * @param requestingSymphony - Requesting symphony name
     * @param currentOwner - Current resource owner
     * @returns Resolution result
     */
    resolveConflict_Reject(resourceId, requestingSymphony, currentOwner) {
      console.warn(`\u{1F3BC} ResourceConflictResolver: REJECT - Resource ${resourceId} is owned by ${currentOwner.symphonyName}, rejecting request from ${requestingSymphony}`);
      return {
        success: false,
        message: `Resource conflict: ${resourceId} owned by ${currentOwner.symphonyName}`
      };
    }
    /**
     * Resolve conflict by queuing the request
     * @param sequenceRequest - Full sequence request
     * @param resourceId - Resource identifier
     * @param currentOwner - Current resource owner
     * @returns Resolution result
     */
    resolveConflict_Queue(sequenceRequest, resourceId, currentOwner) {
      const queuedRequest = {
        ...sequenceRequest,
        data: {
          ...sequenceRequest.data,
          waitingForResource: resourceId,
          blockedBy: currentOwner.symphonyName,
          queuedAt: Date.now()
        }
      };
      console.log(`\u{1F3BC} ResourceConflictResolver: QUEUE - Adding ${sequenceRequest.sequenceName} to queue, waiting for resource ${resourceId} from ${currentOwner.symphonyName}`);
      return {
        success: true,
        message: `Request queued waiting for resource ${resourceId}`
      };
    }
    /**
     * Resolve conflict by interrupting the current owner
     * @param resourceId - Resource identifier
     * @param requestingSymphony - Requesting symphony name
     * @param requestingInstanceId - Requesting instance ID
     * @param requestingPriority - Requesting priority
     * @param requestingExecutionId - Requesting execution ID
     * @param currentOwner - Current resource owner
     * @param resourceManager - Resource manager for ownership operations
     * @returns Resolution result
     */
    resolveConflict_Interrupt(resourceId, requestingSymphony, requestingInstanceId, requestingPriority, requestingExecutionId, currentOwner, resourceManager) {
      if (requestingPriority !== SEQUENCE_PRIORITIES.HIGH) {
        return {
          success: false,
          message: `Only HIGH priority requests can interrupt. Current priority: ${requestingPriority}`
        };
      }
      console.log(`\u{1F3BC} ResourceConflictResolver: INTERRUPT - HIGH priority ${requestingSymphony} interrupting ${currentOwner.symphonyName} for resource ${resourceId}`);
      console.warn(`\u{1F3BC} ResourceConflictResolver: Interrupting ${currentOwner.symphonyName} (${currentOwner.instanceId}) for HIGH priority request`);
      console.log(`\u{1F3BC} ResourceConflictResolver: Resource ${resourceId} forcibly transferred from ${currentOwner.symphonyName} to ${requestingSymphony}`);
      resourceManager.releaseResourceOwnership(resourceId, currentOwner.sequenceExecutionId);
      const acquired = resourceManager.acquireResourceOwnership(resourceId, requestingSymphony, requestingInstanceId, requestingPriority, requestingExecutionId);
      return {
        success: acquired,
        message: acquired ? `Resource ${resourceId} successfully transferred to ${requestingSymphony}` : `Failed to transfer resource ${resourceId} to ${requestingSymphony}`
      };
    }
    /**
     * Determine optimal resolution strategy based on context
     * @param resourceId - Resource identifier
     * @param requestingPriority - Requesting priority
     * @param currentOwner - Current resource owner
     * @param queueLength - Current queue length
     * @returns Recommended resolution strategy
     */
    determineOptimalStrategy(resourceId, requestingPriority, currentOwner, queueLength) {
      if (requestingPriority === SEQUENCE_PRIORITIES.HIGH) {
        return "INTERRUPT";
      }
      if (queueLength > 5 && requestingPriority === SEQUENCE_PRIORITIES.NORMAL) {
        return "REJECT";
      }
      const ownershipDuration = Date.now() - currentOwner.acquiredAt;
      const maxOwnershipTime = 3e4;
      if (ownershipDuration > maxOwnershipTime) {
        return "QUEUE";
      }
      return "REJECT";
    }
    /**
     * Get conflict resolution statistics
     * @returns Resolution statistics
     */
    getResolutionStatistics() {
      return {
        totalConflicts: 0,
        rejectedRequests: 0,
        queuedRequests: 0,
        interruptedOwners: 0,
        averageResolutionTime: 0
      };
    }
    /**
     * Check if a resource conflict can be resolved peacefully
     * @param resourceId - Resource identifier
     * @param requestingPriority - Requesting priority
     * @param currentOwner - Current resource owner
     * @returns True if peaceful resolution is possible
     */
    canResolvePeacefully(resourceId, requestingPriority, currentOwner) {
      if (requestingPriority === SEQUENCE_PRIORITIES.HIGH) {
        return false;
      }
      const ownershipDuration = Date.now() - currentOwner.acquiredAt;
      const estimatedRemainingTime = 1e4;
      return ownershipDuration > estimatedRemainingTime;
    }
  };

  // dist/modules/communication/sequences/resources/ResourceOwnershipTracker.js
  var ResourceOwnershipTracker = class {
    constructor() {
      this.resourceOwnership = /* @__PURE__ */ new Map();
      this.sequenceInstances = /* @__PURE__ */ new Map();
      this.symphonyResourceMap = /* @__PURE__ */ new Map();
      this.instanceCounter = 0;
    }
    /**
     * Get resource owner
     * @param resourceId - Resource identifier
     * @returns Resource owner or undefined
     */
    getResourceOwner(resourceId) {
      return this.resourceOwnership.get(resourceId);
    }
    /**
     * Set resource owner
     * @param resourceId - Resource identifier
     * @param owner - Resource owner
     * @param symphonyName - Symphony name
     * @returns Success status
     */
    setResourceOwner(resourceId, owner, symphonyName) {
      try {
        this.resourceOwnership.set(resourceId, owner);
        if (!this.symphonyResourceMap.has(symphonyName)) {
          this.symphonyResourceMap.set(symphonyName, /* @__PURE__ */ new Set());
        }
        this.symphonyResourceMap.get(symphonyName).add(resourceId);
        console.log(`\u{1F3BC} ResourceOwnershipTracker: Resource ${resourceId} acquired by ${symphonyName} (${owner.instanceId})`);
        return true;
      } catch (error) {
        console.error(`\u{1F3BC} ResourceOwnershipTracker: Failed to set resource owner for ${resourceId}:`, error);
        return false;
      }
    }
    /**
     * Release resource
     * @param resourceId - Resource identifier
     * @param symphonyName - Symphony name
     */
    releaseResource(resourceId, symphonyName) {
      this.resourceOwnership.delete(resourceId);
      const symphonyResources = this.symphonyResourceMap.get(symphonyName);
      if (symphonyResources) {
        symphonyResources.delete(resourceId);
        if (symphonyResources.size === 0) {
          this.symphonyResourceMap.delete(symphonyName);
        }
      }
      console.log(`\u{1F3BC} ResourceOwnershipTracker: Resource ${resourceId} released from ${symphonyName}`);
    }
    /**
     * Create sequence instance
     * @param symphonyName - Symphony name
     * @param sequenceExecutionId - Sequence execution ID
     * @returns Instance ID
     */
    createSequenceInstance(symphonyName, sequenceExecutionId) {
      const instanceId = `${symphonyName}-${++this.instanceCounter}-${Date.now()}`;
      const instance = {
        instanceId,
        symphonyName,
        sequenceExecutionId,
        createdAt: Date.now(),
        resourcesOwned: []
      };
      this.sequenceInstances.set(instanceId, instance);
      console.log(`\u{1F3BC} ResourceOwnershipTracker: Created sequence instance ${instanceId} for ${symphonyName}`);
      return instanceId;
    }
    /**
     * Update sequence instance resources
     * @param instanceId - Instance identifier
     * @param resourceIds - Resource identifiers
     */
    updateInstanceResources(instanceId, resourceIds) {
      const instance = this.sequenceInstances.get(instanceId);
      if (instance) {
        instance.resourcesOwned = [...resourceIds];
      }
    }
    /**
     * Remove sequence instance
     * @param instanceId - Instance identifier
     */
    removeSequenceInstance(instanceId) {
      const instance = this.sequenceInstances.get(instanceId);
      if (instance) {
        instance.resourcesOwned.forEach((resourceId) => {
          this.releaseResource(resourceId, instance.symphonyName);
        });
        this.sequenceInstances.delete(instanceId);
        console.log(`\u{1F3BC} ResourceOwnershipTracker: Removed sequence instance ${instanceId}`);
      }
    }
    /**
     * Get all resource owners
     * @returns Resource ownership map
     */
    getAllResourceOwners() {
      return new Map(this.resourceOwnership);
    }
    /**
     * Get symphony resource mapping
     * @returns Symphony to resources mapping
     */
    getSymphonyResourceMap() {
      return new Map(this.symphonyResourceMap);
    }
    /**
     * Get sequence instances
     * @returns Sequence instances map
     */
    getSequenceInstances() {
      return new Map(this.sequenceInstances);
    }
    /**
     * Get resources owned by symphony
     * @param symphonyName - Symphony name
     * @returns Set of resource IDs
     */
    getResourcesOwnedBySymphony(symphonyName) {
      return this.symphonyResourceMap.get(symphonyName) || /* @__PURE__ */ new Set();
    }
    /**
     * Get active instances for symphony
     * @param symphonyName - Symphony name
     * @returns Array of sequence instances
     */
    getActiveInstancesForSymphony(symphonyName) {
      return Array.from(this.sequenceInstances.values()).filter((instance) => instance.symphonyName === symphonyName);
    }
    /**
     * Check if resource is owned
     * @param resourceId - Resource identifier
     * @returns True if resource is owned
     */
    isResourceOwned(resourceId) {
      return this.resourceOwnership.has(resourceId);
    }
    /**
     * Get ownership duration
     * @param resourceId - Resource identifier
     * @returns Ownership duration in milliseconds, or 0 if not owned
     */
    getOwnershipDuration(resourceId) {
      const owner = this.resourceOwnership.get(resourceId);
      return owner ? Date.now() - owner.acquiredAt : 0;
    }
    /**
     * Get resource statistics
     * @returns Resource usage statistics
     */
    getStatistics() {
      const ownedResources = this.resourceOwnership.size;
      const symphoniesWithResources = this.symphonyResourceMap.size;
      let totalDuration = 0;
      let resourceCount = 0;
      for (const owner of this.resourceOwnership.values()) {
        totalDuration += Date.now() - owner.acquiredAt;
        resourceCount++;
      }
      const averageOwnershipDuration = resourceCount > 0 ? totalDuration / resourceCount : 0;
      return {
        totalResources: ownedResources,
        // In a real system, this would be total available resources
        ownedResources,
        availableResources: 0,
        // Would be calculated as totalResources - ownedResources
        symphoniesWithResources,
        averageOwnershipDuration
      };
    }
    /**
     * Clean up expired instances
     * @param maxAge - Maximum age in milliseconds
     * @returns Number of cleaned up instances
     */
    cleanupExpiredInstances(maxAge = 3e5) {
      const now = Date.now();
      let cleanedUp = 0;
      for (const [instanceId, instance] of this.sequenceInstances.entries()) {
        if (now - instance.createdAt > maxAge) {
          this.removeSequenceInstance(instanceId);
          cleanedUp++;
        }
      }
      if (cleanedUp > 0) {
        console.log(`\u{1F9F9} ResourceOwnershipTracker: Cleaned up ${cleanedUp} expired instances`);
      }
      return cleanedUp;
    }
    /**
     * Reset all tracking data (for testing)
     */
    reset() {
      this.resourceOwnership.clear();
      this.sequenceInstances.clear();
      this.symphonyResourceMap.clear();
      this.instanceCounter = 0;
      console.log("\u{1F9F9} ResourceOwnershipTracker: All tracking data reset");
    }
    /**
     * Get debug information
     * @returns Debug information object
     */
    getDebugInfo() {
      return {
        resourceOwnership: Object.fromEntries(this.resourceOwnership),
        sequenceInstances: Object.fromEntries(this.sequenceInstances),
        symphonyResourceMap: Object.fromEntries(Array.from(this.symphonyResourceMap.entries()).map(([key, value]) => [
          key,
          Array.from(value)
        ])),
        instanceCounter: this.instanceCounter
      };
    }
  };

  // dist/modules/communication/sequences/resources/ResourceManager.js
  var ResourceManager = class {
    constructor() {
      this.ownershipTracker = new ResourceOwnershipTracker();
      this.conflictResolver = new ResourceConflictResolver(this.ownershipTracker);
    }
    /**
     * Check for resource conflicts
     * @param resourceId - Resource identifier
     * @param symphonyName - Symphony name
     * @param priority - Sequence priority
     * @param instanceId - Instance identifier
     * @returns Conflict analysis result
     */
    checkResourceConflict(resourceId, symphonyName, priority, instanceId) {
      const currentOwner = this.ownershipTracker.getResourceOwner(resourceId);
      if (!currentOwner) {
        return {
          hasConflict: false,
          conflictType: "NONE",
          resolution: "ALLOW",
          message: `Resource ${resourceId} is available`
        };
      }
      if (currentOwner.symphonyName === symphonyName) {
        if (currentOwner.instanceId === instanceId) {
          return {
            hasConflict: false,
            conflictType: "NONE",
            currentOwner,
            resolution: "ALLOW",
            message: `Resource ${resourceId} already owned by same instance`
          };
        } else {
          return {
            hasConflict: true,
            conflictType: "INSTANCE_CONFLICT",
            currentOwner,
            resolution: "REJECT",
            message: `Resource ${resourceId} owned by different instance of ${symphonyName}`
          };
        }
      }
      return this.conflictResolver.analyzePriorityConflict(resourceId, symphonyName, priority, currentOwner);
    }
    /**
     * Acquire resource ownership
     * @param resourceId - Resource identifier
     * @param symphonyName - Symphony name
     * @param instanceId - Instance identifier
     * @param priority - Sequence priority
     * @param sequenceExecutionId - Sequence execution ID
     * @returns Success status
     */
    acquireResourceOwnership(resourceId, symphonyName, instanceId, priority, sequenceExecutionId) {
      const conflictResult = this.checkResourceConflict(resourceId, symphonyName, priority, instanceId);
      if (conflictResult.resolution === "REJECT") {
        console.warn(`\u{1F3BC} ResourceManager: Resource acquisition rejected - ${conflictResult.message}`);
        return false;
      } else if (conflictResult.resolution === "INTERRUPT") {
        console.log(`\u{1F3BC} ResourceManager: Interrupting current owner for HIGH priority request - ${conflictResult.message}`);
        this.releaseResourceOwnership(resourceId, conflictResult.currentOwner.sequenceExecutionId);
      }
      const resourceOwner = {
        symphonyName,
        instanceId,
        resourceId,
        acquiredAt: Date.now(),
        priority,
        sequenceExecutionId
      };
      return this.ownershipTracker.setResourceOwner(resourceId, resourceOwner, symphonyName);
    }
    /**
     * Release resource ownership
     * @param resourceId - Resource identifier
     * @param sequenceExecutionId - Sequence execution ID (for verification)
     */
    releaseResourceOwnership(resourceId, sequenceExecutionId) {
      const currentOwner = this.ownershipTracker.getResourceOwner(resourceId);
      if (!currentOwner) {
        return;
      }
      if (sequenceExecutionId && currentOwner.sequenceExecutionId !== sequenceExecutionId) {
        console.warn(`\u{1F3BC} ResourceManager: Cannot release resource ${resourceId} - execution ID mismatch`);
        return;
      }
      this.ownershipTracker.releaseResource(resourceId, currentOwner.symphonyName);
      console.log(`\u{1F3BC} ResourceManager: Released resource ${resourceId} from ${currentOwner.symphonyName}`);
    }
    /**
     * Resolve resource conflicts with advanced strategies
     * @param resourceId - Resource identifier
     * @param symphonyName - Symphony name
     * @param instanceId - Instance identifier
     * @param priority - Sequence priority
     * @param sequenceExecutionId - Sequence execution ID
     * @param sequenceRequest - Full sequence request (for queuing)
     * @returns Resolution result
     */
    resolveResourceConflictAdvanced(resourceId, symphonyName, instanceId, priority, sequenceExecutionId, sequenceRequest) {
      const conflictResult = this.checkResourceConflict(resourceId, symphonyName, priority, instanceId);
      if (!conflictResult.hasConflict) {
        const acquired = this.acquireResourceOwnership(resourceId, symphonyName, instanceId, priority, sequenceExecutionId);
        return {
          success: acquired,
          message: acquired ? `Resource ${resourceId} acquired successfully` : `Failed to acquire resource ${resourceId}`,
          strategy: "DIRECT_ACQUISITION"
        };
      }
      const currentOwner = conflictResult.currentOwner;
      switch (conflictResult.resolution) {
        case "REJECT":
          const rejectResult = this.conflictResolver.resolveConflict_Reject(resourceId, symphonyName, currentOwner);
          return { ...rejectResult, strategy: "REJECT" };
        case "QUEUE":
          const queueResult = this.conflictResolver.resolveConflict_Queue(sequenceRequest, resourceId, currentOwner);
          return { ...queueResult, strategy: "QUEUE" };
        case "INTERRUPT":
          const interruptResult = this.conflictResolver.resolveConflict_Interrupt(resourceId, symphonyName, instanceId, priority, sequenceExecutionId, currentOwner, this);
          return { ...interruptResult, strategy: "INTERRUPT" };
        default:
          return {
            success: false,
            message: `Unknown resolution strategy: ${conflictResult.resolution}`,
            strategy: "UNKNOWN"
          };
      }
    }
    /**
     * Get resource ownership information
     * @returns Resource ownership map
     */
    getResourceOwnership() {
      return this.ownershipTracker.getAllResourceOwners();
    }
    /**
     * Get symphony resource mapping
     * @returns Symphony to resources mapping
     */
    getSymphonyResourceMap() {
      return this.ownershipTracker.getSymphonyResourceMap();
    }
    /**
     * Get sequence instances
     * @returns Sequence instances map
     */
    getSequenceInstances() {
      return this.ownershipTracker.getSequenceInstances();
    }
    /**
     * Get resource statistics
     * @returns Resource usage statistics
     */
    getResourceStatistics() {
      return this.ownershipTracker.getStatistics();
    }
    /**
     * Get resource ownership tracker (for internal use)
     * @returns ResourceOwnershipTracker instance
     */
    getResourceOwnershipTracker() {
      return this.ownershipTracker;
    }
    /**
     * Reset all resource ownership (for testing)
     */
    reset() {
      this.ownershipTracker.reset();
      console.log("\u{1F9F9} ResourceManager: All resource ownership reset");
    }
  };

  // dist/modules/communication/sequences/resources/ResourceDelegator.js
  var ResourceDelegator = class {
    constructor(resourceManager) {
      this.resourceManager = resourceManager;
    }
    /**
     * Check for resource conflicts
     * @param resourceId - Resource ID to check
     * @param requesterId - ID of the requester
     * @param priority - Request priority
     * @returns Conflict check result
     */
    checkResourceConflict(resourceId, requesterId, priority = "NORMAL") {
      try {
        const result = this.resourceManager.checkResourceConflict(resourceId, requesterId, priority, requesterId);
        return {
          hasConflict: result.hasConflict,
          conflictingResource: resourceId,
          conflictType: result.hasConflict ? "ownership" : void 0,
          resolution: result.resolution === "ALLOW" ? "override" : result.resolution === "REJECT" ? "reject" : result.resolution === "QUEUE" ? "queue" : "queue",
          reason: result.message
        };
      } catch (error) {
        console.error("\u{1F534} ResourceDelegator: Error checking resource conflict:", error);
        return {
          hasConflict: true,
          conflictType: "access",
          resolution: "reject",
          reason: `Error checking resource conflict: ${error.message}`
        };
      }
    }
    /**
     * Determine the type of resource conflict
     * @param resourceId - Resource ID
     * @param currentOwner - Current owner ID
     * @param requesterId - Requester ID
     * @returns Conflict type
     */
    determineConflictType(resourceId, currentOwner, requesterId) {
      if (this.hasTimingConflict(resourceId, requesterId)) {
        return "timing";
      }
      if (this.hasDependencyConflict(resourceId, currentOwner, requesterId)) {
        return "dependency";
      }
      if (this.hasAccessConflict(resourceId, currentOwner, requesterId)) {
        return "access";
      }
      return "ownership";
    }
    /**
     * Check for timing conflicts
     * @param resourceId - Resource ID
     * @param requesterId - Requester ID
     * @returns True if timing conflict exists
     */
    hasTimingConflict(resourceId, requesterId) {
      return false;
    }
    /**
     * Check for dependency conflicts
     * @param resourceId - Resource ID
     * @param currentOwner - Current owner ID
     * @param requesterId - Requester ID
     * @returns True if dependency conflict exists
     */
    hasDependencyConflict(resourceId, currentOwner, requesterId) {
      return false;
    }
    /**
     * Check for access level conflicts
     * @param resourceId - Resource ID
     * @param currentOwner - Current owner ID
     * @param requesterId - Requester ID
     * @returns True if access conflict exists
     */
    hasAccessConflict(resourceId, currentOwner, requesterId) {
      return false;
    }
    /**
     * Determine resolution strategy for conflict
     * @param conflictType - Type of conflict
     * @param priority - Request priority
     * @returns Resolution strategy
     */
    determineResolutionStrategy(conflictType, priority) {
      switch (conflictType) {
        case "timing":
          return "queue";
        // Queue rapid requests
        case "dependency":
          return "queue";
        // Wait for dependencies to be released
        case "access":
          return "reject";
        // Reject insufficient access
        case "ownership":
          return priority === "IMMEDIATE" ? "override" : "queue";
        default:
          return "queue";
      }
    }
    /**
     * Acquire resource ownership
     * @param resourceId - Resource ID to acquire
     * @param ownerId - ID of the owner
     * @param priority - Request priority
     * @returns Ownership result
     */
    acquireResourceOwnership(resourceId, ownerId, priority = "NORMAL") {
      try {
        const conflictResult = this.checkResourceConflict(resourceId, ownerId, priority);
        if (conflictResult.hasConflict && conflictResult.resolution === "reject") {
          return {
            acquired: false,
            resourceId,
            ownerId,
            reason: conflictResult.reason
          };
        }
        const acquired = this.resourceManager.acquireResourceOwnership(resourceId, ownerId, ownerId, priority, ownerId);
        if (acquired) {
          const expirationTime = this.calculateExpirationTime(priority);
          return {
            acquired: true,
            resourceId,
            ownerId,
            expiresAt: expirationTime,
            reason: "Resource acquired successfully"
          };
        } else {
          return {
            acquired: false,
            resourceId,
            ownerId,
            reason: "Failed to acquire resource"
          };
        }
      } catch (error) {
        console.error("\u{1F534} ResourceDelegator: Error acquiring resource ownership:", error);
        return {
          acquired: false,
          resourceId,
          ownerId,
          reason: `Error acquiring resource: ${error.message}`
        };
      }
    }
    /**
     * Calculate resource expiration time based on priority
     * @param priority - Request priority
     * @returns Expiration timestamp
     */
    calculateExpirationTime(priority) {
      const baseTime = Date.now();
      const expirationDelays = {
        IMMEDIATE: 3e4,
        // 30 seconds
        HIGH: 6e4,
        // 1 minute
        NORMAL: 3e5,
        // 5 minutes
        LOW: 6e5,
        // 10 minutes
        BACKGROUND: 18e5
        // 30 minutes
      };
      const delay = expirationDelays[priority] || expirationDelays.NORMAL;
      return baseTime + delay;
    }
    /**
     * Release resource ownership
     * @param resourceId - Resource ID to release
     * @param ownerId - ID of the owner
     * @returns True if released successfully
     */
    releaseResourceOwnership(resourceId, ownerId) {
      try {
        this.resourceManager.releaseResourceOwnership(resourceId, ownerId);
        console.log(`\u2705 ResourceDelegator: Released resource ${resourceId} from ${ownerId}`);
        return true;
      } catch (error) {
        console.error("\u{1F534} ResourceDelegator: Error releasing resource ownership:", error);
        return false;
      }
    }
    /**
     * Resolve advanced resource conflicts
     * @param resourceId - Resource ID with conflict
     * @param requesterId - ID of the requester
     * @param priority - Request priority
     * @returns Advanced conflict resolution
     */
    resolveResourceConflictAdvanced(resourceId, requesterId, priority = "NORMAL") {
      const conflictResult = this.checkResourceConflict(resourceId, requesterId, priority);
      if (!conflictResult.hasConflict) {
        return {
          strategy: "priority-based",
          action: "allow",
          details: {
            originalResourceId: resourceId,
            resolvedResourceId: resourceId
          }
        };
      }
      switch (conflictResult.conflictType) {
        case "timing":
          return this.resolveTimingConflict(resourceId, requesterId, priority);
        case "dependency":
          return this.resolveDependencyConflict(resourceId, requesterId, priority);
        case "access":
          return this.resolveAccessConflict(resourceId, requesterId, priority);
        case "ownership":
        default:
          return this.resolveOwnershipConflict(resourceId, requesterId, priority);
      }
    }
    /**
     * Resolve timing conflicts
     */
    resolveTimingConflict(resourceId, requesterId, priority) {
      return {
        strategy: "time-based",
        action: "queue",
        details: {
          originalResourceId: resourceId,
          queuePosition: 1,
          // Simplified queue position
          estimatedWaitTime: 1e3
          // 1 second for timing conflicts
        }
      };
    }
    /**
     * Resolve dependency conflicts
     */
    resolveDependencyConflict(resourceId, requesterId, priority) {
      const alternativeResources = [];
      return {
        strategy: "resource-sharing",
        action: alternativeResources.length > 0 ? "modify" : "queue",
        details: {
          originalResourceId: resourceId,
          alternativeResources,
          estimatedWaitTime: alternativeResources.length > 0 ? 0 : 5e3
        }
      };
    }
    /**
     * Resolve access conflicts
     */
    resolveAccessConflict(resourceId, requesterId, priority) {
      return {
        strategy: "priority-based",
        action: "reject",
        details: {
          originalResourceId: resourceId
        }
      };
    }
    /**
     * Resolve ownership conflicts
     */
    resolveOwnershipConflict(resourceId, requesterId, priority) {
      const action = priority === "IMMEDIATE" ? "allow" : "queue";
      return {
        strategy: "priority-based",
        action,
        details: {
          originalResourceId: resourceId,
          resolvedResourceId: resourceId,
          queuePosition: action === "queue" ? 1 : void 0,
          // Simplified queue position
          estimatedWaitTime: action === "queue" ? 1e4 : 0
          // 10 seconds for ownership conflicts
        }
      };
    }
    /**
     * Get debug information
     * @returns Debug resource delegation information
     */
    getDebugInfo() {
      return {
        conflictsResolved: 0,
        resourcesAcquired: 0,
        resourcesReleased: 0,
        activeConflicts: 0
      };
    }
  };

  // dist/modules/communication/sequences/monitoring/StatisticsManager.js
  var StatisticsManager = class {
    constructor() {
      this.statistics = {
        totalSequencesExecuted: 0,
        totalBeatsExecuted: 0,
        averageExecutionTime: 0,
        totalSequencesQueued: 0,
        currentQueueLength: 0,
        maxQueueLength: 0,
        averageQueueWaitTime: 0,
        errorCount: 0,
        successRate: 0,
        lastExecutionTime: null,
        sequenceCompletionRate: 0,
        chainedSequences: 0
      };
    }
    /**
     * Record a sequence execution
     * @param executionTime - Execution time in milliseconds
     */
    recordSequenceExecution(executionTime) {
      this.statistics.totalSequencesExecuted++;
      const alpha = 0.1;
      this.statistics.averageExecutionTime = this.statistics.averageExecutionTime * (1 - alpha) + executionTime * alpha;
      this.updateSuccessRate();
      console.log(`\u{1F4CA} StatisticsManager: Recorded sequence execution (${executionTime.toFixed(2)}ms)`);
    }
    /**
     * Record a beat execution
     */
    recordBeatExecution() {
      this.statistics.totalBeatsExecuted++;
    }
    /**
     * Record an error occurrence
     */
    recordError() {
      this.statistics.errorCount++;
      this.updateSuccessRate();
      console.warn("\u{1F4CA} StatisticsManager: Recorded error occurrence");
    }
    /**
     * Record a sequence being queued
     */
    recordSequenceQueued() {
      this.statistics.totalSequencesQueued++;
      this.statistics.currentQueueLength++;
      this.statistics.maxQueueLength = Math.max(this.statistics.maxQueueLength, this.statistics.currentQueueLength);
    }
    /**
     * Record a sequence being dequeued
     */
    recordSequenceDequeued() {
      if (this.statistics.currentQueueLength > 0) {
        this.statistics.currentQueueLength--;
      }
    }
    /**
     * Update queue wait time statistics
     * @param waitTime - Wait time in milliseconds
     */
    updateQueueWaitTime(waitTime) {
      const alpha = 0.1;
      this.statistics.averageQueueWaitTime = this.statistics.averageQueueWaitTime * (1 - alpha) + waitTime * alpha;
    }
    /**
     * Update success rate calculation
     */
    updateSuccessRate() {
      const totalAttempts = this.statistics.totalSequencesExecuted + this.statistics.errorCount;
      if (totalAttempts > 0) {
        this.statistics.successRate = this.statistics.totalSequencesExecuted / totalAttempts * 100;
      } else {
        this.statistics.successRate = 100;
      }
    }
    /**
     * Get current statistics
     * @returns Current conductor statistics
     */
    getStatistics() {
      return { ...this.statistics };
    }
    /**
     * Get enhanced statistics with additional metrics
     * @param mountedPlugins - Number of mounted plugins
     * @returns Enhanced statistics
     */
    getEnhancedStatistics(mountedPlugins) {
      return {
        ...this.statistics,
        mountedPlugins
      };
    }
    /**
     * Reset all statistics
     */
    reset() {
      this.statistics = {
        totalSequencesExecuted: 0,
        totalBeatsExecuted: 0,
        averageExecutionTime: 0,
        totalSequencesQueued: 0,
        currentQueueLength: 0,
        maxQueueLength: 0,
        averageQueueWaitTime: 0,
        errorCount: 0,
        successRate: 0,
        lastExecutionTime: null,
        sequenceCompletionRate: 0,
        chainedSequences: 0
      };
      console.log("\u{1F9F9} StatisticsManager: All statistics reset");
    }
    /**
     * Get performance summary
     * @returns Performance summary object
     */
    getPerformanceSummary() {
      const totalAttempts = this.statistics.totalSequencesExecuted + this.statistics.errorCount;
      const errorRate = totalAttempts > 0 ? this.statistics.errorCount / totalAttempts * 100 : 0;
      return {
        executionEfficiency: this.statistics.successRate,
        queueEfficiency: this.statistics.averageQueueWaitTime > 0 ? Math.max(0, 100 - this.statistics.averageQueueWaitTime / 1e3) : 100,
        errorRate,
        throughput: this.statistics.averageExecutionTime > 0 ? 1e3 / this.statistics.averageExecutionTime : 0
        // sequences per second
      };
    }
    /**
     * Get queue analytics
     * @returns Queue performance analytics
     */
    getQueueAnalytics() {
      return {
        currentLoad: this.statistics.currentQueueLength,
        maxLoadReached: this.statistics.maxQueueLength,
        averageWaitTime: this.statistics.averageQueueWaitTime,
        totalProcessed: this.statistics.totalSequencesQueued
      };
    }
    /**
     * Check if performance thresholds are exceeded
     * @returns Performance warnings
     */
    getPerformanceWarnings() {
      const warnings = [];
      if (this.statistics.averageExecutionTime > 5e3) {
        warnings.push("High average execution time (>5s)");
      }
      if (this.statistics.averageQueueWaitTime > 1e4) {
        warnings.push("High average queue wait time (>10s)");
      }
      if (this.statistics.successRate < 95) {
        warnings.push("Low success rate (<95%)");
      }
      if (this.statistics.currentQueueLength > 10) {
        warnings.push("High current queue length (>10)");
      }
      if (this.statistics.errorCount > 100) {
        warnings.push("High error count (>100)");
      }
      return warnings;
    }
    /**
     * Export statistics for external monitoring
     * @returns Statistics in monitoring format
     */
    exportForMonitoring() {
      return {
        "conductor.sequences.executed": this.statistics.totalSequencesExecuted,
        "conductor.beats.executed": this.statistics.totalBeatsExecuted,
        "conductor.execution.avg_time_ms": this.statistics.averageExecutionTime,
        "conductor.queue.length": this.statistics.currentQueueLength,
        "conductor.queue.max_length": this.statistics.maxQueueLength,
        "conductor.queue.avg_wait_time_ms": this.statistics.averageQueueWaitTime,
        "conductor.errors.count": this.statistics.errorCount,
        "conductor.success.rate_percent": this.statistics.successRate
      };
    }
    /**
     * Get debug information
     * @returns Debug statistics information
     */
    getDebugInfo() {
      return {
        statistics: this.getStatistics(),
        performanceSummary: this.getPerformanceSummary(),
        queueAnalytics: this.getQueueAnalytics(),
        warnings: this.getPerformanceWarnings()
      };
    }
  };

  // dist/modules/communication/sequences/monitoring/PerformanceTracker.js
  var PerformanceTracker = class {
    constructor() {
      this.beatStartTimes = /* @__PURE__ */ new Map();
      this.sequenceTimings = /* @__PURE__ */ new Map();
      this.movementStartTimes = /* @__PURE__ */ new Map();
      this.completedBeats = [];
      this.completedMovements = [];
      this.maxHistorySize = 1e3;
    }
    /**
     * Start tracking a beat execution
     * @param sequenceName - Sequence name
     * @param beat - Beat number
     * @returns Beat key for tracking
     */
    startBeatTiming(sequenceName, beat) {
      const beatKey = `${sequenceName}-${beat}`;
      const startTime = performance.now();
      this.beatStartTimes.set(beatKey, startTime);
      console.log(`\u23F1\uFE0F PerformanceTracker: Started timing beat ${beat} for ${sequenceName}`);
      return beatKey;
    }
    /**
     * End tracking a beat execution
     * @param sequenceName - Sequence name
     * @param beat - Beat number
     * @returns Beat duration in milliseconds
     */
    endBeatTiming(sequenceName, beat) {
      const beatKey = `${sequenceName}-${beat}`;
      const startTime = this.beatStartTimes.get(beatKey);
      if (!startTime) {
        console.warn(`\u23F1\uFE0F PerformanceTracker: No start time found for beat ${beat} in ${sequenceName}`);
        return null;
      }
      const endTime = performance.now();
      const duration = endTime - startTime;
      const beatTiming = {
        sequenceName,
        beat,
        startTime,
        endTime,
        duration
      };
      this.completedBeats.push(beatTiming);
      this.beatStartTimes.delete(beatKey);
      if (this.completedBeats.length > this.maxHistorySize) {
        this.completedBeats = this.completedBeats.slice(-this.maxHistorySize / 2);
      }
      console.log(`\u23F1\uFE0F PerformanceTracker: Beat ${beat} completed in ${duration.toFixed(2)}ms`);
      return duration;
    }
    /**
     * Clean up timing data for a failed beat
     * @param sequenceName - Sequence name
     * @param beat - Beat number
     */
    cleanupFailedBeat(sequenceName, beat) {
      const beatKey = `${sequenceName}-${beat}`;
      this.beatStartTimes.delete(beatKey);
      console.warn(`\u23F1\uFE0F PerformanceTracker: Cleaned up failed beat ${beat} for ${sequenceName}`);
    }
    /**
     * Start tracking a movement execution
     * @param sequenceName - Sequence name
     * @param movementName - Movement name
     * @param requestId - Request identifier
     * @returns Movement key for tracking
     */
    startMovementTiming(sequenceName, movementName, requestId) {
      const movementKey = `${sequenceName}-${movementName}-${requestId}`;
      const startTime = performance.now();
      this.movementStartTimes.set(movementKey, startTime);
      console.log(`\u23F1\uFE0F PerformanceTracker: Started timing movement ${movementName} for ${sequenceName}`);
      return movementKey;
    }
    /**
     * End tracking a movement execution
     * @param sequenceName - Sequence name
     * @param movementName - Movement name
     * @param requestId - Request identifier
     * @param beatsCount - Number of beats executed in the movement
     * @returns Movement duration in milliseconds
     */
    endMovementTiming(sequenceName, movementName, requestId, beatsCount) {
      const movementKey = `${sequenceName}-${movementName}-${requestId}`;
      const startTime = this.movementStartTimes.get(movementKey);
      if (!startTime) {
        console.warn(`\u23F1\uFE0F PerformanceTracker: No start time found for movement ${movementName} in ${sequenceName}`);
        return null;
      }
      const endTime = performance.now();
      const duration = endTime - startTime;
      const movementTiming = {
        sequenceName,
        movementName,
        requestId,
        startTime,
        endTime,
        duration,
        beatsCount
      };
      this.completedMovements.push(movementTiming);
      this.movementStartTimes.delete(movementKey);
      if (this.completedMovements.length > this.maxHistorySize) {
        this.completedMovements = this.completedMovements.slice(-this.maxHistorySize / 2);
      }
      console.log(`\u23F1\uFE0F PerformanceTracker: Movement ${movementName} completed in ${duration.toFixed(2)}ms`);
      return duration;
    }
    /**
     * Clean up timing data for a failed movement
     * @param sequenceName - Sequence name
     * @param movementName - Movement name
     * @param requestId - Request identifier
     */
    cleanupFailedMovement(sequenceName, movementName, requestId) {
      const movementKey = `${sequenceName}-${movementName}-${requestId}`;
      this.movementStartTimes.delete(movementKey);
      console.warn(`\u23F1\uFE0F PerformanceTracker: Cleaned up failed movement ${movementName} for ${sequenceName}`);
    }
    /**
     * Start tracking a sequence execution
     * @param sequenceName - Sequence name
     * @param executionId - Execution identifier
     */
    startSequenceTiming(sequenceName, executionId) {
      const startTime = performance.now();
      this.sequenceTimings.set(executionId, {
        sequenceName,
        startTime,
        beatCount: 0
      });
      console.log(`\u23F1\uFE0F PerformanceTracker: Started timing sequence ${sequenceName} (${executionId})`);
    }
    /**
     * End tracking a sequence execution
     * @param executionId - Execution identifier
     * @returns Sequence duration in milliseconds
     */
    endSequenceTiming(executionId) {
      const timing = this.sequenceTimings.get(executionId);
      if (!timing) {
        console.warn(`\u23F1\uFE0F PerformanceTracker: No timing found for execution ${executionId}`);
        return null;
      }
      const endTime = performance.now();
      const duration = endTime - timing.startTime;
      timing.endTime = endTime;
      timing.duration = duration;
      console.log(`\u23F1\uFE0F PerformanceTracker: Sequence ${timing.sequenceName} completed in ${duration.toFixed(2)}ms`);
      this.sequenceTimings.delete(executionId);
      return duration;
    }
    /**
     * Increment beat count for a sequence
     * @param executionId - Execution identifier
     */
    incrementBeatCount(executionId) {
      const timing = this.sequenceTimings.get(executionId);
      if (timing) {
        timing.beatCount++;
      }
    }
    /**
     * Get current beat timing information
     * @param sequenceName - Sequence name
     * @param beat - Beat number
     * @returns Current timing info or null
     */
    getCurrentBeatTiming(sequenceName, beat) {
      const beatKey = `${sequenceName}-${beat}`;
      const startTime = this.beatStartTimes.get(beatKey);
      if (!startTime) {
        return null;
      }
      return {
        startTime,
        elapsed: performance.now() - startTime
      };
    }
    /**
     * Get beat performance statistics
     * @param sequenceName - Optional sequence name filter
     * @returns Beat performance statistics
     */
    getBeatStatistics(sequenceName) {
      const filteredBeats = sequenceName ? this.completedBeats.filter((b) => b.sequenceName === sequenceName) : this.completedBeats;
      if (filteredBeats.length === 0) {
        return {
          totalBeats: 0,
          averageDuration: 0,
          minDuration: 0,
          maxDuration: 0,
          recentBeats: []
        };
      }
      const durations = filteredBeats.map((b) => b.duration).filter((d) => d !== void 0);
      const averageDuration = durations.reduce((sum, d) => sum + d, 0) / durations.length;
      const minDuration = Math.min(...durations);
      const maxDuration = Math.max(...durations);
      return {
        totalBeats: filteredBeats.length,
        averageDuration,
        minDuration,
        maxDuration,
        recentBeats: filteredBeats.slice(-10)
        // Last 10 beats
      };
    }
    /**
     * Get movement performance statistics
     * @param sequenceName - Optional sequence name filter
     * @returns Movement performance statistics
     */
    getMovementTimings(sequenceName) {
      const filteredMovements = sequenceName ? this.completedMovements.filter((m) => m.sequenceName === sequenceName) : this.completedMovements;
      return filteredMovements.slice();
    }
    /**
     * Get active timing information
     * @returns Currently active timings
     */
    getActiveTimings() {
      const now = performance.now();
      const activeBeats = Array.from(this.beatStartTimes.entries()).map(([key, startTime]) => ({
        key,
        elapsed: now - startTime
      }));
      const activeSequences = Array.from(this.sequenceTimings.entries()).map(([executionId, timing]) => ({
        executionId,
        sequenceName: timing.sequenceName,
        elapsed: now - timing.startTime
      }));
      const activeMovements = Array.from(this.movementStartTimes.entries()).map(([key, startTime]) => ({
        key,
        elapsed: now - startTime
      }));
      return {
        activeBeats,
        activeSequences,
        activeMovements
      };
    }
    /**
     * Get performance warnings for long-running operations
     * @param beatThreshold - Beat duration threshold in ms (default: 5000)
     * @param sequenceThreshold - Sequence duration threshold in ms (default: 30000)
     * @returns Performance warnings
     */
    getPerformanceWarnings(beatThreshold = 5e3, sequenceThreshold = 3e4) {
      const warnings = [];
      const now = performance.now();
      for (const [beatKey, startTime] of this.beatStartTimes.entries()) {
        const elapsed = now - startTime;
        if (elapsed > beatThreshold) {
          warnings.push(`Long-running beat: ${beatKey} (${elapsed.toFixed(0)}ms)`);
        }
      }
      for (const [executionId, timing] of this.sequenceTimings.entries()) {
        const elapsed = now - timing.startTime;
        if (elapsed > sequenceThreshold) {
          warnings.push(`Long-running sequence: ${timing.sequenceName} (${elapsed.toFixed(0)}ms)`);
        }
      }
      return warnings;
    }
    /**
     * Reset all performance tracking data
     */
    reset() {
      this.beatStartTimes.clear();
      this.sequenceTimings.clear();
      this.movementStartTimes.clear();
      this.completedBeats = [];
      this.completedMovements = [];
      console.log("\u{1F9F9} PerformanceTracker: All tracking data reset");
    }
    /**
     * Get debug information
     * @returns Debug performance information
     */
    getDebugInfo() {
      return {
        activeBeats: this.beatStartTimes.size,
        activeSequences: this.sequenceTimings.size,
        completedBeatsHistory: this.completedBeats.length,
        beatStatistics: this.getBeatStatistics(),
        warnings: this.getPerformanceWarnings()
      };
    }
  };

  // dist/modules/communication/sequences/monitoring/DuplicationDetector.js
  var DuplicationDetector = class {
    constructor(config) {
      this.executedSequenceHashes = /* @__PURE__ */ new Set();
      this.recentExecutions = /* @__PURE__ */ new Map();
      this.config = {
        idempotencyWindow: 5e3,
        // 5 second window for duplicate detection
        maxHashSetSize: 1e3,
        // Maximum size to prevent memory leaks
        strictModeThreshold: 100,
        // 100ms threshold for StrictMode detection
        ...config
      };
    }
    /**
     * Check if a sequence request is a duplicate
     * @param sequenceHash - Hash of the sequence request
     * @returns Duplication analysis result
     */
    isDuplicateSequenceRequest(sequenceHash) {
      const now = performance.now();
      const lastExecution = this.recentExecutions.get(sequenceHash);
      if (!lastExecution) {
        return {
          isDuplicate: false,
          timeSinceLastExecution: 0,
          reason: "First execution of this sequence"
        };
      }
      const timeSinceLastExecution = now - lastExecution;
      const isDuplicate = timeSinceLastExecution < this.config.idempotencyWindow;
      if (isDuplicate) {
        const isStrictMode = timeSinceLastExecution < this.config.strictModeThreshold;
        return {
          isDuplicate: true,
          timeSinceLastExecution,
          reason: isStrictMode ? `React StrictMode duplicate detected (${timeSinceLastExecution.toFixed(0)}ms since last)` : `Duplicate within idempotency window (${timeSinceLastExecution.toFixed(0)}ms since last)`,
          isStrictMode
        };
      }
      return {
        isDuplicate: false,
        timeSinceLastExecution,
        reason: `Outside idempotency window (${timeSinceLastExecution.toFixed(0)}ms since last)`
      };
    }
    /**
     * Record a sequence execution
     * @param sequenceHash - Hash of the sequence request
     */
    recordSequenceExecution(sequenceHash) {
      const now = performance.now();
      this.recentExecutions.set(sequenceHash, now);
      this.executedSequenceHashes.add(sequenceHash);
      this.cleanupOldExecutionRecords();
      console.log(`\u{1F50D} DuplicationDetector: Recorded execution of sequence hash: ${sequenceHash.substring(0, 8)}...`);
    }
    /**
     * Check if data indicates a StrictMode duplicate
     * @param data - Sequence data to analyze
     * @returns True if likely StrictMode duplicate
     */
    isStrictModeDuplicate(data) {
      const now = performance.now();
      if (data.timestamp && typeof data.timestamp === "number") {
        const timeDiff = now - data.timestamp;
        if (timeDiff < this.config.strictModeThreshold) {
          console.warn(`\u{1F50D} DuplicationDetector: StrictMode duplicate detected - rapid succession (${timeDiff.toFixed(0)}ms)`);
          return true;
        }
      }
      if (data._reactInternalFiber || data._reactInternalInstance) {
        console.warn("\u{1F50D} DuplicationDetector: StrictMode duplicate detected - React internal properties");
        return true;
      }
      if (typeof process !== "undefined" && true) {
        return false;
      }
      return false;
    }
    /**
     * Generate a hash for sequence request data
     * @param sequenceName - Sequence name
     * @param data - Sequence data
     * @returns Hash string
     */
    generateSequenceHash(sequenceName, data) {
      try {
        const dataString = JSON.stringify(data, Object.keys(data).sort());
        const combined = `${sequenceName}:${dataString}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
          const char = combined.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash;
        }
        return hash.toString(36);
      } catch (error) {
        console.warn("\u{1F50D} DuplicationDetector: Failed to generate hash, using fallback:", error);
        return `${sequenceName}-${Date.now()}-${Math.random()}`;
      }
    }
    /**
     * Clean up old execution records to prevent memory leaks
     */
    cleanupOldExecutionRecords() {
      const now = performance.now();
      const cutoffTime = now - this.config.idempotencyWindow;
      for (const [hash, timestamp] of this.recentExecutions.entries()) {
        if (timestamp < cutoffTime) {
          this.recentExecutions.delete(hash);
        }
      }
      if (this.executedSequenceHashes.size > this.config.maxHashSetSize) {
        const hashArray = Array.from(this.executedSequenceHashes);
        const toKeep = hashArray.slice(-this.config.maxHashSetSize / 2);
        this.executedSequenceHashes = new Set(toKeep);
        console.log(`\u{1F9F9} DuplicationDetector: Cleaned up hash set, kept ${toKeep.length} most recent entries`);
      }
    }
    /**
     * Get duplication statistics
     * @returns Duplication detection statistics
     */
    getStatistics() {
      const now = performance.now();
      const timestamps = Array.from(this.recentExecutions.values());
      return {
        totalHashesTracked: this.executedSequenceHashes.size,
        recentExecutionsTracked: this.recentExecutions.size,
        oldestRecentExecution: timestamps.length > 0 ? Math.min(...timestamps) : null,
        newestRecentExecution: timestamps.length > 0 ? Math.max(...timestamps) : null,
        memoryUsageEstimate: this.estimateMemoryUsage()
      };
    }
    /**
     * Estimate memory usage of the detector
     * @returns Estimated memory usage in bytes
     */
    estimateMemoryUsage() {
      const hashSetSize = this.executedSequenceHashes.size * 50;
      const recentExecutionsSize = this.recentExecutions.size * 60;
      return hashSetSize + recentExecutionsSize;
    }
    /**
     * Update configuration
     * @param newConfig - New configuration values
     */
    updateConfig(newConfig) {
      this.config = { ...this.config, ...newConfig };
      console.log("\u{1F50D} DuplicationDetector: Configuration updated:", this.config);
    }
    /**
     * Get current configuration
     * @returns Current configuration
     */
    getConfig() {
      return { ...this.config };
    }
    /**
     * Check if a hash has been executed before
     * @param sequenceHash - Hash to check
     * @returns True if hash has been executed
     */
    hasBeenExecuted(sequenceHash) {
      return this.executedSequenceHashes.has(sequenceHash);
    }
    /**
     * Get recent execution history
     * @param limit - Maximum number of entries to return
     * @returns Recent execution history
     */
    getRecentExecutions(limit = 10) {
      const now = performance.now();
      return Array.from(this.recentExecutions.entries()).map(([hash, timestamp]) => ({
        hash: hash.substring(0, 8) + "...",
        // Truncate for privacy
        timestamp,
        age: now - timestamp
      })).sort((a, b) => b.timestamp - a.timestamp).slice(0, limit);
    }
    /**
     * Reset all duplication detection data
     */
    reset() {
      this.executedSequenceHashes.clear();
      this.recentExecutions.clear();
      console.log("\u{1F9F9} DuplicationDetector: All detection data reset");
    }
    /**
     * Get debug information
     * @returns Debug information about duplication detection
     */
    getDebugInfo() {
      return {
        config: this.getConfig(),
        statistics: this.getStatistics(),
        recentExecutions: this.getRecentExecutions(20)
      };
    }
  };

  // dist/modules/communication/sequences/monitoring/EventLogger.js
  init_SequenceTypes();
  var EventLogger = class {
    constructor(eventBus2, performanceTracker, config) {
      this.beatLoggingInitialized = false;
      this.eventSubscriptions = [];
      this.eventBus = eventBus2;
      this.performanceTracker = performanceTracker;
      this.config = {
        enableHierarchicalLogging: true,
        enableEventEmission: true,
        logLevel: "info",
        ...config
      };
    }
    /**
     * Setup beat execution logging with hierarchical format
     */
    setupBeatExecutionLogging() {
      if (this.beatLoggingInitialized) {
        return;
      }
      if (!this.config.enableHierarchicalLogging) {
        console.log("\u{1F3BC} EventLogger: Hierarchical logging disabled");
        return;
      }
      const beatStartedUnsubscribe = this.eventBus.subscribe(MUSICAL_CONDUCTOR_EVENT_TYPES.BEAT_STARTED, (data) => this.logBeatStartedHierarchical(data), this);
      const beatCompletedUnsubscribe = this.eventBus.subscribe(MUSICAL_CONDUCTOR_EVENT_TYPES.BEAT_COMPLETED, (data) => this.logBeatCompletedHierarchical(data), this);
      this.eventSubscriptions.push(beatStartedUnsubscribe, beatCompletedUnsubscribe);
      this.beatLoggingInitialized = true;
      console.log("\u{1F3BC} EventLogger: Hierarchical beat logging initialized");
    }
    /**
     * Setup movement execution logging with hierarchical format
     */
    setupMovementExecutionLogging() {
      if (!this.config.enableHierarchicalLogging) {
        console.log("\u{1F3BC} EventLogger: Movement hierarchical logging disabled");
        return;
      }
      const movementStartedUnsubscribe = this.eventBus.subscribe(MUSICAL_CONDUCTOR_EVENT_TYPES.MOVEMENT_STARTED, (data) => this.logMovementStartedHierarchical(data), this);
      const movementCompletedUnsubscribe = this.eventBus.subscribe(MUSICAL_CONDUCTOR_EVENT_TYPES.MOVEMENT_COMPLETED, (data) => this.logMovementCompletedHierarchical(data), this);
      const movementFailedUnsubscribe = this.eventBus.subscribe(MUSICAL_CONDUCTOR_EVENT_TYPES.MOVEMENT_FAILED, (data) => this.logMovementFailedHierarchical(data), this);
      this.eventSubscriptions.push(movementStartedUnsubscribe, movementCompletedUnsubscribe, movementFailedUnsubscribe);
      console.log("\u{1F3BC} EventLogger: Hierarchical movement logging initialized");
    }
    /**
     * Log beat started event with hierarchical format
     * @param data - Beat started event data
     */
    logBeatStartedHierarchical(data) {
      this.performanceTracker.startBeatTiming(data.sequenceName, data.beat);
      const movementName = this.getMovementNameForBeat(data.sequenceName, data.beat);
      const groupLabel = `\u{1F3B5} Beat ${data.beat} Started: ${data.title || data.event} (${data.event})`;
      console.group(groupLabel);
      console.log(`%c\u{1F3BC} Sequence: ${data.sequenceName}`, "color: #007BFF; font-weight: bold;");
      console.log(`%c\u{1F3B5} Movement: ${movementName}`, "color: #6F42C1; font-weight: bold;");
      console.log(`%c\u{1F4CA} Beat: ${data.beat}`, "color: #FD7E14; font-weight: bold;");
      console.log(`%c\u{1F3AF} Event: ${data.event}`, "color: #20C997; font-weight: bold;");
      console.log({
        sequence: data.sequenceName,
        movement: movementName,
        beat: data.beat,
        type: data.sequenceType || "UNKNOWN",
        timing: data.timing || "immediate",
        dynamics: data.dynamics || "mf"
      });
    }
    /**
     * Log beat completed event with hierarchical format
     * @param data - Beat completed event data
     */
    logBeatCompletedHierarchical(data) {
      const duration = this.performanceTracker.endBeatTiming(data.sequenceName, data.beat);
      if (duration !== null) {
        console.log(`%c\u2705 Completed in ${duration.toFixed(2)}ms`, "color: #28A745; font-weight: bold;");
      } else {
        console.log(`%c\u2705 Completed`, "color: #28A745; font-weight: bold;");
      }
      console.groupEnd();
    }
    /**
     * Log movement started event with hierarchical format
     * @param data - Movement started event data
     */
    logMovementStartedHierarchical(data) {
      const groupLabel = `\u{1F3B5} Movement Started: ${data.movementName} (${data.beatsCount} beats)`;
      console.group(groupLabel);
      console.log(`%c\u{1F3BC} Sequence: ${data.sequenceName}`, "color: #007BFF; font-weight: bold;");
      console.log(`%c\u{1F194} Request ID: ${data.requestId}`, "color: #6C757D; font-weight: normal;");
      console.log(`%c\u{1F941} Beats Count: ${data.beatsCount}`, "color: #17A2B8; font-weight: bold;");
    }
    /**
     * Log movement completed event with hierarchical format
     * @param data - Movement completed event data
     */
    logMovementCompletedHierarchical(data) {
      if (data.duration !== null && data.duration !== void 0) {
        console.log(`%c\u2705 Movement completed in ${data.duration.toFixed(2)}ms`, "color: #28A745; font-weight: bold;");
      } else {
        console.log(`%c\u2705 Movement completed`, "color: #28A745; font-weight: bold;");
      }
      console.log(`%c\u{1F941} Beats executed: ${data.beatsExecuted}`, "color: #17A2B8; font-weight: normal;");
      console.groupEnd();
    }
    /**
     * Log movement failed event with hierarchical format
     * @param data - Movement failed event data
     */
    logMovementFailedHierarchical(data) {
      console.log(`%c\u274C Movement failed: ${data.error}`, "color: #DC3545; font-weight: bold;");
      console.groupEnd();
    }
    /**
     * Get movement name for a specific beat in a sequence
     * @param sequenceName - Name of the sequence
     * @param beatNumber - Beat number
     * @returns Movement name or "Unknown Movement"
     */
    getMovementNameForBeat(sequenceName, beatNumber) {
      return `Movement ${Math.ceil(beatNumber / 4)}`;
    }
    /**
     * Handle beat execution error with proper logging
     * @param executionContext - Sequence execution context
     * @param beat - Beat that failed
     * @param error - Error that occurred
     */
    handleBeatError(executionContext, beat, error) {
      this.emitEvent(MUSICAL_CONDUCTOR_EVENT_TYPES.BEAT_FAILED, {
        sequenceName: executionContext.sequenceName,
        beat: beat.beat,
        error: error.message,
        success: false
      });
      if (this.config.enableHierarchicalLogging) {
        console.log(`%c\u274C Error: ${error.message}`, "color: #DC3545; font-weight: bold;");
        console.groupEnd();
        this.performanceTracker.cleanupFailedBeat(executionContext.sequenceName, beat.beat);
      }
    }
    /**
     * Emit an event through the event bus
     * @param eventType - Type of event to emit
     * @param data - Event data
     */
    emitEvent(eventType, data) {
      if (!this.config.enableEventEmission) {
        return;
      }
      try {
        this.eventBus.emit(eventType, data);
        if (this.config.logLevel === "debug") {
          console.log(`\u{1F3BC} EventLogger: Emitted ${eventType}`, data);
        }
      } catch (error) {
        console.error(`\u{1F3BC} EventLogger: Failed to emit event ${eventType}:`, error);
      }
    }
    /**
     * Log sequence execution start
     * @param sequenceName - Name of the sequence
     * @param executionId - Execution identifier
     * @param data - Sequence data
     */
    logSequenceStart(sequenceName, executionId, data) {
      if (this.config.logLevel === "debug" || this.config.logLevel === "info") {
        console.log(`\u{1F3BC} EventLogger: Starting sequence ${sequenceName} (${executionId})`, data);
      }
      this.emitEvent(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_STARTED, {
        sequenceName,
        executionId,
        data,
        timestamp: Date.now()
      });
    }
    /**
     * Log sequence execution completion
     * @param sequenceName - Name of the sequence
     * @param executionId - Execution identifier
     * @param success - Whether execution was successful
     * @param duration - Execution duration in milliseconds
     */
    logSequenceComplete(sequenceName, executionId, success, duration) {
      const status = success ? "\u2705 completed" : "\u274C failed";
      const durationText = duration ? ` in ${duration.toFixed(2)}ms` : "";
      if (this.config.logLevel === "debug" || this.config.logLevel === "info") {
        console.log(`\u{1F3BC} EventLogger: Sequence ${sequenceName} ${status}${durationText}`);
      }
      this.emitEvent(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_COMPLETED, {
        sequenceName,
        executionId,
        success,
        duration,
        timestamp: Date.now()
      });
    }
    /**
     * Log queue operations
     * @param operation - Queue operation type
     * @param sequenceName - Sequence name
     * @param queueLength - Current queue length
     */
    logQueueOperation(operation, sequenceName, queueLength) {
      if (this.config.logLevel === "debug") {
        console.log(`\u{1F3BC} EventLogger: Queue ${operation} - ${sequenceName} (queue: ${queueLength})`);
      }
      this.emitEvent(MUSICAL_CONDUCTOR_EVENT_TYPES.QUEUE_PROCESSED, {
        operation,
        sequenceName,
        queueLength,
        timestamp: Date.now()
      });
    }
    /**
     * Update logging configuration
     * @param newConfig - New configuration values
     */
    updateConfig(newConfig) {
      this.config = { ...this.config, ...newConfig };
      console.log("\u{1F3BC} EventLogger: Configuration updated:", this.config);
    }
    /**
     * Get current configuration
     * @returns Current logging configuration
     */
    getConfig() {
      return { ...this.config };
    }
    /**
     * Cleanup event subscriptions
     */
    cleanup() {
      if (this.eventSubscriptions.length > 0) {
        this.eventSubscriptions.forEach((unsubscribe) => unsubscribe());
        this.eventSubscriptions = [];
        this.beatLoggingInitialized = false;
        console.log("\u{1F9F9} EventLogger: Event subscriptions cleaned up");
      }
    }
    /**
     * Get debug information
     * @returns Debug logging information
     */
    getDebugInfo() {
      return {
        config: this.getConfig(),
        beatLoggingInitialized: this.beatLoggingInitialized,
        activeSubscriptions: this.eventSubscriptions.length
      };
    }
  };

  // dist/modules/communication/sequences/validation/SequenceValidator.js
  init_SequenceTypes();
  var SequenceValidator = class {
    constructor(duplicationDetector) {
      this.duplicationDetector = duplicationDetector;
    }
    /**
     * Generate a hash for sequence request data
     * @param sequenceName - Name of the sequence
     * @param data - Sequence data
     * @param priority - Sequence priority
     * @returns Hash string
     */
    generateSequenceHash(sequenceName, data, priority) {
      try {
        const normalizedData = this.normalizeDataForHashing(data);
        const dataString = JSON.stringify(normalizedData, Object.keys(normalizedData).sort());
        const combined = `${sequenceName}:${priority}:${dataString}`;
        let hash = 0;
        for (let i = 0; i < combined.length; i++) {
          const char = combined.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash;
        }
        return hash.toString(36);
      } catch (error) {
        console.warn("\u{1F50D} SequenceValidator: Failed to generate hash, using fallback:", error);
        return `${sequenceName}-${priority}-${Date.now()}-${Math.random()}`;
      }
    }
    /**
     * Normalize data for consistent hashing
     * @param data - Raw sequence data
     * @returns Normalized data object
     */
    normalizeDataForHashing(data) {
      if (!data || typeof data !== "object") {
        return data;
      }
      const normalized = { ...data };
      delete normalized.timestamp;
      delete normalized._reactInternalFiber;
      delete normalized._reactInternalInstance;
      delete normalized.__reactInternalInstance;
      Object.keys(normalized).forEach((key) => {
        if (Array.isArray(normalized[key])) {
          normalized[key] = [...normalized[key]].sort();
        }
      });
      return normalized;
    }
    /**
     * Enhanced sequence deduplication for StrictMode protection
     * @param sequenceId - ID of the sequence
     * @param sequenceName - Name of the sequence
     * @param data - Sequence data
     * @param priority - Sequence priority
     * @returns Deduplication result
     */
    deduplicateSequenceRequest(sequenceId, sequenceName, data, priority) {
      const sequenceHash = this.generateSequenceHash(sequenceName, data, priority);
      if (sequenceName === "Element Library Display Symphony No. 12") {
        const isDuplicate2 = this.duplicationDetector.isDuplicateSequenceRequest(sequenceHash);
        if (isDuplicate2.isDuplicate) {
          const result = this.duplicationDetector.isDuplicateSequenceRequest(sequenceHash);
          console.log(`\u{1F3BC} SequenceValidator: ElementLibrary Display duplicate check - ${result.reason}`);
          console.log("\u{1F3BC} SequenceValidator: Allowing ElementLibrary Display sequence to execute (special handling)");
          return {
            isDuplicate: false,
            // Override duplicate detection for this sequence
            hash: sequenceHash,
            reason: "ElementLibrary Display sequence - special handling",
            shouldExecute: true
          };
        }
        return {
          isDuplicate: false,
          hash: sequenceHash,
          reason: "ElementLibrary Display sequence - first execution",
          shouldExecute: true
        };
      }
      const isDuplicate = this.duplicationDetector.isDuplicateSequenceRequest(sequenceHash);
      if (isDuplicate.isDuplicate) {
        return {
          isDuplicate: true,
          hash: sequenceHash,
          reason: isDuplicate.reason,
          shouldExecute: false
        };
      }
      return {
        isDuplicate: false,
        hash: sequenceHash,
        reason: "New sequence request",
        shouldExecute: true
      };
    }
    /**
     * Check if data indicates a StrictMode duplicate
     * @param data - Sequence data to analyze
     * @returns True if likely StrictMode duplicate
     */
    isStrictModeDuplicate(data) {
      return this.duplicationDetector.isStrictModeDuplicate(data);
    }
    /**
     * Validate sequence structure and data
     * @param sequenceName - Name of the sequence
     * @param data - Sequence data
     * @param priority - Sequence priority
     * @returns Validation result
     */
    validateSequenceRequest(sequenceName, data, priority) {
      const errors = [];
      const warnings = [];
      if (!sequenceName || typeof sequenceName !== "string") {
        errors.push("Sequence name must be a non-empty string");
      } else if (sequenceName.trim().length === 0) {
        errors.push("Sequence name cannot be empty or whitespace only");
      }
      if (!Object.values(SEQUENCE_PRIORITIES).includes(priority)) {
        errors.push(`Invalid priority: ${priority}. Must be one of: ${Object.values(SEQUENCE_PRIORITIES).join(", ")}`);
      }
      if (data !== null && data !== void 0 && typeof data === "object") {
        if (this.isStrictModeDuplicate(data)) {
          warnings.push("Potential React StrictMode duplicate detected");
        }
        try {
          JSON.stringify(data);
        } catch (error) {
          errors.push("Sequence data contains circular references");
        }
        const dataString = JSON.stringify(data);
        if (dataString.length > 1e5) {
          warnings.push("Sequence data is very large (>100KB), consider optimizing");
        }
      }
      if (sequenceName && !this.isValidSequenceNameFormat(sequenceName)) {
        warnings.push("Sequence name format may not follow recommended conventions");
      }
      return {
        isValid: errors.length === 0,
        errors,
        warnings
      };
    }
    /**
     * Check if sequence name follows recommended format
     * @param sequenceName - Sequence name to validate
     * @returns True if format is valid
     */
    isValidSequenceNameFormat(sequenceName) {
      const patterns = [
        /^.+\s+Symphony\s+No\.\s+\d+$/i,
        /^.+\s+Sequence\s+\d+$/i,
        /^.+\s+Movement\s+\d+$/i,
        /^[A-Za-z0-9\s\-_.]+$/
        // General alphanumeric with common separators
      ];
      return patterns.some((pattern) => pattern.test(sequenceName));
    }
    /**
     * Get validation statistics
     * @returns Validation statistics
     */
    getValidationStatistics() {
      return {
        totalValidations: 0,
        validSequences: 0,
        invalidSequences: 0,
        duplicatesDetected: 0,
        strictModeDuplicates: 0
      };
    }
    /**
     * Reset validation state
     */
    reset() {
      console.log("\u{1F9F9} SequenceValidator: Validation state reset");
    }
    /**
     * Get debug information
     * @returns Debug validation information
     */
    getDebugInfo() {
      return {
        validationStatistics: this.getValidationStatistics(),
        duplicationDetectorInfo: this.duplicationDetector.getDebugInfo()
      };
    }
  };

  // dist/modules/communication/sequences/utilities/SequenceUtilities.js
  var SequenceUtilities = class _SequenceUtilities {
    /**
     * Create a unique sequence instance ID
     * @param sequenceName - Name of the sequence
     * @param data - Sequence data
     * @param priority - Sequence priority
     * @returns Unique instance ID
     */
    createSequenceInstanceId(sequenceName, data, priority) {
      const timestamp = Date.now();
      const randomSuffix = Math.random().toString(36).substr(2, 9);
      const priorityCode = this.getPriorityCode(priority);
      return `${_SequenceUtilities.INSTANCE_ID_PREFIX}_${priorityCode}_${timestamp}_${randomSuffix}`;
    }
    /**
     * Get priority code for ID generation
     * @param priority - Sequence priority
     * @returns Priority code
     */
    getPriorityCode(priority) {
      switch (priority) {
        case "HIGH":
          return "HI";
        case "NORMAL":
          return "NOR";
        case "CHAINED":
          return "CH";
        default:
          return "UNK";
      }
    }
    /**
     * Extract symphony name from sequence name
     * @param sequenceName - Full sequence name
     * @returns Symphony name
     */
    extractSymphonyName(sequenceName) {
      const parts = sequenceName.split(".");
      if (parts.length >= 2) {
        return parts[0].trim();
      }
      return "Default Symphony";
    }
    /**
     * Extract resource ID from sequence name and data
     * @param sequenceName - Name of the sequence
     * @param data - Sequence data
     * @returns Resource ID
     */
    extractResourceId(sequenceName, data) {
      if (data?.resourceId) {
        return data.resourceId;
      }
      if (data?.componentId) {
        return `component_${data.componentId}`;
      }
      if (data?.elementId) {
        return `element_${data.elementId}`;
      }
      if (data?.canvasId) {
        return `canvas_${data.canvasId}`;
      }
      const symphonyName = this.extractSymphonyName(sequenceName);
      return `symphony_${symphonyName.toLowerCase().replace(/\s+/g, "_")}`;
    }
    /**
     * Get movement name for a specific beat in a sequence
     * @param sequenceName - Name of the sequence
     * @param beatNumber - Beat number
     * @returns Movement information
     */
    getMovementNameForBeat(sequenceName, beatNumber) {
      const beatsPerMovement = 4;
      const movementNumber = Math.ceil(beatNumber / beatsPerMovement);
      const movementName = this.generateMovementName(sequenceName, movementNumber);
      return {
        name: movementName,
        number: movementNumber,
        description: `Movement ${movementNumber} of ${sequenceName}`
      };
    }
    /**
     * Generate movement name based on sequence name and movement number
     * @param sequenceName - Name of the sequence
     * @param movementNumber - Movement number
     * @returns Generated movement name
     */
    generateMovementName(sequenceName, movementNumber) {
      if (sequenceName.includes("Display")) {
        return `Display Movement ${movementNumber}`;
      }
      if (sequenceName.includes("Animation")) {
        return `Animation Movement ${movementNumber}`;
      }
      if (sequenceName.includes("Interaction")) {
        return `Interaction Movement ${movementNumber}`;
      }
      if (sequenceName.includes("Data")) {
        return `Data Movement ${movementNumber}`;
      }
      return `Movement ${movementNumber}`;
    }
    /**
     * Create execution context for a sequence request
     * @param sequenceRequest - Sequence request
     * @returns Execution context
     */
    createExecutionContext(sequenceRequest) {
      const instanceInfo = this.extractSequenceInstanceInfo(sequenceRequest.sequenceName, sequenceRequest.data, sequenceRequest.priority);
      return {
        id: instanceInfo.instanceId,
        sequenceId: sequenceRequest.sequenceId,
        sequenceName: sequenceRequest.sequenceName,
        sequence: {},
        // Will be filled in by the caller
        data: sequenceRequest.data,
        payload: {},
        startTime: Date.now(),
        currentMovement: 1,
        currentBeat: 0,
        completedBeats: [],
        errors: [],
        executionType: this.determineExecutionType(sequenceRequest),
        priority: sequenceRequest.priority
      };
    }
    /**
     * Extract sequence instance information
     * @param sequenceName - Name of the sequence
     * @param data - Sequence data
     * @param priority - Sequence priority
     * @returns Sequence instance information
     */
    extractSequenceInstanceInfo(sequenceName, data, priority) {
      return {
        instanceId: this.createSequenceInstanceId(sequenceName, data, priority),
        symphonyName: this.extractSymphonyName(sequenceName),
        resourceId: this.extractResourceId(sequenceName, data)
      };
    }
    /**
     * Determine execution type based on sequence request
     * @param sequenceRequest - Sequence request
     * @returns Execution type
     */
    determineExecutionType(sequenceRequest) {
      if (sequenceRequest.priority === "HIGH") {
        return "IMMEDIATE";
      }
      return "CONSECUTIVE";
    }
    /**
     * Check if subscriber is authorized
     * @param callerInfo - Information about the caller
     * @returns True if authorized
     */
    isAuthorizedSubscriber(callerInfo) {
      if (callerInfo?.isReactComponent) {
        return true;
      }
      const authorizedComponents = [
        "MusicalConductor",
        "SequenceExecutor",
        "EventLogger",
        "StatisticsManager",
        "PerformanceTracker"
      ];
      if (callerInfo?.componentName && authorizedComponents.includes(callerInfo.componentName)) {
        return true;
      }
      if (callerInfo?.authToken && this.validateAuthToken(callerInfo.authToken)) {
        return true;
      }
      return true;
    }
    /**
     * Validate authorization token
     * @param token - Authorization token
     * @returns True if valid
     */
    validateAuthToken(token) {
      return token.startsWith("conductor_") && token.length > 20;
    }
    /**
     * Parse sequence name components
     * @param sequenceName - Full sequence name
     * @returns Parsed components
     */
    parseSequenceName(sequenceName) {
      const symphonyMatch = sequenceName.match(/^(.+?)\s+(?:Symphony|Sequence|Movement)\s+No\.\s+(\d+)$/i);
      if (symphonyMatch) {
        return {
          symphony: symphonyMatch[1].trim(),
          number: parseInt(symphonyMatch[2], 10),
          type: "numbered"
        };
      }
      const movementMatch = sequenceName.match(/^(.+?)\s+(.+?)\s+Movement\s+(\d+)$/i);
      if (movementMatch) {
        return {
          symphony: movementMatch[1].trim(),
          movement: movementMatch[2].trim(),
          number: parseInt(movementMatch[3], 10),
          type: "movement"
        };
      }
      return {
        symphony: this.extractSymphonyName(sequenceName),
        type: "simple"
      };
    }
    /**
     * Generate sequence hash for caching/comparison
     * @param sequenceName - Name of the sequence
     * @param data - Sequence data
     * @returns Hash string
     */
    generateSequenceHash(sequenceName, data) {
      const hashData = {
        name: sequenceName,
        resourceId: this.extractResourceId(sequenceName, data),
        symphonyName: this.extractSymphonyName(sequenceName)
      };
      const hashString = JSON.stringify(hashData);
      let hash = 0;
      for (let i = 0; i < hashString.length; i++) {
        const char = hashString.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return `${_SequenceUtilities.SEQUENCE_ID_PREFIX}_${Math.abs(hash).toString(36)}`;
    }
    /**
     * Get debug information
     * @returns Debug utility information
     */
    getDebugInfo() {
      return {
        generatedIds: 0,
        parsedSequences: 0,
        authorizedSubscribers: 0
      };
    }
  };
  SequenceUtilities.SEQUENCE_ID_PREFIX = "seq";
  SequenceUtilities.INSTANCE_ID_PREFIX = "inst";

  // dist/modules/communication/sequences/orchestration/SequenceOrchestrator.js
  init_SequenceTypes();
  var SequenceOrchestrator = class {
    constructor(eventBus2, sequenceRegistry, executionQueue, sequenceExecutor, statisticsManager, sequenceValidator, sequenceUtilities, resourceDelegator) {
      this.eventBus = eventBus2;
      this.sequenceRegistry = sequenceRegistry;
      this.executionQueue = executionQueue;
      this.sequenceExecutor = sequenceExecutor;
      this.statisticsManager = statisticsManager;
      this.sequenceValidator = sequenceValidator;
      this.sequenceUtilities = sequenceUtilities;
      this.resourceDelegator = resourceDelegator;
    }
    /**
     * Start a musical sequence with Sequential Orchestration and Resource Management
     * @param sequenceId - ID of the sequence to start
     * @param data - Data to pass to the sequence
     * @param priority - Priority level: 'HIGH', 'NORMAL', 'CHAINED'
     * @returns Sequence start result
     */
    startSequence(sequenceId, data = {}, priority = SEQUENCE_PRIORITIES.NORMAL) {
      const requestId = this.generateRequestId(sequenceId);
      try {
        const sequence = this.sequenceRegistry.get(sequenceId);
        if (!sequence) {
          this.logSequenceNotFound(sequenceId);
          throw new Error(`Sequence with ID "${sequenceId}" not found`);
        }
        const deduplicationResult = this.sequenceValidator.deduplicateSequenceRequest(sequenceId, sequence.name, data, priority);
        if (deduplicationResult.isDuplicate) {
          return this.handleDuplicateSequence(sequenceId, sequence.name, deduplicationResult);
        }
        this.recordSequenceExecution(deduplicationResult.hash);
        const orchestrationMetadata = this.extractOrchestrationMetadata(sequenceId, sequence.name, data);
        const conflictResult = this.checkResourceConflicts(orchestrationMetadata, priority);
        if (conflictResult.resolution === "REJECT") {
          console.warn(`\u{1F3BC} SequenceOrchestrator: Sequence request rejected - ${conflictResult.message}`);
          throw new Error(`Resource conflict: ${conflictResult.message}`);
        }
        const sequenceRequest = this.createSequenceRequest(sequenceId, sequence.name, data, priority, requestId, orchestrationMetadata, conflictResult, deduplicationResult.hash);
        this.statisticsManager.recordSequenceQueued();
        this.executionQueue.enqueue(sequenceRequest);
        this.processQueueIfIdle();
        this.emitSequenceQueuedEvent(sequenceId, sequence.name, requestId, priority);
        console.log(`\u{1F3BC} SequenceOrchestrator: Sequence "${sequence.name}" (id: ${sequenceId}) queued successfully`);
        return {
          requestId,
          success: true
        };
      } catch (error) {
        console.error(`\u{1F3BC} SequenceOrchestrator: Failed to start sequence: ${sequenceId}`, error);
        this.statisticsManager.recordError();
        return {
          requestId,
          success: false,
          reason: error.message
        };
      }
    }
    /**
     * Process the sequence queue
     * @returns Queue processing result
     */
    async processSequenceQueue() {
      if (this.executionQueue.isEmpty() || this.sequenceExecutor.isSequenceRunning()) {
        return { processed: false };
      }
      const nextRequest = this.executionQueue.dequeue();
      if (!nextRequest) {
        return { processed: false };
      }
      const waitTime = performance.now() - nextRequest.queuedAt;
      this.statisticsManager.updateQueueWaitTime(waitTime);
      const sequence = this.sequenceRegistry.get(nextRequest.sequenceId);
      if (!sequence) {
        console.error(`\u274C SequenceOrchestrator: Sequence ${nextRequest.sequenceId} not found in registry`);
        this.processSequenceQueue();
        return {
          processed: true,
          sequenceName: nextRequest.sequenceName,
          success: false,
          error: "Sequence not found in registry"
        };
      }
      try {
        this.statisticsManager.recordSequenceDequeued();
        this.statisticsManager.recordSequenceExecution(0);
        await this.sequenceExecutor.executeSequence(nextRequest, sequence);
        this.processSequenceQueue();
        return {
          processed: true,
          sequenceName: nextRequest.sequenceName,
          success: true
        };
      } catch (error) {
        console.error(`\u274C SequenceOrchestrator: Failed to execute sequence ${nextRequest.sequenceName}:`, error);
        this.processSequenceQueue();
        return {
          processed: true,
          sequenceName: nextRequest.sequenceName,
          success: false,
          error: error.message
        };
      }
    }
    /**
     * Create execution context for a sequence
     * @param sequenceRequest - Sequence request
     * @returns Execution context
     */
    createExecutionContext(sequenceRequest) {
      const baseContext = this.sequenceUtilities.createExecutionContext(sequenceRequest);
      const sequence = this.sequenceRegistry.get(sequenceRequest.sequenceId);
      if (!sequence) {
        throw new Error(`Sequence ${sequenceRequest.sequenceId} not found`);
      }
      return {
        ...baseContext,
        sequence,
        executionType: sequenceRequest.priority === "HIGH" ? "IMMEDIATE" : "CONSECUTIVE",
        priority: sequenceRequest.priority
      };
    }
    /**
     * Generate a unique request ID
     * @param sequenceId - ID of the sequence
     * @returns Unique request ID
     */
    generateRequestId(sequenceId) {
      return `${sequenceId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    /**
     * Log sequence not found error with helpful information
     * @param sequenceId - ID of the sequence that wasn't found
     * @param sequenceName - Name of the sequence (if available)
     */
    logSequenceNotFound(sequenceId, sequenceName) {
      console.error(`\u274C SequenceOrchestrator: Sequence with ID "${sequenceId}" not found!`);
      if (sequenceName) {
        console.error(`\u274C Sequence name: "${sequenceName}"`);
      }
      console.error(`\u274C This means the plugin for this sequence is not loaded or registered.`);
      console.error(`\u274C Available sequences:`, this.sequenceRegistry.getNames());
      if (sequenceId === "ElementLibrary.library-drop-symphony" || sequenceName === "ElementLibrary.library-drop-symphony") {
        console.error(`\u274C CRITICAL: ElementLibrary.library-drop-symphony not available - drag-and-drop will not work!`);
        console.error(`\u274C Check plugin loading logs above for ElementLibrary.library-drop-symphony errors.`);
      }
    }
    /**
     * Handle duplicate sequence detection
     * @param sequenceId - ID of the sequence
     * @param sequenceName - Name of the sequence
     * @param deduplicationResult - Deduplication result
     * @returns Sequence start result for duplicate
     */
    handleDuplicateSequence(sequenceId, sequenceName, deduplicationResult) {
      console.warn(`\u{1F3BC} SequenceOrchestrator: ${deduplicationResult.reason}`);
      const duplicateRequestId = `${sequenceId}-duplicate-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      this.eventBus.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_CANCELLED, {
        sequenceId,
        sequenceName,
        requestId: duplicateRequestId,
        reason: "duplicate-request",
        hash: deduplicationResult.hash
      });
      return {
        requestId: duplicateRequestId,
        success: false,
        isDuplicate: true,
        reason: deduplicationResult.reason
      };
    }
    /**
     * Extract orchestration metadata from sequence request
     * @param sequenceId - ID of the sequence
     * @param sequenceName - Name of the sequence
     * @param data - Sequence data
     * @returns Orchestration metadata
     */
    extractOrchestrationMetadata(sequenceId, sequenceName, data) {
      return {
        symphonyName: this.sequenceUtilities.extractSymphonyName(sequenceName),
        resourceId: this.sequenceUtilities.extractResourceId(sequenceName, data),
        instanceId: this.sequenceUtilities.createSequenceInstanceId(sequenceName, data, "NORMAL")
      };
    }
    /**
     * Check for resource conflicts
     * @param metadata - Orchestration metadata
     * @param priority - Sequence priority
     * @returns Resource conflict result
     */
    checkResourceConflicts(metadata, priority) {
      const delegatorResult = this.resourceDelegator.checkResourceConflict(metadata.resourceId, metadata.instanceId, priority);
      return {
        hasConflict: delegatorResult.hasConflict,
        conflictType: delegatorResult.hasConflict ? "SAME_RESOURCE" : "NONE",
        resolution: delegatorResult.resolution === "override" ? "ALLOW" : delegatorResult.resolution === "reject" ? "REJECT" : delegatorResult.resolution === "queue" ? "QUEUE" : "ALLOW",
        message: delegatorResult.reason || "No conflict detected"
      };
    }
    /**
     * Create a sequence request object
     * @param sequenceId - ID of the sequence
     * @param sequenceName - Name of the sequence
     * @param data - Sequence data
     * @param priority - Sequence priority
     * @param requestId - Request ID
     * @param metadata - Orchestration metadata
     * @param conflictResult - Resource conflict result
     * @param sequenceHash - Sequence hash for idempotency
     * @returns Sequence request
     */
    createSequenceRequest(sequenceId, sequenceName, data, priority, requestId, metadata, conflictResult, sequenceHash) {
      return {
        sequenceId,
        sequenceName,
        data: {
          ...data,
          // MCO/MSO: Add instance and resource tracking
          instanceId: metadata.instanceId,
          symphonyName: metadata.symphonyName,
          resourceId: metadata.resourceId,
          conflictResult,
          // Phase 3: Add idempotency hash
          sequenceHash
        },
        priority,
        requestId,
        queuedAt: performance.now()
      };
    }
    /**
     * Record sequence execution to prevent duplicates
     * @param sequenceHash - Hash of the sequence
     */
    recordSequenceExecution(sequenceHash) {
      console.log(`\u{1F3BC} SequenceOrchestrator: Recording sequence execution: ${sequenceHash}`);
    }
    /**
     * Process queue if currently idle
     */
    processQueueIfIdle() {
      if (!this.sequenceExecutor.isSequenceRunning()) {
        this.processSequenceQueue();
      }
    }
    /**
     * Emit sequence queued event
     * @param sequenceId - ID of the sequence
     * @param sequenceName - Name of the sequence
     * @param requestId - Request ID
     * @param priority - Sequence priority
     */
    emitSequenceQueuedEvent(sequenceId, sequenceName, requestId, priority) {
      this.eventBus.emit(MUSICAL_CONDUCTOR_EVENT_TYPES.SEQUENCE_QUEUED, {
        sequenceId,
        sequenceName,
        requestId,
        priority,
        queueLength: this.executionQueue.size()
      });
    }
    /**
     * Get debug information
     * @returns Debug orchestration information
     */
    getDebugInfo() {
      return {
        queueSize: this.executionQueue.size(),
        isExecuting: this.sequenceExecutor.isSequenceRunning(),
        currentSequence: this.sequenceExecutor.getCurrentSequence()?.sequenceName || null,
        processedSequences: 0
        // Would track this in a real implementation
      };
    }
  };

  // dist/modules/communication/sequences/orchestration/EventOrchestrator.js
  var EventOrchestrator = class {
    constructor(eventBus2) {
      this.debugMode = false;
      this.eventBus = eventBus2;
    }
    /**
     * Emit an event with contextual data from sequence execution
     * @param eventType - Type of event to emit
     * @param data - Event data
     * @param executionContext - Current sequence execution context
     * @returns Event emission result
     */
    emitEvent(eventType, data, executionContext) {
      try {
        const contextualEventData = this.createContextualEventData(data, executionContext);
        this.handleSpecialEventDebugging(eventType, contextualEventData);
        const subscriberCount = this.eventBus.getSubscriberCount(eventType);
        this.eventBus.emit(eventType, contextualEventData);
        if (this.debugMode) {
          console.log(`\u{1F3BC} EventOrchestrator: Emitted ${eventType} to ${subscriberCount} subscribers`);
        }
        return {
          success: true,
          eventType,
          subscriberCount
        };
      } catch (error) {
        console.error(`\u{1F3BC} EventOrchestrator: Failed to emit event ${eventType}:`, error);
        return {
          success: false,
          eventType,
          subscriberCount: 0,
          error: error.message
        };
      }
    }
    /**
     * Emit a simple event without execution context
     * @param eventType - Type of event to emit
     * @param data - Event data
     * @returns Event emission result
     */
    emitSimpleEvent(eventType, data) {
      try {
        const subscriberCount = this.eventBus.getSubscriberCount(eventType);
        this.eventBus.emit(eventType, data);
        if (this.debugMode) {
          console.log(`\u{1F3BC} EventOrchestrator: Emitted simple event ${eventType} to ${subscriberCount} subscribers`);
        }
        return {
          success: true,
          eventType,
          subscriberCount
        };
      } catch (error) {
        console.error(`\u{1F3BC} EventOrchestrator: Failed to emit simple event ${eventType}:`, error);
        return {
          success: false,
          eventType,
          subscriberCount: 0,
          error: error.message
        };
      }
    }
    /**
     * Create contextual event data with execution context
     * @param originalData - Original event data
     * @param executionContext - Current sequence execution context
     * @returns Contextual event data
     */
    createContextualEventData(originalData, executionContext) {
      return {
        ...originalData,
        // ðŸŽ½ Include the data baton in the event context
        context: {
          payload: executionContext.payload,
          executionId: executionContext.id,
          sequenceName: executionContext.sequenceName
        },
        metadata: {
          timestamp: Date.now(),
          beat: executionContext.currentBeat,
          movement: executionContext.currentMovement
        }
      };
    }
    /**
     * Handle special debugging for specific events
     * @param eventType - Type of event
     * @param contextualEventData - Contextual event data
     */
    handleSpecialEventDebugging(eventType, contextualEventData) {
      if (eventType.includes("sequence")) {
        if (this.debugMode) {
          console.log(`\u{1F50D} DEBUG: EventOrchestrator emitting sequence event: ${eventType}`, {
            sequenceName: contextualEventData.context.sequenceName,
            executionId: contextualEventData.context.executionId,
            beat: contextualEventData.metadata.beat
          });
        }
      }
      if (eventType.includes("beat")) {
        if (this.debugMode) {
          console.log(`\u{1F50D} DEBUG: EventOrchestrator emitting beat event: ${eventType}`, {
            beat: contextualEventData.metadata.beat,
            movement: contextualEventData.metadata.movement,
            sequenceName: contextualEventData.context.sequenceName
          });
        }
      }
    }
    /**
     * Get subscriber count for an event type
     * @param eventType - Type of event
     * @returns Number of subscribers
     */
    getSubscriberCount(eventType) {
      return this.eventBus.getSubscriberCount(eventType);
    }
    /**
     * Check if an event type has subscribers
     * @param eventType - Type of event
     * @returns True if event has subscribers
     */
    hasSubscribers(eventType) {
      return this.getSubscriberCount(eventType) > 0;
    }
    /**
     * Enable or disable debug mode
     * @param enabled - Whether to enable debug mode
     */
    setDebugMode(enabled) {
      this.debugMode = enabled;
      console.log(`\u{1F3BC} EventOrchestrator: Debug mode ${enabled ? "enabled" : "disabled"}`);
    }
    /**
     * Get all event types with subscribers
     * @returns Array of event types that have subscribers
     */
    getActiveEventTypes() {
      return [];
    }
    /**
     * Emit multiple events in sequence
     * @param events - Array of events to emit
     * @param executionContext - Current sequence execution context
     * @returns Array of emission results
     */
    emitMultipleEvents(events, executionContext) {
      const results = [];
      for (const event of events) {
        const result = this.emitEvent(event.eventType, event.data, executionContext);
        results.push(result);
        if (!result.success) {
          console.warn(`\u{1F3BC} EventOrchestrator: Stopping multiple event emission due to failure: ${result.error}`);
          break;
        }
      }
      return results;
    }
    /**
     * Emit event with retry logic
     * @param eventType - Type of event to emit
     * @param data - Event data
     * @param executionContext - Current sequence execution context
     * @param maxRetries - Maximum number of retries
     * @returns Event emission result
     */
    emitEventWithRetry(eventType, data, executionContext, maxRetries = 3) {
      let lastResult;
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        lastResult = this.emitEvent(eventType, data, executionContext);
        if (lastResult.success) {
          if (attempt > 1) {
            console.log(`\u{1F3BC} EventOrchestrator: Event ${eventType} succeeded on attempt ${attempt}`);
          }
          return lastResult;
        }
        if (attempt < maxRetries) {
          console.warn(`\u{1F3BC} EventOrchestrator: Event ${eventType} failed on attempt ${attempt}, retrying...`);
          setTimeout(() => {
          }, 10);
        }
      }
      console.error(`\u{1F3BC} EventOrchestrator: Event ${eventType} failed after ${maxRetries} attempts`);
      return lastResult;
    }
    /**
     * Get debug information
     * @returns Debug event orchestration information
     */
    getDebugInfo() {
      return {
        debugMode: this.debugMode,
        totalEventTypes: this.getActiveEventTypes().length,
        activeEventTypes: this.getActiveEventTypes(),
        eventBusAvailable: !!this.eventBus
      };
    }
  };

  // dist/modules/communication/sequences/api/ConductorAPI.js
  init_SequenceTypes();
  var ConductorAPI = class {
    constructor(sequenceOrchestrator, sequenceExecutor, executionQueue, statisticsManager, pluginInterface, sequenceRegistry, eventBus2) {
      this.sequenceOrchestrator = sequenceOrchestrator;
      this.sequenceExecutor = sequenceExecutor;
      this.executionQueue = executionQueue;
      this.statisticsManager = statisticsManager;
      this.pluginInterface = pluginInterface;
      this.sequenceRegistry = sequenceRegistry;
      this.eventBus = eventBus2;
    }
    /**
     * Queue a sequence for execution (validation compliance method)
     * @param sequenceId - ID of the sequence to queue
     * @param data - Data to pass to the sequence
     * @param priority - Priority level
     * @returns Request ID for tracking
     */
    queueSequence(sequenceId, data = {}, priority = SEQUENCE_PRIORITIES.NORMAL) {
      const result = this.sequenceOrchestrator.startSequence(sequenceId, data, priority);
      if (!result.success) {
        if (result.isDuplicate) {
          return result.requestId;
        }
        throw new Error(result.reason || "Failed to queue sequence");
      }
      return result.requestId;
    }
    /**
     * Execute the next sequence in queue (validation compliance method)
     * @returns Success status
     */
    executeNextSequence() {
      if (this.executionQueue.isEmpty()) {
        return false;
      }
      if (this.sequenceExecutor.isSequenceRunning()) {
        return false;
      }
      this.sequenceOrchestrator.processSequenceQueue();
      return true;
    }
    /**
     * Check if a sequence is currently running (validation compliance method)
     * @param sequenceId - Optional sequence ID to check for specific sequence
     * @returns True if a sequence is executing (or specific sequence if ID provided)
     */
    isSequenceRunning(sequenceId) {
      return this.sequenceExecutor.isSequenceRunning(sequenceId);
    }
    /**
     * Get the currently executing sequence (validation compliance method)
     * @returns Current sequence execution context or null
     */
    getCurrentSequence() {
      return this.sequenceExecutor.getCurrentSequence();
    }
    /**
     * Get queued sequences (validation compliance method)
     * @returns Array of queued sequence names
     */
    getQueuedSequences() {
      return this.executionQueue.getQueuedRequests().map((request) => request.sequenceName);
    }
    /**
     * Clear the sequence queue (validation compliance method)
     * @returns Number of sequences that were cleared
     */
    clearSequenceQueue() {
      const clearedCount = this.executionQueue.size();
      this.executionQueue.clear();
      console.log(`\u{1F3BC} ConductorAPI: Cleared ${clearedCount} sequences from queue`);
      return clearedCount;
    }
    /**
     * Get queue status information
     * @returns Queue status object
     */
    getQueueStatus() {
      const nextRequest = this.executionQueue.peek();
      return {
        size: this.executionQueue.size(),
        isEmpty: this.executionQueue.isEmpty(),
        isProcessing: this.sequenceExecutor.isSequenceRunning(),
        nextSequence: nextRequest?.sequenceName
      };
    }
    /**
     * Get current statistics (enhanced with CIA plugin information)
     * @returns Enhanced statistics object
     */
    getStatistics() {
      return this.statisticsManager.getEnhancedStatistics(this.pluginInterface.getMountedPluginIds().length);
    }
    /**
     * Get conductor status including eventBus availability
     * @returns Conductor status object
     */
    getStatus() {
      return {
        statistics: this.getStatistics(),
        eventBus: !!this.eventBus,
        sequences: this.sequenceRegistry.getNames().length,
        plugins: this.pluginInterface.getMountedPluginIds().length
      };
    }
    /**
     * Reset statistics
     */
    resetStatistics() {
      this.statisticsManager.reset();
      console.log("\u{1F3BC} ConductorAPI: Statistics reset");
    }
    /**
     * Update the data baton payload for the currently executing sequence
     * This allows plugin handlers to pass data between beats
     * @param payloadData - Data to merge into the current payload
     * @returns Success status
     */
    updateDataBaton(payloadData) {
      const currentSequence = this.sequenceExecutor.getCurrentSequence();
      if (!currentSequence) {
        console.warn("\u{1F3BD} ConductorAPI: No active sequence to update data baton");
        return false;
      }
      try {
        Object.assign(currentSequence.payload, payloadData);
        console.log(`\u{1F3BD} ConductorAPI: Updated data baton for sequence ${currentSequence.sequenceName}`, payloadData);
        return true;
      } catch (error) {
        console.error("\u{1F3BD} ConductorAPI: Failed to update data baton:", error);
        return false;
      }
    }
    /**
     * Get the current data baton payload
     * @returns Current payload data or null if no active sequence
     */
    getDataBaton() {
      const currentSequence = this.sequenceExecutor.getCurrentSequence();
      if (!currentSequence) {
        return null;
      }
      return { ...currentSequence.payload };
    }
    /**
     * Clear the data baton payload
     * @returns Success status
     */
    clearDataBaton() {
      const currentSequence = this.sequenceExecutor.getCurrentSequence();
      if (!currentSequence) {
        console.warn("\u{1F3BD} ConductorAPI: No active sequence to clear data baton");
        return false;
      }
      try {
        currentSequence.payload = {};
        console.log(`\u{1F3BD} ConductorAPI: Cleared data baton for sequence ${currentSequence.sequenceName}`);
        return true;
      } catch (error) {
        console.error("\u{1F3BD} ConductorAPI: Failed to clear data baton:", error);
        return false;
      }
    }
    /**
     * Get all registered sequence names
     * @returns Array of sequence names
     */
    getRegisteredSequences() {
      return this.sequenceRegistry.getNames();
    }
    /**
     * Check if a sequence is registered
     * @param sequenceId - ID of the sequence to check
     * @returns True if sequence is registered
     */
    isSequenceRegistered(sequenceId) {
      return this.sequenceRegistry.has(sequenceId);
    }
    /**
     * Check if a sequence is registered by name (for backward compatibility)
     * @param sequenceName - Name of the sequence to check
     * @returns True if sequence is registered
     */
    isSequenceRegisteredByName(sequenceName) {
      return this.sequenceRegistry.findByName(sequenceName) !== void 0;
    }
    /**
     * Get mounted plugin information
     * @returns Array of mounted plugin IDs
     */
    getMountedPlugins() {
      return this.pluginInterface.getMountedPluginIds();
    }
    /**
     * Check if a plugin is mounted
     * @param pluginId - ID of the plugin to check
     * @returns True if plugin is mounted
     */
    isPluginMounted(pluginId) {
      return this.pluginInterface.getMountedPluginIds().includes(pluginId);
    }
    /**
     * Get comprehensive debug information
     * @returns Debug information object
     */
    getDebugInfo() {
      return {
        api: {
          queueStatus: this.getQueueStatus(),
          statistics: this.getStatistics(),
          registeredSequences: this.getRegisteredSequences(),
          mountedPlugins: this.getMountedPlugins()
        },
        orchestration: this.sequenceOrchestrator.getDebugInfo()
      };
    }
  };

  // dist/modules/communication/sequences/strictmode/StrictModeManager.js
  var StrictModeManager = class {
    constructor(duplicationDetector) {
      this.strictModePatterns = /* @__PURE__ */ new Set([
        "double-render",
        "strict-mode",
        "development-only",
        "react-strict",
        "duplicate-effect",
        "double-execution"
      ]);
      this.duplicationDetector = duplicationDetector;
    }
    /**
     * Check if a sequence request is a duplicate, considering StrictMode patterns
     * @param sequenceName - Name of the sequence
     * @param data - Sequence data
     * @param priority - Sequence priority
     * @returns Duplication check result
     */
    checkForDuplication(sequenceName, data, priority) {
      const hash = this.generateSequenceHash(sequenceName, data, priority);
      const isDuplicate = this.duplicationDetector.isDuplicateSequenceRequest(hash);
      if (!isDuplicate) {
        return {
          isDuplicate: false,
          hash
        };
      }
      const strictModeResult = this.isStrictModeDuplicate(data);
      return {
        isDuplicate: true,
        hash,
        reason: strictModeResult.isStrictModeDuplicate ? `StrictMode duplicate detected: ${strictModeResult.patterns.join(", ")}` : "Duplicate sequence request detected",
        isStrictMode: strictModeResult.isStrictModeDuplicate
      };
    }
    /**
     * Record a sequence execution to prevent future duplicates
     * @param hash - Hash of the sequence
     */
    recordSequenceExecution(hash) {
      this.duplicationDetector.recordSequenceExecution(hash);
      console.log(`\u{1F3BC} StrictModeManager: Recorded sequence execution: ${hash.substring(0, 8)}...`);
    }
    /**
     * Check if data contains StrictMode patterns
     * @param data - Data to check for StrictMode patterns
     * @returns StrictMode detection result
     */
    isStrictModeDuplicate(data) {
      const detectedPatterns = [];
      const dataString = JSON.stringify(data).toLowerCase();
      for (const pattern of this.strictModePatterns) {
        if (dataString.includes(pattern)) {
          detectedPatterns.push(pattern);
        }
      }
      if (this.hasReactDevModeIndicators(data)) {
        detectedPatterns.push("react-dev-mode");
      }
      if (this.hasDoubleExecutionPatterns(data)) {
        detectedPatterns.push("double-execution-pattern");
      }
      if (this.hasTimingBasedDuplicatePattern(data)) {
        detectedPatterns.push("timing-duplicate");
      }
      const isStrictModeDuplicate = detectedPatterns.length > 0;
      return {
        isStrictModeDuplicate,
        patterns: detectedPatterns,
        reason: isStrictModeDuplicate ? `StrictMode patterns detected: ${detectedPatterns.join(", ")}` : void 0
      };
    }
    /**
     * Generate a hash for a sequence request
     * @param sequenceName - Name of the sequence
     * @param data - Sequence data
     * @param priority - Sequence priority
     * @returns Hash string
     */
    generateSequenceHash(sequenceName, data, priority) {
      const sortedData = this.sortObjectKeys(data);
      const hashInput = `${sequenceName}:${JSON.stringify(sortedData)}:${priority}`;
      let hash = 0;
      for (let i = 0; i < hashInput.length; i++) {
        const char = hashInput.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return Math.abs(hash).toString(36);
    }
    /**
     * Sort object keys recursively for consistent hashing
     * @param obj - Object to sort
     * @returns Sorted object
     */
    sortObjectKeys(obj) {
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map((item) => this.sortObjectKeys(item));
      }
      const sortedObj = {};
      const keys = Object.keys(obj).sort();
      for (const key of keys) {
        sortedObj[key] = this.sortObjectKeys(obj[key]);
      }
      return sortedObj;
    }
    /**
     * Check for React development mode indicators
     * @param data - Data to check
     * @returns True if React dev mode indicators found
     */
    hasReactDevModeIndicators(data) {
      const reactDevIndicators = [
        "__reactInternalInstance",
        "_reactInternalFiber",
        "__reactInternalMemoizedUnmaskedChildContext",
        "NODE_ENV"
      ];
      const dataString = JSON.stringify(data);
      return reactDevIndicators.some((indicator) => dataString.includes(indicator));
    }
    /**
     * Check for double execution patterns
     * @param data - Data to check
     * @returns True if double execution patterns found
     */
    hasDoubleExecutionPatterns(data) {
      if (data.executionCount && data.executionCount > 1) {
        return true;
      }
      if (data.renderCount && data.renderCount > 1) {
        return true;
      }
      if (data.effectCount && data.effectCount > 1) {
        return true;
      }
      return false;
    }
    /**
     * Check for timing-based duplicate patterns
     * @param data - Data to check
     * @returns True if timing-based duplicates detected
     */
    hasTimingBasedDuplicatePattern(data) {
      if (!data.timestamp) {
        return false;
      }
      const now = Date.now();
      const timestamp = typeof data.timestamp === "number" ? data.timestamp : parseInt(data.timestamp);
      const timeDiff = Math.abs(now - timestamp);
      return timeDiff < 10;
    }
    /**
     * Add a custom StrictMode pattern
     * @param pattern - Pattern to add
     */
    addStrictModePattern(pattern) {
      this.strictModePatterns.add(pattern.toLowerCase());
      console.log(`\u{1F3BC} StrictModeManager: Added StrictMode pattern: ${pattern}`);
    }
    /**
     * Remove a StrictMode pattern
     * @param pattern - Pattern to remove
     */
    removeStrictModePattern(pattern) {
      this.strictModePatterns.delete(pattern.toLowerCase());
      console.log(`\u{1F3BC} StrictModeManager: Removed StrictMode pattern: ${pattern}`);
    }
    /**
     * Get all registered StrictMode patterns
     * @returns Array of patterns
     */
    getStrictModePatterns() {
      return Array.from(this.strictModePatterns);
    }
    /**
     * Clear all recorded sequence executions
     */
    clearExecutionHistory() {
      this.duplicationDetector.reset();
      console.log("\u{1F3BC} StrictModeManager: Cleared execution history");
    }
    /**
     * Get statistics about StrictMode detection
     * @returns StrictMode statistics
     */
    getStrictModeStatistics() {
      return {
        totalPatterns: this.strictModePatterns.size,
        patterns: this.getStrictModePatterns(),
        detectionEnabled: true
      };
    }
    /**
     * Enable or disable StrictMode detection
     * @param enabled - Whether to enable StrictMode detection
     */
    setStrictModeDetection(enabled) {
      if (enabled) {
        const defaultPatterns = [
          "double-render",
          "strict-mode",
          "development-only",
          "react-strict",
          "duplicate-effect",
          "double-execution"
        ];
        for (const pattern of defaultPatterns) {
          this.strictModePatterns.add(pattern);
        }
      } else {
        this.strictModePatterns.clear();
      }
      console.log(`\u{1F3BC} StrictModeManager: StrictMode detection ${enabled ? "enabled" : "disabled"}`);
    }
    /**
     * Get debug information
     * @returns Debug StrictMode information
     */
    getDebugInfo() {
      return {
        strictModePatterns: this.getStrictModePatterns(),
        totalPatterns: this.strictModePatterns.size,
        detectionEnabled: this.strictModePatterns.size > 0,
        duplicationDetectorStats: {
          // Would get stats from duplicationDetector if available
          recordedExecutions: 0
          // Placeholder
        }
      };
    }
  };

  // dist/modules/communication/sequences/resources/ResourceConflictManager.js
  var ResourceConflictManager = class {
    constructor(resourceManager, resourceDelegator, sequenceUtilities) {
      this.resourceManager = resourceManager;
      this.resourceDelegator = resourceDelegator;
      this.sequenceUtilities = sequenceUtilities;
    }
    /**
     * Create a sequence instance ID
     * @param sequenceName - Name of the sequence
     * @param instanceId - Optional instance ID
     * @returns Generated instance ID
     */
    createSequenceInstanceId(sequenceName, instanceId) {
      return this.sequenceUtilities.createSequenceInstanceId(sequenceName, { instanceId }, "NORMAL");
    }
    /**
     * Extract symphony name from sequence name
     * @param sequenceName - Full sequence name
     * @returns Symphony name
     */
    extractSymphonyName(sequenceName) {
      return this.sequenceUtilities.extractSymphonyName(sequenceName);
    }
    /**
     * Extract resource ID from sequence name and data
     * @param sequenceName - Name of the sequence
     * @param data - Sequence data
     * @returns Resource ID
     */
    extractResourceId(sequenceName, data) {
      return this.sequenceUtilities.extractResourceId(sequenceName, data);
    }
    /**
     * Check for resource conflicts
     * @param resourceId - Resource ID to check
     * @param symphonyName - Symphony name
     * @param priority - Sequence priority
     * @param instanceId - Instance ID
     * @returns Conflict result
     */
    checkResourceConflict(resourceId, symphonyName, priority, instanceId) {
      const delegatorResult = this.resourceDelegator.checkResourceConflict(resourceId, instanceId, priority);
      return {
        hasConflict: delegatorResult.hasConflict,
        conflictType: delegatorResult.hasConflict ? "SAME_RESOURCE" : "NONE",
        resolution: delegatorResult.resolution === "override" ? "ALLOW" : delegatorResult.resolution === "reject" ? "REJECT" : delegatorResult.resolution === "queue" ? "QUEUE" : "ALLOW",
        message: delegatorResult.reason || "No conflict detected"
      };
    }
    /**
     * Acquire resource ownership
     * @param resourceId - Resource ID
     * @param symphonyName - Symphony name
     * @param instanceId - Instance ID
     * @param sequenceExecutionId - Execution ID
     */
    acquireResourceOwnership(resourceId, symphonyName, instanceId, sequenceExecutionId) {
      this.resourceDelegator.acquireResourceOwnership(resourceId, sequenceExecutionId);
    }
    /**
     * Release resource ownership
     * @param resourceId - Resource ID
     * @param sequenceExecutionId - Execution ID
     */
    releaseResourceOwnership(resourceId, sequenceExecutionId) {
      this.resourceDelegator.releaseResourceOwnership(resourceId, sequenceExecutionId || "unknown");
    }
    /**
     * Get resource ownership information
     * @returns Resource ownership map
     */
    getResourceOwnership() {
      return this.resourceManager.getResourceOwnership();
    }
    /**
     * Get symphony resource mapping
     * @returns Symphony to resources mapping
     */
    getSymphonyResourceMap() {
      return this.resourceManager.getSymphonyResourceMap();
    }
    /**
     * Enhanced resource conflict resolution with strategy selection
     * @param resourceId - Resource ID
     * @param symphonyName - Symphony name
     * @param instanceId - Instance ID
     * @param priority - Sequence priority
     * @param sequenceExecutionId - Execution ID
     * @param sequenceRequest - Full sequence request
     * @returns Resolution result
     */
    resolveResourceConflictAdvanced(resourceId, symphonyName, instanceId, priority, sequenceExecutionId, sequenceRequest) {
      return this.resourceManager.resolveResourceConflictAdvanced(resourceId, symphonyName, instanceId, priority, sequenceExecutionId, sequenceRequest);
    }
    /**
     * Get comprehensive resource diagnostics
     * @returns Resource diagnostics information
     */
    getResourceDiagnostics() {
      return {
        ownership: this.getResourceOwnership(),
        symphonyResourceMap: this.getSymphonyResourceMap(),
        activeConflicts: 0,
        // Would be tracked in a real implementation
        resolvedConflicts: 0
        // Would be tracked in a real implementation
      };
    }
    /**
     * Clear all resource ownership
     */
    clearAllResourceOwnership() {
      console.log("\u{1F3BC} ResourceConflictManager: Clearing all resource ownership");
    }
    /**
     * Get resource conflict statistics
     * @returns Conflict statistics
     */
    getConflictStatistics() {
      return {
        totalConflicts: 0,
        resolvedConflicts: 0,
        activeConflicts: 0,
        conflictResolutionStrategies: {
          ALLOW: 0,
          REJECT: 0,
          QUEUE: 0,
          INTERRUPT: 0
        }
      };
    }
    /**
     * Check if a resource is currently owned
     * @param resourceId - Resource ID to check
     * @returns True if resource is owned
     */
    isResourceOwned(resourceId) {
      const ownership = this.getResourceOwnership();
      return ownership.has(resourceId);
    }
    /**
     * Get the owner of a resource
     * @param resourceId - Resource ID
     * @returns Resource owner or null if not owned
     */
    getResourceOwner(resourceId) {
      const ownership = this.getResourceOwnership();
      return ownership.get(resourceId) || null;
    }
    /**
     * Get all resources owned by a specific sequence
     * @param sequenceExecutionId - Execution ID
     * @returns Array of resource IDs owned by the sequence
     */
    getResourcesOwnedBySequence(sequenceExecutionId) {
      const ownership = this.getResourceOwnership();
      const ownedResources = [];
      for (const [resourceId, owner] of ownership.entries()) {
        if (owner.sequenceExecutionId === sequenceExecutionId) {
          ownedResources.push(resourceId);
        }
      }
      return ownedResources;
    }
    /**
     * Get debug information
     * @returns Debug resource conflict information
     */
    getDebugInfo() {
      return {
        resourceManager: !!this.resourceManager,
        resourceDelegator: !!this.resourceDelegator,
        sequenceUtilities: !!this.sequenceUtilities,
        diagnostics: this.getResourceDiagnostics(),
        statistics: this.getConflictStatistics()
      };
    }
  };

  // dist/modules/communication/sequences/MusicalConductor.js
  init_CallbackRegistry();
  var pkg = { version: "unknown" };
  try {
    pkg = __require("../../../package.json");
  } catch {
  }
  var MusicalConductor = class _MusicalConductor {
    // Core component getters
    get eventBus() {
      return this.conductorCore.getEventBus();
    }
    /**
     * Expose the sequence registry map early for EventBus integration
     * Available immediately after construction (may be empty until registration)
     */
    get sequences() {
      return this.sequenceRegistry.getSequenceMap();
    }
    constructor(eventBus2) {
      this.requestCorrelationMap = /* @__PURE__ */ new Map();
      this.correlationActiveCounts = /* @__PURE__ */ new Map();
      this.eventUnsubscribes = [];
      this.conductorCore = ConductorCore.getInstance(eventBus2);
      this.sequenceRegistry = new SequenceRegistry(eventBus2);
      this.eventSubscriptionManager = new EventSubscriptionManager(eventBus2, this.conductorCore.getSPAValidator());
      this.sequenceRegistry.setEventSubscriptionManager(this.eventSubscriptionManager);
      this.executionQueue = new ExecutionQueue();
      this.statisticsManager = new StatisticsManager();
      this.performanceTracker = new PerformanceTracker();
      this.duplicationDetector = new DuplicationDetector();
      this.eventLogger = new EventLogger(eventBus2, this.performanceTracker);
      this.eventLogger.setupBeatExecutionLogging();
      this.eventLogger.setupMovementExecutionLogging();
      this.sequenceValidator = new SequenceValidator(this.duplicationDetector);
      this.sequenceUtilities = new SequenceUtilities();
      this.sequenceExecutor = new SequenceExecutor(eventBus2, this.conductorCore.getSPAValidator(), this.executionQueue, this.statisticsManager, this.performanceTracker);
      this.pluginManager = new PluginManager(eventBus2, this.conductorCore.getSPAValidator(), this.sequenceRegistry);
      this.pluginInterface = new PluginInterfaceFacade(this.pluginManager, this.conductorCore.getSPAValidator());
      this.resourceManager = new ResourceManager();
      this.resourceDelegator = new ResourceDelegator(this.resourceManager);
      this.sequenceOrchestrator = new SequenceOrchestrator(eventBus2, this.sequenceRegistry, this.executionQueue, this.sequenceExecutor, this.statisticsManager, this.sequenceValidator, this.sequenceUtilities, this.resourceDelegator);
      this.eventOrchestrator = new EventOrchestrator(eventBus2);
      this.conductorAPI = new ConductorAPI(this.sequenceOrchestrator, this.sequenceExecutor, this.executionQueue, this.statisticsManager, this.pluginInterface, this.sequenceRegistry, eventBus2);
      this.strictModeManager = new StrictModeManager(this.duplicationDetector);
      this.resourceConflictManager = new ResourceConflictManager(this.resourceManager, this.resourceDelegator, this.sequenceUtilities);
      try {
        const v = pkg?.version || "unknown";
        console.log(`\u{1F3BC} MusicalConductor v${v}: Initialized with core components`);
      } catch {
        console.log("\u{1F3BC} MusicalConductor: Initialized with core components");
      }
    }
    /**
     * Get the singleton instance of Musical Conductor
     * @param eventBus - The event bus instance (required for first initialization)
     * @returns The singleton Musical Conductor instance
     */
    static getInstance(eventBus2) {
      if (!_MusicalConductor.instance) {
        if (!eventBus2) {
          throw new Error("EventBus is required for first initialization of Musical Conductor");
        }
        _MusicalConductor.instance = new _MusicalConductor(eventBus2);
      } else if (eventBus2 && _MusicalConductor.instance.eventBus !== eventBus2) {
        console.warn("\u{1F3BC} MusicalConductor: Attempting to change eventBus on existing singleton instance - ignoring");
      }
      return _MusicalConductor.instance;
    }
    /**
     * Reset the singleton instance (for testing/cleanup)
     * This allows re-initialization if needed
     */
    static resetInstance() {
      if (_MusicalConductor.instance) {
        ConductorCore.resetInstance();
      }
      _MusicalConductor.instance = null;
      console.log("\u{1F504} MusicalConductor: Singleton instance reset");
    }
    /**
     * Handle beat execution error with hierarchical logging
     * @param executionContext - Execution context
     * @param beat - Beat that failed
     * @param error - Error that occurred
     */
    handleBeatError(executionContext, beat, error) {
      this.eventLogger.handleBeatError(executionContext, beat, error);
    }
    /**
     * Register a musical sequence
     * @param sequence - The sequence to register
     */
    registerSequence(sequence) {
      this.sequenceRegistry.register(sequence);
    }
    /**
     * Unregister a musical sequence
     * @param sequenceId - ID of the sequence to unregister
     */
    unregisterSequence(sequenceId) {
      this.sequenceRegistry.unregister(sequenceId);
    }
    /**
     * Get a registered sequence by ID
     * @param sequenceId - ID of the sequence
     */
    getSequence(sequenceId) {
      return this.sequenceRegistry.get(sequenceId);
    }
    /**
     * Get a registered sequence by name (for backward compatibility)
     * @param sequenceName - Name of the sequence
     */
    getSequenceByName(sequenceName) {
      return this.sequenceRegistry.findByName(sequenceName);
    }
    /**
     * Get all registered sequence names
     */
    getSequenceNames() {
      return this.sequenceRegistry.getNames();
    }
    /**
     * Get all registered sequences with their details
     * @returns Array of registered sequences
     */
    getRegisteredSequences() {
      return this.sequenceRegistry.getAll();
    }
    /**
     * Get all mounted plugin names
     */
    getMountedPlugins() {
      return this.pluginInterface.getMountedPlugins();
    }
    // ===== CIA (Conductor Integration Architecture) Methods =====
    /**
     * Play a specific movement of a mounted SPA plugin (CIA-compliant)
     * @param pluginId - The plugin identifier
     * @param sequenceId - The sequence ID to execute
     * @param context - Context data to pass to the movement handler
     * @param priority - Sequence priority (NORMAL, HIGH, CHAINED)
     * @returns Execution result
     */
    play(pluginId, sequenceId, context = {}, priority = SEQUENCE_PRIORITIES.NORMAL) {
      try {
        const registry = CallbackRegistry.getInstance();
        const { correlationId, count } = registry.preserveInPlace(context);
        if (count > 0) {
          console.log(`\u{1F3BC} MusicalConductor.play: preserved ${count} callback(s) for correlationId=${correlationId}`);
        }
      } catch (e) {
        console.warn("\u26A0\uFE0F MusicalConductor.play: callback preservation skipped:", e?.message || e);
      }
      return this.pluginInterface.play(pluginId, sequenceId, context, priority, async (seqId, data, prio) => {
        const requestId = await this.startSequence(seqId, data, prio);
        try {
          const key = (await Promise.resolve().then(() => (init_CallbackRegistry(), CallbackRegistry_exports))).__internal.CORRELATION_KEY;
          const corr = data?.[key];
          if (typeof corr === "string") {
            this.requestCorrelationMap.set(requestId, corr);
            const cur = this.correlationActiveCounts.get(corr) || 0;
            this.correlationActiveCounts.set(corr, cur + 1);
          }
          if (this.eventUnsubscribes.length === 0) {
            this.installCorrelationCleanupListeners();
          }
        } catch {
        }
        return requestId;
      });
    }
    /**
     * Subscribe to events through the conductor (SPA-compliant)
     * This method ensures all event subscriptions go through the conductor
     * and prevents direct eventBus access violations
     * @param eventName - The event name to subscribe to
     * @param callback - The callback function to execute
     * @param context - Optional context for the subscription
     * @returns Unsubscribe function
     */
    subscribe(eventName, callback, context) {
      return this.eventSubscriptionManager.subscribe(eventName, callback, context);
    }
    /**
     * Friendly alias for subscribe() used by many client apps
     */
    on(eventName, callback, context) {
      return this.subscribe(eventName, callback, context);
    }
    /**
     * Unsubscribe from events through the conductor (SPA-compliant)
     * @param eventName - The event name to unsubscribe from
     * @param callback - The callback function to remove
     */
    unsubscribe(eventName, callback) {
      this.eventSubscriptionManager.unsubscribe(eventName, callback);
    }
    /**
     * Friendly alias for unsubscribe() used by many client apps
     */
    off(eventName, callback) {
      this.unsubscribe(eventName, callback);
    }
    /**
     * Mount an SPA plugin with comprehensive validation (CIA-compliant)
     * @param sequence - The sequence definition from the plugin
     * @param handlers - The handlers object from the plugin
     * @param pluginId - Optional plugin ID (defaults to sequence.name)
     * @returns Plugin mount result
     */
    async mount(sequence, handlers, pluginId, metadata) {
      return this.pluginInterface.mount(sequence, handlers, pluginId, metadata);
    }
    /**
     * Register CIA-compliant plugins
     * Loads and mounts all plugins from the plugins directory
     */
    async registerCIAPlugins() {
      return this.pluginInterface.registerCIAPlugins();
    }
    /**
     * Execute movement with handler validation (CIA-compliant)
     * @param sequenceId - Sequence ID identifier
     * @param movementName - Movement name
     * @param data - Data to pass to handler
     * @returns Handler execution result
     */
    executeMovementHandler(sequenceId, movementName, data) {
      return this.pluginInterface.executeMovementWithHandler(sequenceId, movementName, data);
    }
    /**
     * Load plugin from dynamic import with error handling (CIA-compliant)
     * @param pluginPath - Path to the plugin module
     * @returns Plugin load result
     */
    async loadPlugin(pluginPath) {
      return this.pluginInterface.loadPlugin(pluginPath);
    }
    /**
     * Validate plugin pre-compilation status
     * @param pluginId - Plugin identifier
     * @returns Validation result
     */
    /**
     * Unmount a plugin (CIA-compliant)
     * @param pluginId - Plugin identifier
     * @returns Success status
     */
    unmountPlugin(pluginId) {
      return this.pluginInterface.unmountPlugin(pluginId);
    }
    /**
     * Get mounted plugin information
     * @param pluginId - Plugin identifier
     * @returns Plugin information or undefined
     */
    getPluginInfo(pluginId) {
      return this.pluginInterface.getPluginInfo(pluginId);
    }
    /**
     * Get all mounted plugin IDs
     * @returns Array of plugin IDs
     */
    getMountedPluginIds() {
      return this.pluginInterface.getMountedPluginIds();
    }
    /**
     * Set priority for an event type
     * @param eventType - Event type
     * @param priority - Priority level (MUSICAL_DYNAMICS value)
     */
    setPriority(eventType, priority) {
      console.log(`\u{1F3BC} MusicalConductor: Set priority for ${eventType}: ${priority}`);
    }
    /**
     * Start a musical sequence with Sequential Orchestration and Resource Management
     * @param sequenceId - ID of the sequence to start
     * @param data - Data to pass to the sequence
     * @param priority - Priority level: 'HIGH', 'NORMAL', 'CHAINED'
     * @returns Request ID for tracking
     */
    async startSequence(sequenceIdOrName, data = {}, priority = SEQUENCE_PRIORITIES.NORMAL) {
      let resolvedId = sequenceIdOrName;
      if (!this.sequenceRegistry.has(resolvedId)) {
        const byName = this.sequenceRegistry.findByName(sequenceIdOrName);
        if (byName) {
          resolvedId = byName.id;
        }
      }
      const result = this.sequenceOrchestrator.startSequence(resolvedId, data, priority);
      if (!result.success) {
        if (result.isDuplicate) {
          return result.requestId;
        }
        const reason = result.reason || "Failed to start sequence";
        if (/not found/i.test(reason)) {
          throw new Error("Sequence not found");
        }
        throw new Error(reason);
      }
      return result.requestId;
    }
    /**
     * Create execution context for a sequence
     * @param sequenceRequest - Sequence request
     */
    createExecutionContext(sequenceRequest) {
      return this.sequenceOrchestrator.createExecutionContext(sequenceRequest);
    }
    /**
     * Get current statistics (enhanced with CIA plugin information)
     */
    getStatistics() {
      return this.conductorAPI.getStatistics();
    }
    /**
     * Get conductor status including eventBus availability
     * @returns Conductor status object
     */
    getStatus() {
      return this.conductorAPI.getStatus();
    }
    /**
     * Reset statistics
     */
    resetStatistics() {
      this.conductorAPI.resetStatistics();
      this.performanceTracker.reset();
      this.duplicationDetector.reset();
      console.log("\u{1F3BC} MusicalConductor: All monitoring data reset");
    }
    /**
     * Get queue status
     */
    getQueueStatus() {
      return this.executionQueue.getStatus();
    }
    /**
     * Emit an event through the event bus
     * @param eventType - Event type
     * @param eventData - Event data
     * @param executionContext - Execution context
     */
    emitEvent(eventType, eventData, executionContext) {
      const result = this.eventOrchestrator.emitEvent(eventType, eventData, executionContext);
      if (!result.success) {
        throw new Error(result.error || "Failed to emit event");
      }
    }
    // ===== Orchestration Validation Compliance Methods =====
    /**
     * Queue a sequence for execution (validation compliance method)
     * @param sequenceId - ID of the sequence to queue
     * @param data - Data to pass to the sequence
     * @param priority - Priority level
     * @returns Request ID for tracking
     */
    queueSequence(sequenceId, data = {}, priority = SEQUENCE_PRIORITIES.NORMAL) {
      return this.conductorAPI.queueSequence(sequenceId, data, priority);
    }
    /**
     * Execute the next sequence in queue (validation compliance method)
     * @returns Success status
     */
    executeNextSequence() {
      return this.conductorAPI.executeNextSequence();
    }
    /**
     * Check if a sequence is currently running (validation compliance method)
     * @param sequenceId - Optional sequence ID to check for specific sequence
     * @returns True if a sequence is executing (or specific sequence if ID provided)
     */
    isSequenceRunning(sequenceId) {
      return this.conductorAPI.isSequenceRunning(sequenceId);
    }
    /**
     * Get the currently executing sequence (validation compliance method)
     * @returns Current sequence execution context or null
     */
    getCurrentSequence() {
      return this.conductorAPI.getCurrentSequence();
    }
    /**
     * ðŸŽ½ Update the data baton payload for the currently executing sequence
     * This allows plugin handlers to pass data between beats
     * @param payloadData - Data to merge into the current payload
     * @returns Success status
     */
    updatePayload(payloadData) {
      return this.conductorAPI.updateDataBaton(payloadData);
    }
    /**
     * ðŸŽ½ Get the current data baton payload
     * @returns Current payload or null if no active sequence
     */
    getPayload() {
      return this.conductorAPI.getDataBaton();
    }
    /**
     * Get all queued sequences (validation compliance method)
     * @returns Array of queued sequence requests
     */
    getQueuedSequences() {
      return this.conductorAPI.getQueuedSequences();
    }
    /**
     * Install listeners to cleanup callback registry entries when sequences complete or fail
     */
    installCorrelationCleanupListeners() {
      const bus = this.eventBus;
      const registry = CallbackRegistry.getInstance();
      const onDone = (evt) => {
        try {
          const requestId = evt?.requestId;
          const corr = requestId ? this.requestCorrelationMap.get(requestId) : void 0;
          if (typeof corr === "string") {
            const remaining = (this.correlationActiveCounts.get(corr) || 1) - 1;
            if (remaining <= 0) {
              registry.cleanup(corr);
              this.correlationActiveCounts.delete(corr);
              console.log(`\u{1F3BC} MusicalConductor: cleaned callbacks for correlationId=${corr}`);
            } else {
              this.correlationActiveCounts.set(corr, remaining);
            }
            this.requestCorrelationMap.delete(requestId);
          }
        } catch {
        }
      };
      this.eventUnsubscribes.push(bus.subscribe("sequence-completed", onDone), bus.subscribe("sequence-failed", onDone), bus.subscribe("sequence-cancelled", onDone));
    }
    /**
     * Clear the sequence queue (validation compliance method)
     * @returns Number of sequences that were cleared
     */
    clearSequenceQueue() {
      return this.conductorAPI.clearSequenceQueue();
    }
    /**
     * Get resource ownership information (MCO/MSO diagnostic method)
     * @returns Resource ownership map
     */
    getResourceOwnership() {
      return this.resourceConflictManager.getResourceOwnership();
    }
    /**
     * Get symphony resource mapping (MCO/MSO diagnostic method)
     * @returns Symphony to resources mapping
     */
    getSymphonyResourceMap() {
      return this.resourceConflictManager.getSymphonyResourceMap();
    }
    /**
     * Get sequence instances (MCO/MSO diagnostic method)
     * @returns Sequence instances map
     */
    getSequenceInstances() {
      return this.resourceManager.getSequenceInstances();
    }
  };
  MusicalConductor.instance = null;

  // dist/modules/communication/sequences/index.js
  var ALL_SEQUENCES = [
    // Canvas sequences now handled by dynamic symphony plugins
  ];
  function registerAllSequences(conductor) {
    console.log("\u{1F3BC} Registering all musical sequences with conductor...");
    let registeredCount = 0;
    let failedCount = 0;
    for (const sequence of ALL_SEQUENCES) {
      try {
        conductor.registerSequence(sequence);
        registeredCount++;
        console.log(`\u2705 Registered sequence: ${sequence.name}`);
      } catch (error) {
        failedCount++;
        console.error(`\u274C Failed to register sequence: ${sequence.name}`, error);
      }
    }
    console.log(`\u{1F3BC} Sequence registration complete: ${registeredCount} registered, ${failedCount} failed`);
    const categories = new Set(ALL_SEQUENCES.map((seq) => seq.category));
    console.log(`\u{1F4CA} Sequence categories: ${Array.from(categories).join(", ")}`);
  }
  function validateAllSequences() {
    const valid = [];
    const invalid = [];
    for (const sequence of ALL_SEQUENCES) {
      const errors = [];
      if (!sequence.name)
        errors.push("Missing sequence name");
      if (!sequence.description)
        errors.push("Missing sequence description");
      if (!sequence.movements || sequence.movements.length === 0) {
        errors.push("Missing movements");
      }
      sequence.movements?.forEach((movement, movementIndex) => {
        if (!movement.name)
          errors.push(`Movement ${movementIndex}: Missing name`);
        if (!movement.beats || movement.beats.length === 0) {
          errors.push(`Movement ${movementIndex}: Missing beats`);
        }
        movement.beats?.forEach((beat, beatIndex) => {
          if (!beat.event)
            errors.push(`Movement ${movementIndex}, Beat ${beatIndex}: Missing event`);
          if (!beat.dynamics)
            errors.push(`Movement ${movementIndex}, Beat ${beatIndex}: Missing dynamics`);
        });
      });
      if (errors.length === 0) {
        valid.push(sequence.name);
      } else {
        invalid.push({ name: sequence.name, errors });
      }
    }
    return { valid, invalid };
  }
  function initializeMusicalSequences(conductor) {
    console.log("\u{1F3BC} Initializing Musical Sequences System...");
    const validationResults = validateAllSequences();
    if (validationResults.invalid.length > 0) {
      console.warn("\u26A0\uFE0F Some sequences have validation errors:", validationResults.invalid);
    }
    registerAllSequences(conductor);
    const registeredSequences = conductor.getSequenceNames().length;
    const success = registeredSequences > 0;
    console.log(`\u{1F3BC} Musical Sequences System initialized: ${success ? "SUCCESS" : "FAILED"}`);
    console.log(`\u{1F4CA} Total sequences registered: ${registeredSequences}`);
    return {
      success,
      registeredSequences,
      validationResults
    };
  }

  // dist/modules/communication/index.js
  init_SequenceTypes();
  var communicationSystemInitialized = false;
  var communicationSystemInstance = null;
  function initializeCommunicationSystem() {
    if (communicationSystemInitialized && communicationSystemInstance) {
      console.log("\u{1F3BC} Communication System already initialized, returning existing instance...");
      return communicationSystemInstance;
    }
    console.log("\u{1F3BC} Initializing RenderX Evolution Communication System...");
    const conductor = MusicalConductor.getInstance(eventBus);
    eventBus.connectToMainConductor(conductor);
    const sequenceResults = initializeMusicalSequences(conductor);
    console.log("\u2705 Communication System initialized successfully");
    console.log(`\u{1F3BC} Registered ${sequenceResults.registeredSequences} musical sequences`);
    if (sequenceResults.validationResults.invalid.length > 0) {
      console.warn("\u26A0\uFE0F Some sequences have validation issues:", sequenceResults.validationResults.invalid);
    }
    communicationSystemInstance = {
      eventBus,
      conductor,
      sequenceResults
    };
    communicationSystemInitialized = true;
    return communicationSystemInstance;
  }

  // tools/avalonia-integration/build/entry.js
  var conductorInstance;
  try {
    const sys = initializeCommunicationSystem();
    conductorInstance = sys?.conductor ?? MusicalConductor.getInstance(eventBus);
  } catch (e) {
    try {
      conductorInstance = MusicalConductor.getInstance(eventBus);
    } catch (err) {
      console.log("MusicalConductor fallback initialization failed:", err);
    }
  }
  var MC = {
    play: (pluginId, sequenceId, context, priority) => conductorInstance.play(pluginId, sequenceId, context, priority),
    getStatus: () => conductorInstance.getStatus(),
    getStatistics: () => conductorInstance.getStatistics(),
    registerCIAPlugins: (...args) => conductorInstance.registerCIAPlugins(...args),
    on: (evt, cb, ctx) => conductorInstance.on(evt, cb, ctx),
    off: (evt, cb) => conductorInstance.off(evt, cb)
  };
  if (typeof globalThis !== "undefined") {
    globalThis.MusicalConductor = MC;
  } else if (typeof window !== "undefined") {
    window.MusicalConductor = MC;
  } else if (typeof global !== "undefined") {
    global.MusicalConductor = MC;
  }
})();
