# Acceptance Criteria - renderx-web domain

[packages/canvas-component/json-sequences/canvas-component/create.json]

[packages/canvas-component/json-sequences/canvas-component/update.json]
beat: 1 handler: updateNode
- Given an existing canvas node
- When updateNode applies changes
- Then P95 latency is ≤ 500ms and node schema remains valid
- And telemetry 'node.updated' includes changedFields and duration
- Given invalid update payload
- When updateNode runs
- Then it returns 'UpdateValidationError' with invalid path
- And no side effects occur
- Given repeated identical updates
- When updateNode executes twice
- Then operation is idempotent and emits dedupe=true on second run

[packages/canvas-component/json-sequences/canvas-component/import.json]
beat: 1 handler: parseImport
- Given a valid import file (JSON/CSV)
- When parseImport runs
- Then P95 latency ≤ 1s and records parsed count equals input
- And telemetry 'import.parsed' includes format and count
beat: 2 handler: mapToNodes
- Given parsed records
- When mapToNodes runs
- Then output nodes conform to CanvasNode schema
- And errors are logged with indexes for invalid records

[packages/control-panel/json-sequences/ui.render.json]
beat: 1 handler: renderPanel
- Given control panel state
- When renderPanel runs
- Then first paint ≤ 200ms P95 and UI responds within 100ms to input
- And telemetry 'control-panel.render' includes duration and components
beat: 2 handler: applyCSS
- Given panel render completes
- When applyCSS runs
- Then styles apply deterministically with no FOUC
- And accessibility roles/labels are present
beat: 3 handler: renderView
- Given a complete view configuration with sections, fields, and rules
- When renderView is invoked
- Then the entire form renders within ≤ 500ms and all interactive elements respond
- And no console errors or warnings are emitted
- Given a large view with ≥ 200 fields
- When renderView processes it
- Then initial interaction latency is < 100ms and memory usage remains stable
- And rendering completes within ≤ 800ms under P95
- Given responsive design requirements
- When renderView renders
- Then layout adapts across desktop/tablet/mobile with readable text
- And touch targets meet ≥ 44x44px on mobile
- Given accessibility requirements (WCAG 2.1 AA)
- When renderView renders
- Then elements use semantic HTML and color contrast ≥ 4.5:1
- And keyboard navigation remains fully functional


[packages/control-panel/json-sequences/update.json]
beat: 1 handler: updateFromElement
- Given the updateFromElement operation is triggered
- When the handler executes
- Then it completes successfully within < 100ms
- And the output is valid and meets schema
- And any required events are published
- Given valid input parameters
- When updateFromElement processes them
- Then results conform to expected schema
- And no errors are thrown
- And telemetry events are recorded with latency metrics
- Given error conditions
- When updateFromElement encounters an error
- Then the error is logged with full context
- And appropriate recovery is attempted
- And the system remains stable
- Given performance SLA of < 100ms
- When updateFromElement executes
- Then latency is consistently within target
- And throughput meets baseline requirements
- And resource usage stays within bounds
- Given compliance and governance
- When updateFromElement operates
- Then all governance rules are enforced
- And audit trails capture execution
- And no compliance violations occur
beat: 2 handler: notifyUi
- Given a class change operation completes
- When notifyUi is invoked with change details
- Then an event is published to the central EventRouter within 5ms
- And the event contains element ID, action (add/remove), and class name
- And the event is stamped with microsecond-precision timestamp
- Given multiple class operations occur in sequence
- When notifyUi publishes events
- Then events are queued in FIFO order
- And subscribers receive events in the order they occurred
- And no events are dropped or duplicated
- Given a subscriber is registered for UI change events
- When notifyUi publishes
- Then the subscriber receives the event within 20ms
- And the subscriber can act on the notification
- And multiple subscribers can consume the same event
- Given the event system is congested
- When notifyUi attempts to publish
- Then the event is queued with backpressure
- And the operation does not block the caller
- And events are eventually delivered with bounded latency
- Given notification occurs during error conditions
- When notifyUi is called
- Then events are still published for traceability
- And error context is included in event payload
- And the system can reconstruct the failure chain from events

[packages/control-panel/json-sequences/classes.add.json]
beat: 1 handler: addClass
- Given element and class name
- When addClass runs
- Then class is added once, latency ≤ 5ms
- And telemetry 'ui.class.add' includes elementId and class
beat: 2 handler: notifyUi
- Given a class change operation completes
- When notifyUi is invoked with change details
- Then an event is published to the central EventRouter within 5ms
- And the event contains element ID, action (add/remove), and class name
- And the event is stamped with microsecond-precision timestamp
- Given multiple class operations occur in sequence
- When notifyUi publishes events
- Then events are queued in FIFO order
- And subscribers receive events in the order they occurred
- And no events are dropped or duplicated
- Given a subscriber is registered for UI change events
- When notifyUi publishes
- Then the subscriber receives the event within 20ms
- And the subscriber can act on the notification
- And multiple subscribers can consume the same event
- Given the event system is congested
- When notifyUi attempts to publish
- Then the event is queued with backpressure
- And the operation does not block the caller
- And events are eventually delivered with bounded latency
- Given notification occurs during error conditions
- When notifyUi is called
- Then events are still published for traceability
- And error context is included in event payload
- And the system can reconstruct the failure chain from events

[packages/control-panel/json-sequences/classes.remove.json]
beat: 1 handler: removeClass
- Given element with existing class
- When removeClass runs
- Then class is removed, latency ≤ 5ms
- And telemetry 'ui.class.remove' includes elementId and class
beat: 2 handler: notifyUi
- Given a class change operation completes
- When notifyUi is invoked with change details
- Then an event is published to the central EventRouter within 5ms
- And the event contains element ID, action (add/remove), and class name
- And the event is stamped with microsecond-precision timestamp
- Given multiple class operations occur in sequence
- When notifyUi publishes events
- Then events are queued in FIFO order
- And subscribers receive events in the order they occurred
- And no events are dropped or duplicated
- Given a subscriber is registered for UI change events
- When notifyUi publishes
- Then the subscriber receives the event within 20ms
- And the subscriber can act on the notification
- And multiple subscribers can consume the same event
- Given the event system is congested
- When notifyUi attempts to publish
- Then the event is queued with backpressure
- And the operation does not block the caller
- And events are eventually delivered with bounded latency
- Given notification occurs during error conditions
- When notifyUi is called
- Then events are still published for traceability
- And error context is included in event payload
- And the system can reconstruct the failure chain from events

[packages/control-panel/json-sequences/css.create.json]
beat: 1 handler: createRule
- Given a valid CSS rule
- When createRule runs
- Then rule is inserted into stylesheet, latency ≤ 20ms
- And telemetry 'css.rule.create' includes selector and index
beat: 2 handler: notifyUi
- Given a class change operation completes
- When notifyUi is invoked with change details
- Then an event is published to the central EventRouter within 5ms
- And the event contains element ID, action (add/remove), and class name
- And the event is stamped with microsecond-precision timestamp
- Given multiple class operations occur in sequence
- When notifyUi publishes events
- Then events are queued in FIFO order
- And subscribers receive events in the order they occurred
- And no events are dropped or duplicated
- Given a subscriber is registered for UI change events
- When notifyUi publishes
- Then the subscriber receives the event within 20ms
- And the subscriber can act on the notification
- And multiple subscribers can consume the same event
- Given the event system is congested
- When notifyUi attempts to publish
- Then the event is queued with backpressure
- And the operation does not block the caller
- And events are eventually delivered with bounded latency
- Given notification occurs during error conditions
- When notifyUi is called
- Then events are still published for traceability
- And error context is included in event payload
- And the system can reconstruct the failure chain from events

[packages/control-panel/json-sequences/css.edit.json]
beat: 1 handler: editRule
- Given existing CSS rule
- When editRule runs
- Then selector/properties update atomically with rollback on error
- And telemetry 'css.rule.edit' includes diff summary
beat: 2 handler: notifyUi
- Given a class change operation completes
- When notifyUi is invoked with change details
- Then an event is published to the central EventRouter within 5ms
- And the event contains element ID, action (add/remove), and class name
- And the event is stamped with microsecond-precision timestamp
- Given multiple class operations occur in sequence
- When notifyUi publishes events
- Then events are queued in FIFO order
- And subscribers receive events in the order they occurred
- And no events are dropped or duplicated
- Given a subscriber is registered for UI change events
- When notifyUi publishes
- Then the subscriber receives the event within 20ms
- And the subscriber can act on the notification
- And multiple subscribers can consume the same event
- Given the event system is congested
- When notifyUi attempts to publish
- Then the event is queued with backpressure
- And the operation does not block the caller
- And events are eventually delivered with bounded latency
- Given notification occurs during error conditions
- When notifyUi is called
- Then events are still published for traceability
- And error context is included in event payload
- And the system can reconstruct the failure chain from events

[packages/control-panel/json-sequences/css.delete.json]
beat: 1 handler: deleteRule
- Given rule index
- When deleteRule runs
- Then rule is removed and reflow cost ≤ baseline
- And telemetry 'css.rule.delete' includes index and cost
beat: 2 handler: notifyUi
- Given a class change operation completes
- When notifyUi is invoked with change details
- Then an event is published to the central EventRouter within 5ms
- And the event contains element ID, action (add/remove), and class name
- And the event is stamped with microsecond-precision timestamp
- Given multiple class operations occur in sequence
- When notifyUi publishes events
- Then events are queued in FIFO order
- And subscribers receive events in the order they occurred
- And no events are dropped or duplicated
- Given a subscriber is registered for UI change events
- When notifyUi publishes
- Then the subscriber receives the event within 20ms
- And the subscriber can act on the notification
- And multiple subscribers can consume the same event
- Given the event system is congested
- When notifyUi attempts to publish
- Then the event is queued with backpressure
- And the operation does not block the caller
- And events are eventually delivered with bounded latency
- Given notification occurs during error conditions
- When notifyUi is called
- Then events are still published for traceability
- And error context is included in event payload
- And the system can reconstruct the failure chain from events

[packages/control-panel/json-sequences/selection.show.json]
beat: 1 handler: showSelection
- Given selected element(s)
- When showSelection runs
- Then overlay draws within ≤ 30ms and aligns within ≤ 1px
- And telemetry 'selection.show' includes count and bounds
beat: 2 handler: notifyUi
- Given a class change operation completes
- When notifyUi is invoked with change details
- Then an event is published to the central EventRouter within 5ms
- And the event contains element ID, action (add/remove), and class name
- And the event is stamped with microsecond-precision timestamp
- Given multiple class operations occur in sequence
- When notifyUi publishes events
- Then events are queued in FIFO order
- And subscribers receive events in the order they occurred
- And no events are dropped or duplicated
- Given a subscriber is registered for UI change events
- When notifyUi publishes
- Then the subscriber receives the event within 20ms
- And the subscriber can act on the notification
- And multiple subscribers can consume the same event
- Given the event system is congested
- When notifyUi attempts to publish
- Then the event is queued with backpressure
- And the operation does not block the caller
- And events are eventually delivered with bounded latency
- Given notification occurs during error conditions
- When notifyUi is called
- Then events are still published for traceability
- And error context is included in event payload
- And the system can reconstruct the failure chain from events

[packages/control-panel/json-sequences/ui.init.json]
beat: 1 handler: initPanel
- Given application startup
- When initPanel runs
- Then panel initializes within ≤ 300ms and subscribes to events
- And telemetry 'control-panel.init' includes subscriptions

[packages/control-panel/json-sequences/ui.init.batched.json]
beat: 1 handler: initPanelBatched
- Given many components (≥ 100)
- When initPanelBatched runs
- Then batching reduces CPU by ≥ 20% versus naive init
- And telemetry 'control-panel.init.batched' includes batchSize

[packages/control-panel/json-sequences/ui.field.change.json]
beat: 1 handler: onFieldChange
- Given a user input event
- When onFieldChange runs
- Then model updates debounced ≤ 50ms and validates lazily
- And telemetry 'ui.field.change' includes field and debounce

[packages/control-panel/json-sequences/ui.field.validate.json]
beat: 1 handler: validateField
- Given field value
- When validateField runs
- Then errors are reported with code and path, latency ≤ 10ms
- And telemetry 'ui.field.validate' includes validity

[packages/control-panel/json-sequences/ui.section.toggle.json]
beat: 1 handler: toggleSection
- Given a section
- When toggleSection runs
- Then expand/collapse animates ≤ 120ms and preserves focus order
- And telemetry 'ui.section.toggle' includes state

[packages/header/json-sequences/header/ui.theme.get.json]
beat: 1 handler: getTheme
- Given theme storage
- When getTheme runs
- Then returns current theme within ≤ 10ms and emits 'theme.get'
- And telemetry includes source (storage/default)
beat: 2 handler: notifyUi
- Given a theme fetch completes
- When notifyUi is invoked
- Then an event is published to the EventRouter within 5ms
- And the event contains theme value and source
- And the event is timestamped and trace-linked

[packages/header/json-sequences/header/ui.theme.toggle.json]
beat: 1 handler: toggleTheme
- Given current theme
- When toggleTheme runs
- Then toggles between light/dark, persists setting, latency ≤ 20ms
- And telemetry 'theme.toggle' includes prev/next

[packages/library/json-sequences/library/library-load.json]
beat: 1 handler: requestLoad
- Given a library path
- When requestLoad runs
- Then emits 'library.load.requested' and validates path
- And telemetry includes path and requestId
beat: 2 handler: loadLibrary
- Given request
- When loadLibrary runs
- Then loads assets with P95 ≤ 2s, errors typed
- And telemetry 'library.load' includes size and duration

[packages/library-component/json-sequences/library-component/index.json]
beat: 1 handler: initLibraryComponent
- Given library component registry
- When initLibraryComponent runs
- Then registers components, latency ≤ 200ms and exposes APIs
- And telemetry 'library.component.init' includes count

[packages/library-component/json-sequences/library-component/drag.json]
beat: 1 handler: dragStart
- Given pointer down
- When dragStart runs
- Then starts drag within ≤ 16ms and sets data payload
- And telemetry 'drag.start' includes elementId

[packages/library-component/json-sequences/library-component/drop.json]
beat: 1 handler: onDrop
- Given valid drop target
- When onDrop runs
- Then composes node and validates schema; latency ≤ 150ms
- And telemetry 'drop' includes target and success

[packages/library-component/json-sequences/library-component/container.drop.json]
beat: 1 handler: onContainerDrop
- Given container target
- When onContainerDrop runs
- Then inserts child at index, reflows minimal, latency ≤ 150ms
- And telemetry includes containerId and index
