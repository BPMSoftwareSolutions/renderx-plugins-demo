# Desktop JSON Artifacts & TDD Validation Guide üèóÔ∏è

## Overview

The desktop shell must leverage the **SAME JSON artifacts** as the web version to ensure parity and maintain a single source of truth. This guide explains:

1. **What JSON files are used** and where they come from
2. **How the desktop shell should consume them**
3. **Pre-build steps required** to generate/sync JSON files
4. **TDD approach** with Roslyn analyzer validation
5. **ESLint/Roslyn guardrails** to enforce correct usage

---

## JSON Artifacts (Single Source of Truth)

### 1. Plugin Manifest
**File**: `wwwroot/plugins/plugin-manifest.json`  
**Purpose**: Defines all plugins, their UI slots, assemblies, and runtime handlers  
**Source**: Generated from plugin discovery or manually maintained  
**Desktop Usage**: Loaded by `IPluginLoader` to discover and instantiate plugins

```json
{
  "plugins": [
    {
      "id": "CanvasPlugin",
      "ui": {
        "slot": "canvas",
        "assembly": "RenderX.Plugins.Canvas",
        "type": "RenderX.Plugins.Canvas.CanvasControl"
      },
      "runtime": {
        "assembly": "RenderX.Plugins.Canvas",
        "type": "RenderX.Plugins.Canvas.CanvasPlugin",
        "method": "Register"
      }
    }
  ]
}
```

### 2. Interaction Manifest
**File**: `wwwroot/interaction-manifest.json`  
**Purpose**: Maps interaction keys to plugin sequences  
**Source**: Generated by `scripts/generate-interaction-manifest.js`  
**Desktop Usage**: Loaded by conductor to route events to correct sequences

### 3. Topics Manifest
**File**: `wwwroot/topics-manifest.json`  
**Purpose**: Defines event topics and their schemas  
**Source**: Generated by `scripts/generate-topics-manifest.js`  
**Desktop Usage**: Loaded by event router for type-safe event publishing

### 4. Component Definitions
**Directory**: `json-components/`  
**Purpose**: JSON definitions of UI components (canvas, library, etc.)  
**Source**: Synced from `catalog/json-components/` or npm packages  
**Desktop Usage**: Loaded by canvas plugin to render components

### 5. Sequences
**Directory**: `json-sequences/`  
**Purpose**: JSON definitions of musical sequences  
**Source**: Synced from `catalog/json-sequences/` or npm packages  
**Desktop Usage**: Loaded by conductor for sequence execution

---

## Pre-Build Steps (Desktop Shell)

### Step 1: Sync JSON Sources
**Command**: `npm run pre:manifests`  
**What it does**:
- Copies `catalog/json-components/` ‚Üí `json-components/`
- Copies `catalog/json-sequences/` ‚Üí `json-sequences/`
- Discovers npm packages with `renderx.components` and `renderx.sequences`
- Merges all sources into single directories

**Why**: Desktop shell needs access to all component and sequence definitions

### Step 2: Generate Manifests
**Command**: `npm run pre:manifests` (includes all steps)  
**What it does**:
- Generates `interaction-manifest.json` from plugin catalogs
- Generates `topics-manifest.json` from topic definitions
- Generates `layout-manifest.json` from layout definitions
- Aggregates all plugin metadata

**Why**: Manifests are the single source of truth for plugin discovery

### Step 3: Copy to wwwroot
**Command**: Automatic (part of build process)  
**What it does**:
- Copies manifests to `wwwroot/` for runtime access
- Copies component/sequence JSON to `wwwroot/` for conductor

**Why**: Desktop shell loads these at runtime via `IPluginLoader`

---

## TDD Approach: Roslyn Validation Workflow

### Workflow: Red ‚Üí Green ‚Üí Refactor

#### 1. RED: Run Roslyn Analyzer
```powershell
# Build will fail with SHELL001/SHELL002 violations
dotnet build src/RenderX.Shell.Avalonia/RenderX.Shell.Avalonia.csproj
```

**Expected Output**:
```
error SHELL002: MainWindow must not directly instantiate plugin controls.
Violation: Direct instantiation of CanvasControl [MainWindow.axaml.cs:69]
```

#### 2. GREEN: Fix Violations
- Implement `IPluginLoader` interface
- Implement `PluginLoader` class
- Create `SlotContainer` control
- Update `MainWindow.axaml.cs` to use plugin loader
- Remove hardcoded plugin imports

#### 3. VERIFY: Run Analyzer Again
```powershell
# Build should succeed with NO violations
dotnet build src/RenderX.Shell.Avalonia/RenderX.Shell.Avalonia.csproj
```

**Expected Output**:
```
Build succeeded. 0 errors, 0 warnings.
```

---

## Roslyn Guardrails (Automated Enforcement)

### SHELL001: Thin-Host Architecture
**Detects**: Forbidden imports from custom SDK implementations  
**Forbidden**:
```csharp
‚ùå using RenderX.Shell.Avalonia.Core.Conductor.*;
‚ùå using RenderX.Shell.Avalonia.Core.Events.*;
```

**Correct**:
```csharp
‚úÖ var conductor = _serviceProvider.GetRequiredService<IConductorClient>();
```

### SHELL002: Plugin Decoupling
**Detects**: Hardcoded plugin instantiation in MainWindow  
**Forbidden**:
```csharp
‚ùå using RenderX.Shell.Avalonia.UI.Views;
‚ùå new CanvasControl();
‚ùå new ControlPanelControl();
```

**Correct**:
```csharp
‚úÖ var pluginLoader = _serviceProvider.GetRequiredService<IPluginLoader>();
‚úÖ var manifest = await pluginLoader.LoadManifestAsync();
‚úÖ var slots = this.FindControls<SlotContainer>();
```

---

## ESLint Guardrails (Web Version Reference)

The web version has ESLint rules that enforce:
- ‚úÖ Sequences defined in JSON (not hardcoded)
- ‚úÖ Interactions routed via manifest (not hardcoded)
- ‚úÖ Topics validated against manifest
- ‚úÖ Components loaded from JSON (not hardcoded)

**Desktop equivalent**: Roslyn analyzer enforces same patterns

---

## For Future Agents: TDD Checklist

### Before Starting Phase 3B
- [ ] Read this guide completely
- [ ] Understand JSON artifact flow (manifest ‚Üí loader ‚Üí slots)
- [ ] Understand pre-build steps (sync ‚Üí generate ‚Üí copy)
- [ ] Understand TDD workflow (red ‚Üí green ‚Üí verify)

### During Implementation
- [ ] Run `npm run pre:manifests` before building
- [ ] Run `dotnet build` and verify SHELL002 violations appear
- [ ] Implement IPluginLoader, PluginLoader, SlotContainer
- [ ] Run `dotnet build` and verify violations disappear
- [ ] Verify `plugin-manifest.json` is loaded correctly
- [ ] Verify plugins are instantiated via reflection

### After Implementation
- [ ] All SHELL001/SHELL002 violations fixed
- [ ] Build succeeds with 0 errors
- [ ] Plugins load dynamically from manifest
- [ ] No hardcoded plugin imports in MainWindow
- [ ] Parity with web version achieved

---

## Key Principle: Single Source of Truth

| Artifact | Source | Desktop Usage |
|----------|--------|---------------|
| **plugin-manifest.json** | Plugin discovery | IPluginLoader reads at startup |
| **interaction-manifest.json** | Generated from plugins | Conductor routes events |
| **topics-manifest.json** | Generated from definitions | EventRouter validates topics |
| **json-components/** | Synced from catalog | Canvas plugin renders |
| **json-sequences/** | Synced from catalog | Conductor executes |

**Rule**: Never hardcode what should come from JSON manifests.

---

## References

- **ARCHITECTURE_RULES_FOR_AGENTS.md** - Strict rules
- **ADR-0024-Desktop-Plugin-Decoupling.md** - Architecture decision
- **SHELL002_VIOLATIONS_GUIDE.md** - Step-by-step fix guide
- **package.json** - Pre-build scripts (`pre:manifests`)

