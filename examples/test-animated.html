<!DOCTYPE html>
<html>
  <head>
    <title>Test Animated SVG for GIF Export</title>
    <style>
      body {
        margin: 20px;
        font-family: Arial, sans-serif;
      }
      #test-svg {
        border: 1px solid #ccc;
        margin: 20px 0;
      }
      button {
        margin: 5px;
        padding: 10px;
      }
    </style>
  </head>
  <body>
    <h1>Test Animated SVG for GIF Export</h1>

    <svg
      id="test-svg"
      width="400"
      height="300"
      viewBox="0 0 400 300"
      xmlns="http://www.w3.org/2000/svg"
    >
      <!-- Background -->
      <rect width="400" height="300" fill="#f0f8ff" />

      <!-- Rotating square -->
      <rect
        id="rotating-square"
        x="50"
        y="50"
        width="40"
        height="40"
        fill="#ff6b6b"
        transform-origin="70 70"
      />

      <!-- Scaling circle -->
      <circle id="scaling-circle" cx="200" cy="100" r="20" fill="#4ecdc4" />

      <!-- Moving triangle -->
      <polygon
        id="moving-triangle"
        points="300,50 320,90 280,90"
        fill="#45b7d1"
      />

      <!-- Fading text -->
      <text
        id="fading-text"
        x="150"
        y="200"
        font-size="24"
        fill="#96ceb4"
        text-anchor="middle"
      >
        Animated!
      </text>

      <!-- Stroke animation line -->
      <path
        id="drawing-line"
        d="M 50 250 Q 200 200 350 250"
        stroke="#feca57"
        stroke-width="4"
        fill="none"
        stroke-dasharray="300"
        stroke-dashoffset="300"
      />
    </svg>

    <div>
      <button onclick="exportStaticGif()">Export Static GIF</button>
      <button onclick="exportAnimatedGif()">Export Animated GIF</button>
      <button onclick="testAnimation()">Test Animation in Browser</button>
    </div>

    <script type="module">
      // Mock GIF.js for testing
      class MockGIF {
        constructor(options) {
          this.options = options;
          this.frames = [];
        }

        addFrame(canvas, options) {
          console.log("Adding frame to GIF:", { canvas, options });
          this.frames.push({ canvas, options });
        }

        on(event, callback) {
          if (event === "finished") {
            setTimeout(() => {
              const blob = new Blob(["fake-gif-data"], { type: "image/gif" });
              callback(blob);
            }, 100);
          }
          if (event === "progress") {
            // Mock progress updates
            setTimeout(() => callback(0.5), 50);
            setTimeout(() => callback(1.0), 90);
          }
        }

        render() {
          console.log("Rendering GIF with", this.frames.length, "frames");
        }
      }

      // Mock conductor for testing
      window.conductor = {
        play: async (pluginId, sequenceId, payload) => {
          console.log("Mock conductor.play called:", {
            pluginId,
            sequenceId,
            payload,
          });

          // Simulate the GIF export handler directly
          try {
            const targetId = payload.targetId;
            const options = payload.options || {};

            const svgEl = document.getElementById(targetId);
            if (!svgEl) {
              throw new Error(`SVG element with id "${targetId}" not found`);
            }

            console.log("Found SVG element:", svgEl);

            // Get dimensions
            const rect = svgEl.getBoundingClientRect();
            const width = options.width || rect.width || 400;
            const height = options.height || rect.height || 300;

            console.log("Export dimensions:", { width, height });

            // Animation parameters
            const keyframes = options.animation?.keyframes || [];
            const fps = Math.max(1, Math.floor(options.fps || 5));
            const durationMs = Math.max(0, Math.floor(options.durationMs || 0));
            const totalFrames =
              durationMs > 0
                ? Math.max(2, Math.round((fps * durationMs) / 1000))
                : 1;
            const frameDelay =
              totalFrames <= 1 ? 100 : Math.max(1, Math.round(1000 / fps));

            console.log("Animation params:", {
              keyframes: keyframes.length,
              fps,
              durationMs,
              totalFrames,
              frameDelay,
            });

            // Create mock GIF encoder
            const gif = new MockGIF({
              workers: 2,
              quality: 10,
              repeat: 0,
              width,
              height,
            });

            // Create canvas for rendering
            const canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext("2d");

            // Helper function for linear interpolation
            const lerp = (a, b, t) => a + (b - a) * t;

            // Generate frames
            for (let frameIndex = 0; frameIndex < totalFrames; frameIndex++) {
              const t = totalFrames > 1 ? frameIndex / (totalFrames - 1) : 0;

              console.log(
                `Generating frame ${
                  frameIndex + 1
                }/${totalFrames} (t=${t.toFixed(2)})`
              );

              // Clone SVG for this frame
              const svgClone = svgEl.cloneNode(true);
              svgClone.setAttribute("width", String(width));
              svgClone.setAttribute("height", String(height));

              // Apply keyframe animations
              if (keyframes && keyframes.length) {
                for (const k of keyframes) {
                  const nodes = svgClone.querySelectorAll(k.selector);
                  const val = lerp(Number(k.from), Number(k.to), t);

                  nodes.forEach((node) => {
                    try {
                      if (k.kind === "rotate") {
                        const bb = node.getBBox?.() || {
                          x: 0,
                          y: 0,
                          width: 20,
                          height: 20,
                        };
                        const cx = bb.x + bb.width / 2;
                        const cy = bb.y + bb.height / 2;
                        node.setAttribute(
                          "transform",
                          `rotate(${val} ${cx} ${cy})`
                        );
                      } else if (k.kind === "scale") {
                        const bb = node.getBBox?.() || {
                          x: 0,
                          y: 0,
                          width: 20,
                          height: 20,
                        };
                        const cx = bb.x + bb.width / 2;
                        const cy = bb.y + bb.height / 2;
                        node.setAttribute(
                          "transform",
                          `translate(${cx} ${cy}) scale(${val}) translate(${-cx} ${-cy})`
                        );
                      } else {
                        node.setAttribute(k.attr, String(val));
                      }
                      console.log(
                        `Applied ${k.selector} ${k.attr}=${val} (kind=${
                          k.kind || "attr"
                        })`
                      );
                    } catch (e) {
                      console.warn("Failed to apply keyframe:", e);
                    }
                  });
                }
              }

              // Serialize SVG to data URL
              const serializer = new XMLSerializer();
              const svgString = serializer.serializeToString(svgClone);
              const dataUrl = `data:image/svg+xml;base64,${btoa(svgString)}`;

              // Draw to canvas (simulate)
              const ctx = canvas.getContext("2d");
              ctx.clearRect(0, 0, width, height);
              ctx.fillStyle = "#ffffff";
              ctx.fillRect(0, 0, width, height);

              // Add frame to GIF
              gif.addFrame(canvas, { delay: frameDelay, copy: true });
            }

            // Render and download
            gif.render();

            console.log("GIF export completed successfully!");
          } catch (error) {
            console.error("Failed to export GIF:", error);
          }
        },
      };

      window.exportStaticGif = () => {
        conductor.play(
          "CanvasComponentExportGifPlugin",
          "canvas-component-export-gif-symphony",
          {
            targetId: "test-svg",
            options: {
              width: 400,
              height: 300,
            },
          }
        );
      };

      window.exportAnimatedGif = () => {
        conductor.play(
          "CanvasComponentExportGifPlugin",
          "canvas-component-export-gif-symphony",
          {
            targetId: "test-svg",
            options: {
              width: 400,
              height: 300,
              fps: 10,
              durationMs: 2000,
              animation: {
                keyframes: [
                  {
                    selector: "#rotating-square",
                    attr: "transform",
                    from: 0,
                    to: 360,
                    kind: "rotate",
                  },
                  {
                    selector: "#scaling-circle",
                    attr: "transform",
                    from: 1.0,
                    to: 1.5,
                    kind: "scale",
                  },
                  {
                    selector: "#moving-triangle",
                    attr: "transform",
                    from: 0,
                    to: 100,
                  },
                  {
                    selector: "#fading-text",
                    attr: "opacity",
                    from: 1.0,
                    to: 0.3,
                  },
                  {
                    selector: "#drawing-line",
                    attr: "stroke-dashoffset",
                    from: 300,
                    to: 0,
                  },
                ],
              },
            },
          }
        );
      };

      window.testAnimation = () => {
        const svg = document.getElementById("test-svg");
        const square = document.getElementById("rotating-square");
        const circle = document.getElementById("scaling-circle");
        const triangle = document.getElementById("moving-triangle");
        const text = document.getElementById("fading-text");
        const line = document.getElementById("drawing-line");

        // Add CSS animations for browser preview
        const style = document.createElement("style");
        style.textContent = `
                @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
                @keyframes scale { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.5); } }
                @keyframes move { from { transform: translateX(0); } to { transform: translateX(100px); } }
                @keyframes fade { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
                @keyframes draw { from { stroke-dashoffset: 300; } to { stroke-dashoffset: 0; } }
                
                #rotating-square { animation: rotate 2s linear infinite; }
                #scaling-circle { animation: scale 2s ease-in-out infinite; }
                #moving-triangle { animation: move 2s ease-in-out infinite; }
                #fading-text { animation: fade 2s ease-in-out infinite; }
                #drawing-line { animation: draw 2s ease-in-out infinite; }
            `;
        document.head.appendChild(style);
      };
    </script>
  </body>
</html>
